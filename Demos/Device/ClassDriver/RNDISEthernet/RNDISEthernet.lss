
RNDISEthernet.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000f8  00800100  00002e4e  00002ee2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002e4e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001225  008001f8  008001f8  00002fda  2**0
                  ALLOC
  3 .debug_aranges 00000670  00000000  00000000  00002fda  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000010cd  00000000  00000000  0000364a  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000a757  00000000  00000000  00004717  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00002de2  00000000  00000000  0000ee6e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00007f0d  00000000  00000000  00011c50  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000960  00000000  00000000  00019b60  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00003dea  00000000  00000000  0001a4c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000044fc  00000000  00000000  0001e2aa  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000758  00000000  00000000  000227a6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
	return true;
#endif
}

void Endpoint_ClearEndpoints(void)
{
       0:	10 c2       	rjmp	.+1056   	; 0x422 <__ctors_end>
	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = USB_MODE_None;
	#endif

	USB_IsInitialized = false;
}
       2:	00 00       	nop

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
       4:	2c c2       	rjmp	.+1112   	; 0x45e <__bad_interrupt>

	return Serial_ReceiveByte();
}

int Serial_getchar_Blocking(FILE *Stream)
{
       6:	00 00       	nop
       8:	2a c2       	rjmp	.+1108   	; 0x45e <__bad_interrupt>
       a:	00 00       	nop
       c:	28 c2       	rjmp	.+1104   	; 0x45e <__bad_interrupt>
       e:	00 00       	nop
      10:	26 c2       	rjmp	.+1100   	; 0x45e <__bad_interrupt>
      12:	00 00       	nop
      14:	24 c2       	rjmp	.+1096   	; 0x45e <__bad_interrupt>
      16:	00 00       	nop
      18:	22 c2       	rjmp	.+1092   	; 0x45e <__bad_interrupt>
      1a:	00 00       	nop
      1c:	20 c2       	rjmp	.+1088   	; 0x45e <__bad_interrupt>
      1e:	00 00       	nop
      20:	1e c2       	rjmp	.+1084   	; 0x45e <__bad_interrupt>
      22:	00 00       	nop
      24:	1c c2       	rjmp	.+1080   	; 0x45e <__bad_interrupt>
      26:	00 00       	nop
      28:	0c 94 57 0e 	jmp	0x1cae	; 0x1cae <__vector_10>
      2c:	18 c2       	rjmp	.+1072   	; 0x45e <__bad_interrupt>
      2e:	00 00       	nop
      30:	16 c2       	rjmp	.+1068   	; 0x45e <__bad_interrupt>
      32:	00 00       	nop
      34:	14 c2       	rjmp	.+1064   	; 0x45e <__bad_interrupt>
      36:	00 00       	nop
      38:	12 c2       	rjmp	.+1060   	; 0x45e <__bad_interrupt>
      3a:	00 00       	nop
      3c:	10 c2       	rjmp	.+1056   	; 0x45e <__bad_interrupt>
      3e:	00 00       	nop
      40:	0e c2       	rjmp	.+1052   	; 0x45e <__bad_interrupt>
      42:	00 00       	nop
      44:	0c c2       	rjmp	.+1048   	; 0x45e <__bad_interrupt>
      46:	00 00       	nop
      48:	0a c2       	rjmp	.+1044   	; 0x45e <__bad_interrupt>
      4a:	00 00       	nop
      4c:	08 c2       	rjmp	.+1040   	; 0x45e <__bad_interrupt>
      4e:	00 00       	nop
      50:	06 c2       	rjmp	.+1036   	; 0x45e <__bad_interrupt>
      52:	00 00       	nop
      54:	04 c2       	rjmp	.+1032   	; 0x45e <__bad_interrupt>
      56:	00 00       	nop
      58:	02 c2       	rjmp	.+1028   	; 0x45e <__bad_interrupt>
      5a:	00 00       	nop
      5c:	00 c2       	rjmp	.+1024   	; 0x45e <__bad_interrupt>
      5e:	00 00       	nop
      60:	fe c1       	rjmp	.+1020   	; 0x45e <__bad_interrupt>
      62:	00 00       	nop
      64:	fc c1       	rjmp	.+1016   	; 0x45e <__bad_interrupt>
      66:	00 00       	nop
      68:	fa c1       	rjmp	.+1012   	; 0x45e <__bad_interrupt>
      6a:	00 00       	nop
      6c:	f8 c1       	rjmp	.+1008   	; 0x45e <__bad_interrupt>
      6e:	00 00       	nop
      70:	f6 c1       	rjmp	.+1004   	; 0x45e <__bad_interrupt>
      72:	00 00       	nop
      74:	f4 c1       	rjmp	.+1000   	; 0x45e <__bad_interrupt>
      76:	00 00       	nop
      78:	f2 c1       	rjmp	.+996    	; 0x45e <__bad_interrupt>
      7a:	00 00       	nop
      7c:	f0 c1       	rjmp	.+992    	; 0x45e <__bad_interrupt>
      7e:	00 00       	nop
      80:	ee c1       	rjmp	.+988    	; 0x45e <__bad_interrupt>
      82:	00 00       	nop
      84:	ec c1       	rjmp	.+984    	; 0x45e <__bad_interrupt>
      86:	00 00       	nop
      88:	ea c1       	rjmp	.+980    	; 0x45e <__bad_interrupt>
      8a:	00 00       	nop
      8c:	e8 c1       	rjmp	.+976    	; 0x45e <__bad_interrupt>
      8e:	00 00       	nop
      90:	e6 c1       	rjmp	.+972    	; 0x45e <__bad_interrupt>
      92:	00 00       	nop
      94:	e4 c1       	rjmp	.+968    	; 0x45e <__bad_interrupt>
      96:	00 00       	nop

00000098 <DeviceDescriptor>:
      98:	12 01 10 01 02 00 00 08 eb 03 4c 20 01 00 01 02     ..........L ....
      a8:	00 01                                               ..

000000aa <ConfigurationDescriptor>:
      aa:	09 02 3e 00 02 01 00 c0 32 09 04 00 00 01 02 02     ..>.....2.......
      ba:	ff 00 05 24 00 10 01 04 24 02 00 05 24 06 00 01     ...$....$...$...
      ca:	07 05 83 03 08 00 ff 09 04 01 00 02 0a 00 00 00     ................
      da:	07 05 02 02 40 00 01 07 05 81 02 40 00 01           ....@......@..

000000e8 <LanguageString>:
      e8:	04 03 09 04                                         ....

000000ec <ManufacturerString>:
      ec:	18 03 44 00 65 00 61 00 6e 00 20 00 43 00 61 00     ..D.e.a.n. .C.a.
      fc:	6d 00 65 00 72 00 61 00 00 00                       m.e.r.a...

00000106 <ProductString>:
     106:	28 03 4c 00 55 00 46 00 41 00 20 00 52 00 4e 00     (.L.U.F.A. .R.N.
     116:	44 00 49 00 53 00 20 00 43 00 44 00 43 00 20 00     D.I.S. .C.D.C. .
     126:	44 00 65 00 6d 00 6f 00 00 00                       D.e.m.o...

00000130 <HTTP200Header>:
     130:	48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d     HTTP/1.1 200 OK.
     140:	0a 53 65 72 76 65 72 3a 20 4c 55 46 41 20 52 4e     .Server: LUFA RN
     150:	44 49 53 0d 0a 43 6f 6e 74 65 6e 74 2d 74 79 70     DIS..Content-typ
     160:	65 3a 20 74 65 78 74 2f 68 74 6d 6c 0d 0a 43 6f     e: text/html..Co
     170:	6e 6e 65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d     nnection: close.
     180:	0a 0d 0a 00                                         ....

00000184 <HTTP404Header>:
     184:	48 54 54 50 2f 31 2e 31 20 34 30 34 20 4e 6f 74     HTTP/1.1 404 Not
     194:	20 46 6f 75 6e 64 0d 0a 53 65 72 76 65 72 3a 20      Found..Server: 
     1a4:	4c 55 46 41 20 52 4e 44 49 53 0d 0a 43 6f 6e 6e     LUFA RNDIS..Conn
     1b4:	65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d 0a 0d     ection: close...
     1c4:	0a 00                                               ..

000001c6 <HTTPPage>:
     1c6:	3c 68 74 6d 6c 3e 09 3c 68 65 61 64 3e 09 09 3c     <html>.<head>..<
     1d6:	74 69 74 6c 65 3e 09 09 09 4c 55 46 41 20 57 65     title>...LUFA We
     1e6:	62 73 65 72 76 65 72 20 44 65 6d 6f 09 09 3c 2f     bserver Demo..</
     1f6:	74 69 74 6c 65 3e 09 3c 2f 68 65 61 64 3e 09 3c     title>.</head>.<
     206:	62 6f 64 79 3e 09 09 3c 68 31 3e 48 65 6c 6c 6f     body>..<h1>Hello
     216:	20 66 72 6f 6d 20 79 6f 75 72 20 55 53 42 20 41      from your USB A
     226:	56 52 21 3c 2f 68 31 3e 09 09 3c 70 3e 09 09 09     VR!</h1>..<p>...
     236:	48 65 6c 6c 6f 21 20 57 65 6c 63 6f 6d 65 20 74     Hello! Welcome t
     246:	6f 20 74 68 65 20 4c 55 46 41 20 52 4e 44 49 53     o the LUFA RNDIS
     256:	20 44 65 6d 6f 20 57 65 62 73 65 72 76 65 72 20      Demo Webserver 
     266:	74 65 73 74 20 70 61 67 65 2c 20 72 75 6e 6e 69     test page, runni
     276:	6e 67 20 6f 6e 20 79 6f 75 72 20 55 53 42 20 41     ng on your USB A
     286:	56 52 20 76 69 61 20 74 68 65 20 4c 55 46 41 20     VR via the LUFA 
     296:	6c 69 62 72 61 72 79 2e 20 54 68 69 73 20 64 65     library. This de
     2a6:	6d 6f 6e 73 74 72 61 74 65 73 20 74 68 65 20 48     monstrates the H
     2b6:	54 54 50 20 77 65 62 73 65 72 76 65 72 2c 20 54     TTP webserver, T
     2c6:	43 50 2f 49 50 20 73 74 61 63 6b 20 61 6e 64 20     CP/IP stack and 
     2d6:	52 4e 44 49 53 20 64 65 6d 6f 20 61 6c 6c 20 72     RNDIS demo all r
     2e6:	75 6e 6e 69 6e 67 20 61 74 6f 70 20 74 68 65 20     unning atop the 
     2f6:	4c 55 46 41 20 55 53 42 20 73 74 61 63 6b 2e 09     LUFA USB stack..
     306:	09 09 3c 62 72 20 2f 3e 3c 62 72 20 2f 3e 09 09     ..<br /><br />..
     316:	09 3c 73 6d 61 6c 6c 3e 50 72 6f 6a 65 63 74 20     .<small>Project 
     326:	49 6e 66 6f 72 6d 61 74 69 6f 6e 3a 20 3c 61 20     Information: <a 
     336:	68 72 65 66 3d 22 68 74 74 70 3a 2f 2f 77 77 77     href="http://www
     346:	2e 6c 75 66 61 2d 6c 69 62 2e 6f 72 67 22 3e 68     .lufa-lib.org">h
     356:	74 74 70 3a 2f 2f 77 77 77 2e 6c 75 66 61 2d 6c     ttp://www.lufa-l
     366:	69 62 2e 6f 72 67 3c 2f 61 3e 2e 3c 2f 73 6d 61     ib.org</a>.</sma
     376:	6c 6c 3e 09 09 09 3c 68 72 20 2f 3e 09 09 09 3c     ll>...<hr />...<
     386:	69 3e 4c 55 46 41 20 56 65 72 73 69 6f 6e 3a 20     i>LUFA Version: 
     396:	3c 2f 69 3e 31 32 30 32 31 39 09 09 3c 2f 70 3e     </i>120219..</p>
     3a6:	09 3c 2f 62 6f 64 79 3e 3c 2f 68 74 6d 6c 3e 00     .</body></html>.

000003b6 <AdapterSupportedOIDList>:
     3b6:	01 01 01 00 02 02 01 00 02 01 01 00 03 01 01 00     ................
     3c6:	04 01 01 00 06 01 01 00 11 01 01 00 07 01 01 00     ................
     3d6:	0a 01 01 00 0b 01 01 00 0c 01 01 00 0d 01 01 00     ................
     3e6:	0e 01 01 00 11 01 01 00 14 01 01 00 01 01 02 00     ................
     3f6:	02 01 02 00 03 01 02 00 04 01 02 00 05 01 02 00     ................
     406:	01 01 01 01 02 01 01 01 03 01 01 01 04 01 01 01     ................
     416:	01 01 02 01 02 01 02 01 03 01 02 01                 ............

00000422 <__ctors_end>:
     422:	11 24       	eor	r1, r1
     424:	1f be       	out	0x3f, r1	; 63
     426:	cf ef       	ldi	r28, 0xFF	; 255
     428:	d0 e2       	ldi	r29, 0x20	; 32
     42a:	de bf       	out	0x3e, r29	; 62
     42c:	cd bf       	out	0x3d, r28	; 61

0000042e <__do_copy_data>:
     42e:	11 e0       	ldi	r17, 0x01	; 1
     430:	a0 e0       	ldi	r26, 0x00	; 0
     432:	b1 e0       	ldi	r27, 0x01	; 1
     434:	ee e4       	ldi	r30, 0x4E	; 78
     436:	fe e2       	ldi	r31, 0x2E	; 46
     438:	00 e0       	ldi	r16, 0x00	; 0
     43a:	0b bf       	out	0x3b, r16	; 59
     43c:	02 c0       	rjmp	.+4      	; 0x442 <__do_copy_data+0x14>
     43e:	07 90       	elpm	r0, Z+
     440:	0d 92       	st	X+, r0
     442:	a8 3f       	cpi	r26, 0xF8	; 248
     444:	b1 07       	cpc	r27, r17
     446:	d9 f7       	brne	.-10     	; 0x43e <__do_copy_data+0x10>

00000448 <__do_clear_bss>:
     448:	14 e1       	ldi	r17, 0x14	; 20
     44a:	a8 ef       	ldi	r26, 0xF8	; 248
     44c:	b1 e0       	ldi	r27, 0x01	; 1
     44e:	01 c0       	rjmp	.+2      	; 0x452 <.do_clear_bss_start>

00000450 <.do_clear_bss_loop>:
     450:	1d 92       	st	X+, r1

00000452 <.do_clear_bss_start>:
     452:	ad 31       	cpi	r26, 0x1D	; 29
     454:	b1 07       	cpc	r27, r17
     456:	e1 f7       	brne	.-8      	; 0x450 <.do_clear_bss_loop>
     458:	4f d0       	rcall	.+158    	; 0x4f8 <main>
     45a:	0c 94 25 17 	jmp	0x2e4a	; 0x2e4a <_exit>

0000045e <__bad_interrupt>:
     45e:	d0 cd       	rjmp	.-1120   	; 0x0 <__vectors>

00000460 <EVENT_USB_Device_Connect>:
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
     460:	8b b1       	in	r24, 0x0b	; 11
     462:	8f 70       	andi	r24, 0x0F	; 15
     464:	80 6a       	ori	r24, 0xA0	; 160
     466:	8b b9       	out	0x0b, r24	; 11

/** Event handler for the library USB Connection event. */
void EVENT_USB_Device_Connect(void)
{
	LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);
}
     468:	08 95       	ret

0000046a <EVENT_USB_Device_Disconnect>:
     46a:	8b b1       	in	r24, 0x0b	; 11
     46c:	8f 70       	andi	r24, 0x0F	; 15
     46e:	80 61       	ori	r24, 0x10	; 16
     470:	8b b9       	out	0x0b, r24	; 11

/** Event handler for the library USB Disconnection event. */
void EVENT_USB_Device_Disconnect(void)
{
	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
}
     472:	08 95       	ret

00000474 <EVENT_USB_Device_ControlRequest>:
}

/** Event handler for the library USB Control Request reception event. */
void EVENT_USB_Device_ControlRequest(void)
{
	RNDIS_Device_ProcessControlRequest(&Ethernet_RNDIS_Interface);
     474:	88 e1       	ldi	r24, 0x18	; 24
     476:	91 e0       	ldi	r25, 0x01	; 1
     478:	0c 94 c4 13 	jmp	0x2788	; 0x2788 <RNDIS_Device_ProcessControlRequest>

0000047c <EVENT_USB_Device_ConfigurationChanged>:
/** Event handler for the library USB Configuration Changed event. */
void EVENT_USB_Device_ConfigurationChanged(void)
{
	bool ConfigSuccess = true;

	ConfigSuccess &= RNDIS_Device_ConfigureEndpoints(&Ethernet_RNDIS_Interface);
     47c:	88 e1       	ldi	r24, 0x18	; 24
     47e:	91 e0       	ldi	r25, 0x01	; 1
     480:	0e 94 74 13 	call	0x26e8	; 0x26e8 <RNDIS_Device_ConfigureEndpoints>

	LEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);
     484:	80 fd       	sbrc	r24, 0
     486:	02 c0       	rjmp	.+4      	; 0x48c <EVENT_USB_Device_ConfigurationChanged+0x10>
     488:	90 e9       	ldi	r25, 0x90	; 144
     48a:	01 c0       	rjmp	.+2      	; 0x48e <EVENT_USB_Device_ConfigurationChanged+0x12>
     48c:	90 e6       	ldi	r25, 0x60	; 96
     48e:	8b b1       	in	r24, 0x0b	; 11
     490:	8f 70       	andi	r24, 0x0F	; 15
     492:	98 2b       	or	r25, r24
     494:	9b b9       	out	0x0b, r25	; 11
}
     496:	08 95       	ret

00000498 <SetupHardware>:

/** Configures the board hardware and chip peripherals for the demo's functionality. */
void SetupHardware(void)
{
	/* Disable watchdog if enabled by bootloader/fuses */
	MCUSR &= ~(1 << WDRF);
     498:	84 b7       	in	r24, 0x34	; 52
     49a:	87 7f       	andi	r24, 0xF7	; 247
     49c:	84 bf       	out	0x34, r24	; 52
	wdt_disable();
     49e:	38 e1       	ldi	r19, 0x18	; 24
     4a0:	0f b6       	in	r0, 0x3f	; 63
     4a2:	f8 94       	cli
     4a4:	30 93 60 00 	sts	0x0060, r19
     4a8:	10 92 60 00 	sts	0x0060, r1
     4ac:	0f be       	out	0x3f, r0	; 63

	/* Disable clock division */
	clock_prescale_set(clock_div_1);
     4ae:	80 e0       	ldi	r24, 0x00	; 0
     4b0:	90 e0       	ldi	r25, 0x00	; 0
     4b2:	20 e8       	ldi	r18, 0x80	; 128
     4b4:	0f b6       	in	r0, 0x3f	; 63
     4b6:	f8 94       	cli
     4b8:	20 93 61 00 	sts	0x0061, r18
     4bc:	80 93 61 00 	sts	0x0061, r24
     4c0:	0f be       	out	0x3f, r0	; 63

		/* Inline Functions: */
		#if !defined(__DOXYGEN__)
			static inline void LEDs_Init(void)
			{
				DDRD  |=  LEDS_ALL_LEDS;
     4c2:	8a b1       	in	r24, 0x0a	; 10
     4c4:	80 6f       	ori	r24, 0xF0	; 240
     4c6:	8a b9       	out	0x0a, r24	; 10
				PORTD &= ~LEDS_ALL_LEDS;
     4c8:	8b b1       	in	r24, 0x0b	; 11
     4ca:	8f 70       	andi	r24, 0x0F	; 15
     4cc:	8b b9       	out	0x0b, r24	; 11
			 *  \param[in] DoubleSpeed  Enables double speed mode when set, halving the sample time to double the baud rate.
			 */
			static inline void Serial_Init(const uint32_t BaudRate,
			                               const bool DoubleSpeed)
			{
				UBRR1  = (DoubleSpeed ? SERIAL_2X_UBBRVAL(BaudRate) : SERIAL_UBBRVAL(BaudRate));
     4ce:	83 e3       	ldi	r24, 0x33	; 51
     4d0:	90 e0       	ldi	r25, 0x00	; 0
     4d2:	90 93 cd 00 	sts	0x00CD, r25
     4d6:	80 93 cc 00 	sts	0x00CC, r24

				UCSR1C = ((1 << UCSZ11) | (1 << UCSZ10));
     4da:	86 e0       	ldi	r24, 0x06	; 6
     4dc:	80 93 ca 00 	sts	0x00CA, r24
				UCSR1A = (DoubleSpeed ? (1 << U2X1) : 0);
     4e0:	10 92 c8 00 	sts	0x00C8, r1
				UCSR1B = ((1 << TXEN1)  | (1 << RXEN1));
     4e4:	30 93 c9 00 	sts	0x00C9, r19

				DDRD  |= (1 << 3);
     4e8:	53 9a       	sbi	0x0a, 3	; 10
				PORTD |= (1 << 2);
     4ea:	5a 9a       	sbi	0x0b, 2	; 11

	/* Hardware Initialization */
	LEDs_Init();
	Serial_Init(9600, false);
	USB_Init();
     4ec:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <USB_Init>

	/* Create a stdio stream for the serial port for stdin and stdout */
	Serial_CreateStream(NULL);
     4f0:	80 e0       	ldi	r24, 0x00	; 0
     4f2:	90 e0       	ldi	r25, 0x00	; 0
     4f4:	0c 94 aa 16 	jmp	0x2d54	; 0x2d54 <Serial_CreateStream>

000004f8 <main>:
/** Main program entry point. This routine contains the overall program flow, including initial
 *  setup of all components and the main program loop.
 */
int main(void)
{
	SetupHardware();
     4f8:	cf df       	rcall	.-98     	; 0x498 <SetupHardware>

	TCP_Init();
     4fa:	5e d1       	rcall	.+700    	; 0x7b8 <TCP_Init>
	Webserver_Init();
     4fc:	0e 94 69 0d 	call	0x1ad2	; 0x1ad2 <Webserver_Init>
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
     500:	8b b1       	in	r24, 0x0b	; 11
     502:	8f 70       	andi	r24, 0x0F	; 15
     504:	80 61       	ori	r24, 0x10	; 16
     506:	8b b9       	out	0x0b, r24	; 11

	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
	sei();
     508:	78 94       	sei

	for (;;)
	{
		if (RNDIS_Device_IsPacketReceived(&Ethernet_RNDIS_Interface))
     50a:	88 e1       	ldi	r24, 0x18	; 24
     50c:	91 e0       	ldi	r25, 0x01	; 1
     50e:	0e 94 47 12 	call	0x248e	; 0x248e <RNDIS_Device_IsPacketReceived>
     512:	88 23       	and	r24, r24
     514:	31 f1       	breq	.+76     	; 0x562 <main+0x6a>
     516:	8b b1       	in	r24, 0x0b	; 11
     518:	8f 70       	andi	r24, 0x0F	; 15
     51a:	80 62       	ori	r24, 0x20	; 32
     51c:	8b b9       	out	0x0b, r24	; 11
		{
			LEDs_SetAllLEDs(LEDMASK_USB_BUSY);

			RNDIS_Device_ReadPacket(&Ethernet_RNDIS_Interface, &FrameIN.FrameData, &FrameIN.FrameLength);
     51e:	88 e1       	ldi	r24, 0x18	; 24
     520:	91 e0       	ldi	r25, 0x01	; 1
     522:	68 ef       	ldi	r22, 0xF8	; 248
     524:	71 e0       	ldi	r23, 0x01	; 1
     526:	44 ed       	ldi	r20, 0xD4	; 212
     528:	57 e0       	ldi	r21, 0x07	; 7
     52a:	0e 94 17 13 	call	0x262e	; 0x262e <RNDIS_Device_ReadPacket>
			Ethernet_ProcessPacket(&FrameIN, &FrameOUT);
     52e:	88 ef       	ldi	r24, 0xF8	; 248
     530:	91 e0       	ldi	r25, 0x01	; 1
     532:	66 ed       	ldi	r22, 0xD6	; 214
     534:	77 e0       	ldi	r23, 0x07	; 7
     536:	81 d0       	rcall	.+258    	; 0x63a <Ethernet_ProcessPacket>

			if (FrameOUT.FrameLength)
     538:	40 91 b2 0d 	lds	r20, 0x0DB2
     53c:	50 91 b3 0d 	lds	r21, 0x0DB3
     540:	41 15       	cp	r20, r1
     542:	51 05       	cpc	r21, r1
     544:	51 f0       	breq	.+20     	; 0x55a <main+0x62>
			{
				RNDIS_Device_SendPacket(&Ethernet_RNDIS_Interface, &FrameOUT.FrameData, FrameOUT.FrameLength);
     546:	88 e1       	ldi	r24, 0x18	; 24
     548:	91 e0       	ldi	r25, 0x01	; 1
     54a:	66 ed       	ldi	r22, 0xD6	; 214
     54c:	77 e0       	ldi	r23, 0x07	; 7
     54e:	0e 94 61 12 	call	0x24c2	; 0x24c2 <RNDIS_Device_SendPacket>
				FrameOUT.FrameLength = 0;
     552:	10 92 b3 0d 	sts	0x0DB3, r1
     556:	10 92 b2 0d 	sts	0x0DB2, r1
     55a:	8b b1       	in	r24, 0x0b	; 11
     55c:	8f 70       	andi	r24, 0x0F	; 15
     55e:	80 66       	ori	r24, 0x60	; 96
     560:	8b b9       	out	0x0b, r24	; 11
			}

			LEDs_SetAllLEDs(LEDMASK_USB_READY);
		}

		TCP_TCPTask(&Ethernet_RNDIS_Interface, &FrameOUT);
     562:	88 e1       	ldi	r24, 0x18	; 24
     564:	91 e0       	ldi	r25, 0x01	; 1
     566:	66 ed       	ldi	r22, 0xD6	; 214
     568:	77 e0       	ldi	r23, 0x07	; 7
     56a:	26 d6       	rcall	.+3148   	; 0x11b8 <TCP_TCPTask>

		RNDIS_Device_USBTask(&Ethernet_RNDIS_Interface);
     56c:	88 e1       	ldi	r24, 0x18	; 24
     56e:	91 e0       	ldi	r25, 0x01	; 1
     570:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <RNDIS_Device_USBTask>
		USB_USBTask();
     574:	0e 94 34 12 	call	0x2468	; 0x2468 <USB_USBTask>
     578:	c8 cf       	rjmp	.-112    	; 0x50a <main+0x12>

0000057a <CALLBACK_USB_GetDescriptor>:
 *  USB host.
 */
uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
                                    const uint8_t wIndex,
                                    const void** const DescriptorAddress)
{
     57a:	da 01       	movw	r26, r20
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
     57c:	92 30       	cpi	r25, 0x02	; 2
     57e:	49 f0       	breq	.+18     	; 0x592 <CALLBACK_USB_GetDescriptor+0x18>
     580:	93 30       	cpi	r25, 0x03	; 3
     582:	61 f0       	breq	.+24     	; 0x59c <CALLBACK_USB_GetDescriptor+0x22>
     584:	91 30       	cpi	r25, 0x01	; 1
     586:	f9 f4       	brne	.+62     	; 0x5c6 <CALLBACK_USB_GetDescriptor+0x4c>
     588:	e8 e9       	ldi	r30, 0x98	; 152
     58a:	f0 e0       	ldi	r31, 0x00	; 0
     58c:	22 e1       	ldi	r18, 0x12	; 18
     58e:	30 e0       	ldi	r19, 0x00	; 0
     590:	1e c0       	rjmp	.+60     	; 0x5ce <CALLBACK_USB_GetDescriptor+0x54>
     592:	ea ea       	ldi	r30, 0xAA	; 170
     594:	f0 e0       	ldi	r31, 0x00	; 0
     596:	2e e3       	ldi	r18, 0x3E	; 62
     598:	30 e0       	ldi	r19, 0x00	; 0
     59a:	19 c0       	rjmp	.+50     	; 0x5ce <CALLBACK_USB_GetDescriptor+0x54>
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
		case DTYPE_String:
			switch (DescriptorNumber)
     59c:	81 30       	cpi	r24, 0x01	; 1
     59e:	49 f0       	breq	.+18     	; 0x5b2 <CALLBACK_USB_GetDescriptor+0x38>
     5a0:	81 30       	cpi	r24, 0x01	; 1
     5a2:	18 f0       	brcs	.+6      	; 0x5aa <CALLBACK_USB_GetDescriptor+0x30>
     5a4:	82 30       	cpi	r24, 0x02	; 2
     5a6:	79 f4       	brne	.+30     	; 0x5c6 <CALLBACK_USB_GetDescriptor+0x4c>
     5a8:	08 c0       	rjmp	.+16     	; 0x5ba <CALLBACK_USB_GetDescriptor+0x40>
			{
				case 0x00:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
     5aa:	e8 ee       	ldi	r30, 0xE8	; 232
     5ac:	f0 e0       	ldi	r31, 0x00	; 0
     5ae:	84 91       	lpm	r24, Z+
     5b0:	07 c0       	rjmp	.+14     	; 0x5c0 <CALLBACK_USB_GetDescriptor+0x46>
					break;
				case 0x01:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
     5b2:	ec ee       	ldi	r30, 0xEC	; 236
     5b4:	f0 e0       	ldi	r31, 0x00	; 0
     5b6:	84 91       	lpm	r24, Z+
     5b8:	03 c0       	rjmp	.+6      	; 0x5c0 <CALLBACK_USB_GetDescriptor+0x46>
					break;
				case 0x02:
					Address = &ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
     5ba:	e6 e0       	ldi	r30, 0x06	; 6
     5bc:	f1 e0       	ldi	r31, 0x01	; 1
     5be:	84 91       	lpm	r24, Z+
     5c0:	28 2f       	mov	r18, r24
     5c2:	30 e0       	ldi	r19, 0x00	; 0
     5c4:	04 c0       	rjmp	.+8      	; 0x5ce <CALLBACK_USB_GetDescriptor+0x54>
     5c6:	e0 e0       	ldi	r30, 0x00	; 0
     5c8:	f0 e0       	ldi	r31, 0x00	; 0
     5ca:	20 e0       	ldi	r18, 0x00	; 0
     5cc:	30 e0       	ldi	r19, 0x00	; 0
			}

			break;
	}

	*DescriptorAddress = Address;
     5ce:	ed 93       	st	X+, r30
     5d0:	fc 93       	st	X, r31
	return Size;
}
     5d2:	c9 01       	movw	r24, r18
     5d4:	08 95       	ret

000005d6 <Ethernet_Checksum16>:
 *
 *  \return A 16-bit Ethernet checksum value
 */
uint16_t Ethernet_Checksum16(void* Data,
                             uint16_t Bytes)
{
     5d6:	cf 93       	push	r28
     5d8:	df 93       	push	r29
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     5da:	76 95       	lsr	r23
     5dc:	67 95       	ror	r22
     5de:	ec 01       	movw	r28, r24
     5e0:	20 e0       	ldi	r18, 0x00	; 0
     5e2:	30 e0       	ldi	r19, 0x00	; 0
     5e4:	40 e0       	ldi	r20, 0x00	; 0
     5e6:	50 e0       	ldi	r21, 0x00	; 0
     5e8:	e0 e0       	ldi	r30, 0x00	; 0
     5ea:	f0 e0       	ldi	r31, 0x00	; 0
     5ec:	09 c0       	rjmp	.+18     	; 0x600 <Ethernet_Checksum16+0x2a>
	  Checksum += Words[CurrWord];
     5ee:	89 91       	ld	r24, Y+
     5f0:	99 91       	ld	r25, Y+
     5f2:	a0 e0       	ldi	r26, 0x00	; 0
     5f4:	b0 e0       	ldi	r27, 0x00	; 0
     5f6:	28 0f       	add	r18, r24
     5f8:	39 1f       	adc	r19, r25
     5fa:	4a 1f       	adc	r20, r26
     5fc:	5b 1f       	adc	r21, r27
                             uint16_t Bytes)
{
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     5fe:	31 96       	adiw	r30, 0x01	; 1
     600:	e6 17       	cp	r30, r22
     602:	f7 07       	cpc	r31, r23
     604:	a0 f3       	brcs	.-24     	; 0x5ee <Ethernet_Checksum16+0x18>
     606:	0b c0       	rjmp	.+22     	; 0x61e <Ethernet_Checksum16+0x48>
	  Checksum += Words[CurrWord];

	while (Checksum & 0xFFFF0000)
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));
     608:	da 01       	movw	r26, r20
     60a:	c9 01       	movw	r24, r18
     60c:	a0 70       	andi	r26, 0x00	; 0
     60e:	b0 70       	andi	r27, 0x00	; 0
     610:	9a 01       	movw	r18, r20
     612:	44 27       	eor	r20, r20
     614:	55 27       	eor	r21, r21
     616:	28 0f       	add	r18, r24
     618:	39 1f       	adc	r19, r25
     61a:	4a 1f       	adc	r20, r26
     61c:	5b 1f       	adc	r21, r27
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
	  Checksum += Words[CurrWord];

	while (Checksum & 0xFFFF0000)
     61e:	da 01       	movw	r26, r20
     620:	c9 01       	movw	r24, r18
     622:	80 70       	andi	r24, 0x00	; 0
     624:	90 70       	andi	r25, 0x00	; 0
     626:	00 97       	sbiw	r24, 0x00	; 0
     628:	a1 05       	cpc	r26, r1
     62a:	b1 05       	cpc	r27, r1
     62c:	69 f7       	brne	.-38     	; 0x608 <Ethernet_Checksum16+0x32>
     62e:	20 95       	com	r18
     630:	30 95       	com	r19
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));

	return ~Checksum;
}
     632:	c9 01       	movw	r24, r18
     634:	df 91       	pop	r29
     636:	cf 91       	pop	r28
     638:	08 95       	ret

0000063a <Ethernet_ProcessPacket>:
/** Processes an incoming Ethernet frame, and writes the appropriate response to the output Ethernet
 *  frame buffer if the sub protocol handlers create a valid response.
 */
void Ethernet_ProcessPacket(Ethernet_Frame_Info_t* const FrameIN,
                            Ethernet_Frame_Info_t* const FrameOUT)
{
     63a:	0f 93       	push	r16
     63c:	1f 93       	push	r17
     63e:	cf 93       	push	r28
     640:	df 93       	push	r29
     642:	ec 01       	movw	r28, r24
     644:	8b 01       	movw	r16, r22
	DecodeEthernetFrameHeader(FrameIN->FrameData);
     646:	6c d0       	rcall	.+216    	; 0x720 <DecodeEthernetFrameHeader>
	Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT->FrameData;

	int16_t                  RetSize        = NO_RESPONSE;

	/* Ensure frame is addressed to either all (broadcast) or the virtual webserver, and is a type II frame */
	if ((MAC_COMPARE(&FrameINHeader->Destination, &ServerMACAddress) ||
     648:	ce 01       	movw	r24, r28
     64a:	63 eb       	ldi	r22, 0xB3	; 179
     64c:	71 e0       	ldi	r23, 0x01	; 1
     64e:	46 e0       	ldi	r20, 0x06	; 6
     650:	50 e0       	ldi	r21, 0x00	; 0
     652:	0e 94 f0 16 	call	0x2de0	; 0x2de0 <memcmp>
     656:	00 97       	sbiw	r24, 0x00	; 0
     658:	51 f0       	breq	.+20     	; 0x66e <Ethernet_ProcessPacket+0x34>
     65a:	ce 01       	movw	r24, r28
     65c:	6d eb       	ldi	r22, 0xBD	; 189
     65e:	71 e0       	ldi	r23, 0x01	; 1
     660:	46 e0       	ldi	r20, 0x06	; 6
     662:	50 e0       	ldi	r21, 0x00	; 0
     664:	0e 94 f0 16 	call	0x2de0	; 0x2de0 <memcmp>
     668:	00 97       	sbiw	r24, 0x00	; 0
     66a:	09 f0       	breq	.+2      	; 0x66e <Ethernet_ProcessPacket+0x34>
     66c:	50 c0       	rjmp	.+160    	; 0x70e <Ethernet_ProcessPacket+0xd4>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
     66e:	c4 52       	subi	r28, 0x24	; 36
     670:	da 4f       	sbci	r29, 0xFA	; 250
     672:	88 81       	ld	r24, Y
     674:	99 81       	ldd	r25, Y+1	; 0x01
     676:	cc 5d       	subi	r28, 0xDC	; 220
     678:	d5 40       	sbci	r29, 0x05	; 5

				Temp = Data.Bytes[0];
     67a:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[1];
     67c:	89 2f       	mov	r24, r25
				Data.Bytes[1] = Temp;
     67e:	92 2f       	mov	r25, r18
     680:	81 50       	subi	r24, 0x01	; 1
     682:	96 40       	sbci	r25, 0x06	; 6
     684:	08 f4       	brcc	.+2      	; 0x688 <Ethernet_ProcessPacket+0x4e>
     686:	43 c0       	rjmp	.+134    	; 0x70e <Ethernet_ProcessPacket+0xd4>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
     688:	2c 85       	ldd	r18, Y+12	; 0x0c
     68a:	3d 85       	ldd	r19, Y+13	; 0x0d

				Temp = Data.Bytes[0];
     68c:	82 2f       	mov	r24, r18
				Data.Bytes[0] = Data.Bytes[1];
     68e:	23 2f       	mov	r18, r19
				Data.Bytes[1] = Temp;
     690:	38 2f       	mov	r19, r24
	     MAC_COMPARE(&FrameINHeader->Destination, &BroadcastMACAddress)) &&
		 (SwapEndian_16(FrameIN->FrameLength) > ETHERNET_VER2_MINSIZE))
	{
		/* Process the packet depending on its protocol */
		switch (SwapEndian_16(FrameINHeader->EtherType))
     692:	88 e0       	ldi	r24, 0x08	; 8
     694:	20 30       	cpi	r18, 0x00	; 0
     696:	38 07       	cpc	r19, r24
     698:	59 f0       	breq	.+22     	; 0x6b0 <Ethernet_ProcessPacket+0x76>
     69a:	26 50       	subi	r18, 0x06	; 6
     69c:	38 40       	sbci	r19, 0x08	; 8
     69e:	b9 f5       	brne	.+110    	; 0x70e <Ethernet_ProcessPacket+0xd4>
		{
			case ETHERTYPE_ARP:
				RetSize = ARP_ProcessARPPacket(&FrameIN->FrameData[sizeof(Ethernet_Frame_Header_t)],
     6a0:	b8 01       	movw	r22, r16
     6a2:	62 5f       	subi	r22, 0xF2	; 242
     6a4:	7f 4f       	sbci	r23, 0xFF	; 255
     6a6:	ce 01       	movw	r24, r28
     6a8:	0e 96       	adiw	r24, 0x0e	; 14
     6aa:	0e 94 7a 0b 	call	0x16f4	; 0x16f4 <ARP_ProcessARPPacket>
     6ae:	09 c0       	rjmp	.+18     	; 0x6c2 <Ethernet_ProcessPacket+0x88>
				                               &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t)]);
				break;
			case ETHERTYPE_IPV4:
				RetSize = IP_ProcessIPPacket(FrameIN,
     6b0:	be 01       	movw	r22, r28
     6b2:	62 5f       	subi	r22, 0xF2	; 242
     6b4:	7f 4f       	sbci	r23, 0xFF	; 255
     6b6:	a8 01       	movw	r20, r16
     6b8:	42 5f       	subi	r20, 0xF2	; 242
     6ba:	5f 4f       	sbci	r21, 0xFF	; 255
     6bc:	ce 01       	movw	r24, r28
     6be:	0e 94 f8 0b 	call	0x17f0	; 0x17f0 <IP_ProcessIPPacket>
     6c2:	9c 01       	movw	r18, r24
				                             &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t)]);
				break;
		}

		/* Protocol processing routine has filled a response, complete the ethernet frame header */
		if (RetSize > 0)
     6c4:	18 16       	cp	r1, r24
     6c6:	19 06       	cpc	r1, r25
     6c8:	f4 f4       	brge	.+60     	; 0x706 <Ethernet_ProcessPacket+0xcc>
		{
			/* Fill out the response Ethernet frame header */
			FrameOUTHeader->Source          = ServerMACAddress;
     6ca:	d8 01       	movw	r26, r16
     6cc:	16 96       	adiw	r26, 0x06	; 6
     6ce:	e3 eb       	ldi	r30, 0xB3	; 179
     6d0:	f1 e0       	ldi	r31, 0x01	; 1
     6d2:	86 e0       	ldi	r24, 0x06	; 6
     6d4:	01 90       	ld	r0, Z+
     6d6:	0d 92       	st	X+, r0
     6d8:	81 50       	subi	r24, 0x01	; 1
     6da:	e1 f7       	brne	.-8      	; 0x6d4 <Ethernet_ProcessPacket+0x9a>
			FrameOUTHeader->Destination     = FrameINHeader->Source;
     6dc:	d8 01       	movw	r26, r16
     6de:	fe 01       	movw	r30, r28
     6e0:	36 96       	adiw	r30, 0x06	; 6
     6e2:	86 e0       	ldi	r24, 0x06	; 6
     6e4:	01 90       	ld	r0, Z+
     6e6:	0d 92       	st	X+, r0
     6e8:	81 50       	subi	r24, 0x01	; 1
     6ea:	e1 f7       	brne	.-8      	; 0x6e4 <Ethernet_ProcessPacket+0xaa>
			FrameOUTHeader->EtherType       = FrameINHeader->EtherType;
     6ec:	8c 85       	ldd	r24, Y+12	; 0x0c
     6ee:	9d 85       	ldd	r25, Y+13	; 0x0d
     6f0:	f8 01       	movw	r30, r16
     6f2:	95 87       	std	Z+13, r25	; 0x0d
     6f4:	84 87       	std	Z+12, r24	; 0x0c

			/* Set the response length in the buffer and indicate that a response is ready to be sent */
			FrameOUT->FrameLength           = (sizeof(Ethernet_Frame_Header_t) + RetSize);
     6f6:	04 52       	subi	r16, 0x24	; 36
     6f8:	1a 4f       	sbci	r17, 0xFA	; 250
     6fa:	22 5f       	subi	r18, 0xF2	; 242
     6fc:	3f 4f       	sbci	r19, 0xFF	; 255
     6fe:	f8 01       	movw	r30, r16
     700:	31 83       	std	Z+1, r19	; 0x01
     702:	20 83       	st	Z, r18
     704:	04 c0       	rjmp	.+8      	; 0x70e <Ethernet_ProcessPacket+0xd4>
		}
	}

	/* Check if the packet was processed */
	if (RetSize != NO_PROCESS)
     706:	ff ef       	ldi	r31, 0xFF	; 255
     708:	8f 3f       	cpi	r24, 0xFF	; 255
     70a:	9f 07       	cpc	r25, r31
     70c:	21 f0       	breq	.+8      	; 0x716 <Ethernet_ProcessPacket+0xdc>
	{
		/* Clear the frame buffer */
		FrameIN->FrameLength = 0;
     70e:	c4 52       	subi	r28, 0x24	; 36
     710:	da 4f       	sbci	r29, 0xFA	; 250
     712:	19 82       	std	Y+1, r1	; 0x01
     714:	18 82       	st	Y, r1
	}
}
     716:	df 91       	pop	r29
     718:	cf 91       	pop	r28
     71a:	1f 91       	pop	r17
     71c:	0f 91       	pop	r16
     71e:	08 95       	ret

00000720 <DecodeEthernetFrameHeader>:
	                                                                     FrameHeader->Destination.Octets[4],
	                                                                     FrameHeader->Destination.Octets[5]);

	printf_P(PSTR("  + Protocol: 0x%04x\r\n"), SwapEndian_16(FrameHeader->EtherType));
	#endif
}
     720:	08 95       	ret

00000722 <DecodeARPHeader>:
		                                                ARPHeader->TPA.Octets[1],
		                                                ARPHeader->TPA.Octets[2],
		                                                ARPHeader->TPA.Octets[3]);
	}
	#endif
}
     722:	08 95       	ret

00000724 <DecodeIPHeader>:
	printf_P(PSTR("    + IP Dst: %u.%u.%u.%u\r\n"), IPHeader->DestinationAddress.Octets[0],
	                                                IPHeader->DestinationAddress.Octets[1],
	                                                IPHeader->DestinationAddress.Octets[2],
	                                                IPHeader->DestinationAddress.Octets[3]);
	#endif
}
     724:	08 95       	ret

00000726 <DecodeICMPHeader>:
	printf_P(PSTR("    \\\r\n     ICMP\r\n"));

	printf_P(PSTR("     + Type: %u\r\n"), ICMPHeader->Type);
	printf_P(PSTR("     + Code: %u\r\n"), ICMPHeader->Code);
	#endif
}
     726:	08 95       	ret

00000728 <DecodeTCPHeader>:
	printf_P(PSTR("     + Flags: 0x%02X\r\n"), TCPHeader->Flags);

	if (TCP_GetPortState(TCPHeader->DestinationPort) == TCP_Port_Closed)
	  printf_P(PSTR("     + NOT LISTENING ON DESTINATION PORT\r\n"));
	#endif
}
     728:	08 95       	ret

0000072a <DecodeUDPHeader>:
	printf_P(PSTR("     + Source Port: %u\r\n"), SwapEndian_16(UDPHeader->SourcePort));
	printf_P(PSTR("     + Destination Port: %u\r\n"), SwapEndian_16(UDPHeader->DestinationPort));

	printf_P(PSTR("     + Data Length: %d\r\n"), SwapEndian_16(UDPHeader->Length));
	#endif
}
     72a:	08 95       	ret

0000072c <DecodeDHCPHeader>:

		DHCPOptions += ((DHCPOptions[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptions[1] + 2));
	}

	#endif
}
     72c:	08 95       	ret

0000072e <ICMP_ProcessICMPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t ICMP_ProcessICMPPacket(Ethernet_Frame_Info_t* const FrameIN,
                               void* InDataStart,
                               void* OutDataStart)
{
     72e:	ef 92       	push	r14
     730:	ff 92       	push	r15
     732:	0f 93       	push	r16
     734:	1f 93       	push	r17
     736:	cf 93       	push	r28
     738:	df 93       	push	r29
     73a:	7c 01       	movw	r14, r24
     73c:	8b 01       	movw	r16, r22
     73e:	ea 01       	movw	r28, r20
	ICMP_Header_t* ICMPHeaderIN  = (ICMP_Header_t*)InDataStart;
	ICMP_Header_t* ICMPHeaderOUT = (ICMP_Header_t*)OutDataStart;

	DecodeICMPHeader(InDataStart);
     740:	cb 01       	movw	r24, r22
     742:	f1 df       	rcall	.-30     	; 0x726 <DecodeICMPHeader>

	/* Determine if the ICMP packet is an echo request (ping) */
	if (ICMPHeaderIN->Type == ICMP_TYPE_ECHOREQUEST)
     744:	f8 01       	movw	r30, r16
     746:	80 81       	ld	r24, Z
     748:	88 30       	cpi	r24, 0x08	; 8
     74a:	19 f0       	breq	.+6      	; 0x752 <ICMP_ProcessICMPPacket+0x24>
     74c:	20 e0       	ldi	r18, 0x00	; 0
     74e:	30 e0       	ldi	r19, 0x00	; 0
     750:	2b c0       	rjmp	.+86     	; 0x7a8 <ICMP_ProcessICMPPacket+0x7a>
	{
		/* Fill out the ICMP response packet */
		ICMPHeaderOUT->Type     = ICMP_TYPE_ECHOREPLY;
     752:	18 82       	st	Y, r1
		ICMPHeaderOUT->Code     = 0;
     754:	19 82       	std	Y+1, r1	; 0x01
		ICMPHeaderOUT->Checksum = 0;
     756:	1b 82       	std	Y+3, r1	; 0x03
     758:	1a 82       	std	Y+2, r1	; 0x02
		ICMPHeaderOUT->Id       = ICMPHeaderIN->Id;
     75a:	f8 01       	movw	r30, r16
     75c:	84 81       	ldd	r24, Z+4	; 0x04
     75e:	95 81       	ldd	r25, Z+5	; 0x05
     760:	9d 83       	std	Y+5, r25	; 0x05
     762:	8c 83       	std	Y+4, r24	; 0x04
		ICMPHeaderOUT->Sequence = ICMPHeaderIN->Sequence;
     764:	86 81       	ldd	r24, Z+6	; 0x06
     766:	97 81       	ldd	r25, Z+7	; 0x07
     768:	9f 83       	std	Y+7, r25	; 0x07
     76a:	8e 83       	std	Y+6, r24	; 0x06

		intptr_t DataSize = FrameIN->FrameLength - ((((intptr_t)InDataStart + sizeof(ICMP_Header_t)) - (intptr_t)FrameIN->FrameData));
     76c:	b8 01       	movw	r22, r16
     76e:	68 5f       	subi	r22, 0xF8	; 248
     770:	7f 4f       	sbci	r23, 0xFF	; 255
     772:	8c ed       	ldi	r24, 0xDC	; 220
     774:	95 e0       	ldi	r25, 0x05	; 5
     776:	e8 0e       	add	r14, r24
     778:	f9 1e       	adc	r15, r25
     77a:	f7 01       	movw	r30, r14
     77c:	80 81       	ld	r24, Z
     77e:	91 81       	ldd	r25, Z+1	; 0x01
     780:	87 01       	movw	r16, r14
     782:	0c 5d       	subi	r16, 0xDC	; 220
     784:	15 40       	sbci	r17, 0x05	; 5
     786:	08 0f       	add	r16, r24
     788:	19 1f       	adc	r17, r25
     78a:	06 1b       	sub	r16, r22
     78c:	17 0b       	sbc	r17, r23

		/* Copy the remaining payload to the response - echo requests should echo back any sent data */
		memmove(&((uint8_t*)OutDataStart)[sizeof(ICMP_Header_t)],
     78e:	ce 01       	movw	r24, r28
     790:	08 96       	adiw	r24, 0x08	; 8
     792:	a8 01       	movw	r20, r16
     794:	0e 94 06 17 	call	0x2e0c	; 0x2e0c <memmove>
		        &((uint8_t*)InDataStart)[sizeof(ICMP_Header_t)],
			    DataSize);

		ICMPHeaderOUT->Checksum = Ethernet_Checksum16(ICMPHeaderOUT, (DataSize + sizeof(ICMP_Header_t)));
     798:	08 5f       	subi	r16, 0xF8	; 248
     79a:	1f 4f       	sbci	r17, 0xFF	; 255
     79c:	ce 01       	movw	r24, r28
     79e:	b8 01       	movw	r22, r16
     7a0:	1a df       	rcall	.-460    	; 0x5d6 <Ethernet_Checksum16>
     7a2:	9b 83       	std	Y+3, r25	; 0x03
     7a4:	8a 83       	std	Y+2, r24	; 0x02

		/* Return the size of the response so far */
		return (DataSize + sizeof(ICMP_Header_t));
     7a6:	98 01       	movw	r18, r16
	}

	return NO_RESPONSE;
}
     7a8:	c9 01       	movw	r24, r18
     7aa:	df 91       	pop	r29
     7ac:	cf 91       	pop	r28
     7ae:	1f 91       	pop	r17
     7b0:	0f 91       	pop	r16
     7b2:	ff 90       	pop	r15
     7b4:	ef 90       	pop	r14
     7b6:	08 95       	ret

000007b8 <TCP_Init>:
 */
void TCP_Init(void)
{
	/* Initialize the port state table with all CLOSED entries */
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	  PortStateTable[PTableEntry].State = TCP_Port_Closed;
     7b8:	10 92 f9 13 	sts	0x13F9, r1

	/* Initialize the connection table with all CLOSED entries */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	  ConnectionStateTable[CSTableEntry].State = TCP_Connection_Closed;
     7bc:	8a e0       	ldi	r24, 0x0A	; 10
     7be:	80 93 ca 0f 	sts	0x0FCA, r24
     7c2:	80 93 e0 11 	sts	0x11E0, r24
     7c6:	80 93 f6 13 	sts	0x13F6, r24
}
     7ca:	08 95       	ret

000007cc <TCP_SetPortState>:
 *  \return Boolean true if the port state was set, false otherwise (no more space in the port state table)
 */
bool TCP_SetPortState(const uint16_t Port,
                      const uint8_t State,
                      void (*Handler)(TCP_ConnectionState_t*, TCP_ConnectionBuffer_t*))
{
     7cc:	9c 01       	movw	r18, r24

	/* Check to see if the port entry is already in the port state table */
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	{
		/* Find existing entry for the port in the table, update it if found */
		if (PortStateTable[PTableEntry].Port == Port)
     7ce:	80 91 f7 13 	lds	r24, 0x13F7
     7d2:	90 91 f8 13 	lds	r25, 0x13F8
     7d6:	82 17       	cp	r24, r18
     7d8:	93 07       	cpc	r25, r19
     7da:	39 f4       	brne	.+14     	; 0x7ea <TCP_SetPortState+0x1e>
		{
			PortStateTable[PTableEntry].State = State;
     7dc:	60 93 f9 13 	sts	0x13F9, r22
			PortStateTable[PTableEntry].ApplicationHandler = Handler;
     7e0:	50 93 fb 13 	sts	0x13FB, r21
     7e4:	40 93 fa 13 	sts	0x13FA, r20
     7e8:	02 c0       	rjmp	.+4      	; 0x7ee <TCP_SetPortState+0x22>
			return true;
		}
	}

	/* Check if trying to open the port -- if so we need to find an unused (closed) entry and replace it */
	if (State == TCP_Port_Open)
     7ea:	61 30       	cpi	r22, 0x01	; 1
     7ec:	11 f0       	breq	.+4      	; 0x7f2 <TCP_SetPortState+0x26>
     7ee:	81 e0       	ldi	r24, 0x01	; 1
     7f0:	08 95       	ret
	{
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Find a closed port entry in the table, change it to the given port and state */
			if (PortStateTable[PTableEntry].State == TCP_Port_Closed)
     7f2:	80 91 f9 13 	lds	r24, 0x13F9
     7f6:	88 23       	and	r24, r24
     7f8:	11 f0       	breq	.+4      	; 0x7fe <TCP_SetPortState+0x32>
     7fa:	80 e0       	ldi	r24, 0x00	; 0
     7fc:	08 95       	ret
			{
				PortStateTable[PTableEntry].Port  = Port;
     7fe:	30 93 f8 13 	sts	0x13F8, r19
     802:	20 93 f7 13 	sts	0x13F7, r18
				PortStateTable[PTableEntry].State = State;
     806:	60 93 f9 13 	sts	0x13F9, r22
				PortStateTable[PTableEntry].ApplicationHandler = Handler;
     80a:	50 93 fb 13 	sts	0x13FB, r21
     80e:	40 93 fa 13 	sts	0x13FA, r20
     812:	81 e0       	ldi	r24, 0x01	; 1
	else
	{
		/* Port not in table but trying to close it, so operation successful */
		return true;
	}
}
     814:	08 95       	ret

00000816 <TCP_GetPortState>:
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	{
		/* Find existing entry for the port in the table, return the port status if found */
		if (PortStateTable[PTableEntry].Port == Port)
     816:	20 91 f7 13 	lds	r18, 0x13F7
     81a:	30 91 f8 13 	lds	r19, 0x13F8
     81e:	28 17       	cp	r18, r24
     820:	39 07       	cpc	r19, r25
     822:	11 f0       	breq	.+4      	; 0x828 <TCP_GetPortState+0x12>
     824:	80 e0       	ldi	r24, 0x00	; 0
     826:	08 95       	ret
		  return PortStateTable[PTableEntry].State;
     828:	80 91 f9 13 	lds	r24, 0x13F9
	}

	/* Port not in table, assume closed */
	return TCP_Port_Closed;
}
     82c:	08 95       	ret

0000082e <SwapEndian_32>:
			 *
			 *  \return Input data with the individual bytes reversed.
			 */
			static inline uint32_t SwapEndian_32(const uint32_t DWord) ATTR_WARN_UNUSED_RESULT ATTR_CONST;
			static inline uint32_t SwapEndian_32(const uint32_t DWord)
			{
     82e:	36 2f       	mov	r19, r22
     830:	27 2f       	mov	r18, r23
				Temp = Data.Bytes[1];
				Data.Bytes[1] = Data.Bytes[2];
				Data.Bytes[2] = Temp;

				return Data.DWord;
			}
     832:	69 2f       	mov	r22, r25
     834:	78 2f       	mov	r23, r24
     836:	c9 01       	movw	r24, r18
     838:	08 95       	ret

0000083a <TCP_Checksum16>:
 */
static uint16_t TCP_Checksum16(void* TCPHeaderOutStart,
                               const IP_Address_t SourceAddress,
                               const IP_Address_t DestinationAddress,
                               const uint16_t TCPOutSize)
{
     83a:	4f 92       	push	r4
     83c:	5f 92       	push	r5
     83e:	6f 92       	push	r6
     840:	7f 92       	push	r7
     842:	8f 92       	push	r8
     844:	9f 92       	push	r9
     846:	af 92       	push	r10
     848:	bf 92       	push	r11
     84a:	cf 92       	push	r12
     84c:	df 92       	push	r13
     84e:	ef 92       	push	r14
     850:	ff 92       	push	r15
     852:	0f 93       	push	r16
     854:	1f 93       	push	r17
     856:	df 93       	push	r29
     858:	cf 93       	push	r28
     85a:	cd b7       	in	r28, 0x3d	; 61
     85c:	de b7       	in	r29, 0x3e	; 62
     85e:	28 97       	sbiw	r28, 0x08	; 8
     860:	0f b6       	in	r0, 0x3f	; 63
     862:	f8 94       	cli
     864:	de bf       	out	0x3e, r29	; 62
     866:	0f be       	out	0x3f, r0	; 63
     868:	cd bf       	out	0x3d, r28	; 61
     86a:	2c 01       	movw	r4, r24
     86c:	fa 01       	movw	r30, r20
     86e:	49 83       	std	Y+1, r20	; 0x01
     870:	5a 83       	std	Y+2, r21	; 0x02
     872:	6b 83       	std	Y+3, r22	; 0x03
     874:	7c 83       	std	Y+4, r23	; 0x04
     876:	a8 01       	movw	r20, r16
     878:	0d 83       	std	Y+5, r16	; 0x05
     87a:	1e 83       	std	Y+6, r17	; 0x06
     87c:	2f 83       	std	Y+7, r18	; 0x07
     87e:	38 87       	std	Y+8, r19	; 0x08
     880:	37 01       	movw	r6, r14

	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)&SourceAddress)[0];
	Checksum += ((uint16_t*)&SourceAddress)[1];
     882:	0b 81       	ldd	r16, Y+3	; 0x03
     884:	1c 81       	ldd	r17, Y+4	; 0x04
	Checksum += ((uint16_t*)&DestinationAddress)[0];
	Checksum += ((uint16_t*)&DestinationAddress)[1];
     886:	cf 80       	ldd	r12, Y+7	; 0x07
     888:	d8 84       	ldd	r13, Y+8	; 0x08
				} Data;

				Data.Word = Word;

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
     88a:	87 2d       	mov	r24, r7
				Data.Bytes[1] = Temp;
     88c:	9e 2d       	mov	r25, r14

	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)&SourceAddress)[0];
	Checksum += ((uint16_t*)&SourceAddress)[1];
     88e:	4f 01       	movw	r8, r30
     890:	aa 24       	eor	r10, r10
     892:	bb 24       	eor	r11, r11
     894:	60 e0       	ldi	r22, 0x00	; 0
     896:	70 e0       	ldi	r23, 0x00	; 0
     898:	84 0e       	add	r8, r20
     89a:	95 1e       	adc	r9, r21
     89c:	a6 1e       	adc	r10, r22
     89e:	b7 1e       	adc	r11, r23
	Checksum += ((uint16_t*)&DestinationAddress)[0];
     8a0:	20 e0       	ldi	r18, 0x00	; 0
     8a2:	36 e0       	ldi	r19, 0x06	; 6
     8a4:	40 e0       	ldi	r20, 0x00	; 0
     8a6:	50 e0       	ldi	r21, 0x00	; 0
     8a8:	82 0e       	add	r8, r18
     8aa:	93 1e       	adc	r9, r19
     8ac:	a4 1e       	adc	r10, r20
     8ae:	b5 1e       	adc	r11, r21
	Checksum += ((uint16_t*)&DestinationAddress)[1];
     8b0:	20 e0       	ldi	r18, 0x00	; 0
     8b2:	30 e0       	ldi	r19, 0x00	; 0
     8b4:	80 0e       	add	r8, r16
     8b6:	91 1e       	adc	r9, r17
     8b8:	a2 1e       	adc	r10, r18
     8ba:	b3 1e       	adc	r11, r19
	Checksum += SwapEndian_16(PROTOCOL_TCP);
     8bc:	ee 24       	eor	r14, r14
     8be:	ff 24       	eor	r15, r15
     8c0:	8c 0c       	add	r8, r12
     8c2:	9d 1c       	adc	r9, r13
     8c4:	ae 1c       	adc	r10, r14
     8c6:	bf 1c       	adc	r11, r15
	Checksum += SwapEndian_16(TCPOutSize);
     8c8:	a0 e0       	ldi	r26, 0x00	; 0
     8ca:	b0 e0       	ldi	r27, 0x00	; 0
     8cc:	88 0e       	add	r8, r24
     8ce:	99 1e       	adc	r9, r25
     8d0:	aa 1e       	adc	r10, r26
     8d2:	bb 1e       	adc	r11, r27

	for (uint16_t CurrWord = 0; CurrWord < (TCPOutSize >> 1); CurrWord++)
     8d4:	f3 01       	movw	r30, r6
     8d6:	f6 95       	lsr	r31
     8d8:	e7 95       	ror	r30
     8da:	a2 01       	movw	r20, r4
     8dc:	20 e0       	ldi	r18, 0x00	; 0
     8de:	30 e0       	ldi	r19, 0x00	; 0
     8e0:	0c c0       	rjmp	.+24     	; 0x8fa <TCP_Checksum16+0xc0>
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];
     8e2:	da 01       	movw	r26, r20
     8e4:	8d 91       	ld	r24, X+
     8e6:	9d 91       	ld	r25, X+
     8e8:	ad 01       	movw	r20, r26
     8ea:	a0 e0       	ldi	r26, 0x00	; 0
     8ec:	b0 e0       	ldi	r27, 0x00	; 0
     8ee:	88 0e       	add	r8, r24
     8f0:	99 1e       	adc	r9, r25
     8f2:	aa 1e       	adc	r10, r26
     8f4:	bb 1e       	adc	r11, r27
	Checksum += ((uint16_t*)&DestinationAddress)[0];
	Checksum += ((uint16_t*)&DestinationAddress)[1];
	Checksum += SwapEndian_16(PROTOCOL_TCP);
	Checksum += SwapEndian_16(TCPOutSize);

	for (uint16_t CurrWord = 0; CurrWord < (TCPOutSize >> 1); CurrWord++)
     8f6:	2f 5f       	subi	r18, 0xFF	; 255
     8f8:	3f 4f       	sbci	r19, 0xFF	; 255
     8fa:	2e 17       	cp	r18, r30
     8fc:	3f 07       	cpc	r19, r31
     8fe:	88 f3       	brcs	.-30     	; 0x8e2 <TCP_Checksum16+0xa8>
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];

	if (TCPOutSize & 0x01)
     900:	60 fe       	sbrs	r6, 0
     902:	15 c0       	rjmp	.+42     	; 0x92e <TCP_Checksum16+0xf4>
	  Checksum += (((uint16_t*)TCPHeaderOutStart)[TCPOutSize >> 1] & 0x00FF);
     904:	ee 0f       	add	r30, r30
     906:	ff 1f       	adc	r31, r31
     908:	e4 0d       	add	r30, r4
     90a:	f5 1d       	adc	r31, r5
     90c:	80 81       	ld	r24, Z
     90e:	88 0e       	add	r8, r24
     910:	91 1c       	adc	r9, r1
     912:	a1 1c       	adc	r10, r1
     914:	b1 1c       	adc	r11, r1
     916:	0b c0       	rjmp	.+22     	; 0x92e <TCP_Checksum16+0xf4>

	while (Checksum & 0xFFFF0000)
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));
     918:	d5 01       	movw	r26, r10
     91a:	c4 01       	movw	r24, r8
     91c:	a0 70       	andi	r26, 0x00	; 0
     91e:	b0 70       	andi	r27, 0x00	; 0
     920:	45 01       	movw	r8, r10
     922:	aa 24       	eor	r10, r10
     924:	bb 24       	eor	r11, r11
     926:	88 0e       	add	r8, r24
     928:	99 1e       	adc	r9, r25
     92a:	aa 1e       	adc	r10, r26
     92c:	bb 1e       	adc	r11, r27
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];

	if (TCPOutSize & 0x01)
	  Checksum += (((uint16_t*)TCPHeaderOutStart)[TCPOutSize >> 1] & 0x00FF);

	while (Checksum & 0xFFFF0000)
     92e:	d5 01       	movw	r26, r10
     930:	c4 01       	movw	r24, r8
     932:	80 70       	andi	r24, 0x00	; 0
     934:	90 70       	andi	r25, 0x00	; 0
     936:	00 97       	sbiw	r24, 0x00	; 0
     938:	a1 05       	cpc	r26, r1
     93a:	b1 05       	cpc	r27, r1
     93c:	69 f7       	brne	.-38     	; 0x918 <TCP_Checksum16+0xde>
     93e:	94 01       	movw	r18, r8
     940:	20 95       	com	r18
     942:	30 95       	com	r19
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));

	return ~Checksum;
}
     944:	c9 01       	movw	r24, r18
     946:	28 96       	adiw	r28, 0x08	; 8
     948:	0f b6       	in	r0, 0x3f	; 63
     94a:	f8 94       	cli
     94c:	de bf       	out	0x3e, r29	; 62
     94e:	0f be       	out	0x3f, r0	; 63
     950:	cd bf       	out	0x3d, r28	; 61
     952:	cf 91       	pop	r28
     954:	df 91       	pop	r29
     956:	1f 91       	pop	r17
     958:	0f 91       	pop	r16
     95a:	ff 90       	pop	r15
     95c:	ef 90       	pop	r14
     95e:	df 90       	pop	r13
     960:	cf 90       	pop	r12
     962:	bf 90       	pop	r11
     964:	af 90       	pop	r10
     966:	9f 90       	pop	r9
     968:	8f 90       	pop	r8
     96a:	7f 90       	pop	r7
     96c:	6f 90       	pop	r6
     96e:	5f 90       	pop	r5
     970:	4f 90       	pop	r4
     972:	08 95       	ret

00000974 <TCP_GetConnectionInfo>:
 *  \return ConnectionInfo structure of the connection if found, NULL otherwise
 */
TCP_ConnectionInfo_t* TCP_GetConnectionInfo(const uint16_t Port,
                                            const IP_Address_t RemoteAddress,
                                            const uint16_t RemotePort)
{
     974:	4f 92       	push	r4
     976:	5f 92       	push	r5
     978:	6f 92       	push	r6
     97a:	7f 92       	push	r7
     97c:	8f 92       	push	r8
     97e:	9f 92       	push	r9
     980:	af 92       	push	r10
     982:	bf 92       	push	r11
     984:	cf 92       	push	r12
     986:	df 92       	push	r13
     988:	ef 92       	push	r14
     98a:	ff 92       	push	r15
     98c:	0f 93       	push	r16
     98e:	1f 93       	push	r17
     990:	df 93       	push	r29
     992:	cf 93       	push	r28
     994:	00 d0       	rcall	.+0      	; 0x996 <TCP_GetConnectionInfo+0x22>
     996:	00 d0       	rcall	.+0      	; 0x998 <TCP_GetConnectionInfo+0x24>
     998:	cd b7       	in	r28, 0x3d	; 61
     99a:	de b7       	in	r29, 0x3e	; 62
     99c:	4c 01       	movw	r8, r24
     99e:	49 83       	std	Y+1, r20	; 0x01
     9a0:	5a 83       	std	Y+2, r21	; 0x02
     9a2:	6b 83       	std	Y+3, r22	; 0x03
     9a4:	7c 83       	std	Y+4, r23	; 0x04
     9a6:	59 01       	movw	r10, r18
     9a8:	65 eb       	ldi	r22, 0xB5	; 181
     9aa:	e6 2e       	mov	r14, r22
     9ac:	6d e0       	ldi	r22, 0x0D	; 13
     9ae:	f6 2e       	mov	r15, r22
     9b0:	00 e0       	ldi	r16, 0x00	; 0
     9b2:	10 e0       	ldi	r17, 0x00	; 0
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     9b4:	56 e1       	ldi	r21, 0x16	; 22
     9b6:	45 2e       	mov	r4, r21
     9b8:	52 e0       	ldi	r21, 0x02	; 2
     9ba:	55 2e       	mov	r5, r21
     9bc:	3e 01       	movw	r6, r28
     9be:	08 94       	sec
     9c0:	61 1c       	adc	r6, r1
     9c2:	71 1c       	adc	r7, r1
     9c4:	f7 01       	movw	r30, r14
     9c6:	80 81       	ld	r24, Z
     9c8:	91 81       	ldd	r25, Z+1	; 0x01
     9ca:	88 15       	cp	r24, r8
     9cc:	99 05       	cpc	r25, r9
     9ce:	d9 f4       	brne	.+54     	; 0xa06 <TCP_GetConnectionInfo+0x92>
     9d0:	04 9d       	mul	r16, r4
     9d2:	60 01       	movw	r12, r0
     9d4:	05 9d       	mul	r16, r5
     9d6:	d0 0c       	add	r13, r0
     9d8:	14 9d       	mul	r17, r4
     9da:	d0 0c       	add	r13, r0
     9dc:	11 24       	eor	r1, r1
     9de:	c6 01       	movw	r24, r12
     9e0:	87 54       	subi	r24, 0x47	; 71
     9e2:	92 4f       	sbci	r25, 0xF2	; 242
     9e4:	b3 01       	movw	r22, r6
     9e6:	44 e0       	ldi	r20, 0x04	; 4
     9e8:	50 e0       	ldi	r21, 0x00	; 0
     9ea:	0e 94 f0 16 	call	0x2de0	; 0x2de0 <memcmp>
     9ee:	00 97       	sbiw	r24, 0x00	; 0
     9f0:	51 f4       	brne	.+20     	; 0xa06 <TCP_GetConnectionInfo+0x92>
     9f2:	f7 01       	movw	r30, r14
     9f4:	82 81       	ldd	r24, Z+2	; 0x02
     9f6:	93 81       	ldd	r25, Z+3	; 0x03
     9f8:	8a 15       	cp	r24, r10
     9fa:	9b 05       	cpc	r25, r11
     9fc:	21 f4       	brne	.+8      	; 0xa06 <TCP_GetConnectionInfo+0x92>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
		{
			return &ConnectionStateTable[CSTableEntry].Info;
     9fe:	96 01       	movw	r18, r12
     a00:	23 54       	subi	r18, 0x43	; 67
     a02:	32 4f       	sbci	r19, 0xF2	; 242
     a04:	0b c0       	rjmp	.+22     	; 0xa1c <TCP_GetConnectionInfo+0xa8>
     a06:	0f 5f       	subi	r16, 0xFF	; 255
     a08:	1f 4f       	sbci	r17, 0xFF	; 255
     a0a:	86 e1       	ldi	r24, 0x16	; 22
     a0c:	92 e0       	ldi	r25, 0x02	; 2
     a0e:	e8 0e       	add	r14, r24
     a10:	f9 1e       	adc	r15, r25
                                            const IP_Address_t RemoteAddress,
                                            const uint16_t RemotePort)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     a12:	03 30       	cpi	r16, 0x03	; 3
     a14:	11 05       	cpc	r17, r1
     a16:	b1 f6       	brne	.-84     	; 0x9c4 <TCP_GetConnectionInfo+0x50>
     a18:	20 e0       	ldi	r18, 0x00	; 0
     a1a:	30 e0       	ldi	r19, 0x00	; 0
			return &ConnectionStateTable[CSTableEntry].Info;
		}
	}

	return NULL;
}
     a1c:	c9 01       	movw	r24, r18
     a1e:	0f 90       	pop	r0
     a20:	0f 90       	pop	r0
     a22:	0f 90       	pop	r0
     a24:	0f 90       	pop	r0
     a26:	cf 91       	pop	r28
     a28:	df 91       	pop	r29
     a2a:	1f 91       	pop	r17
     a2c:	0f 91       	pop	r16
     a2e:	ff 90       	pop	r15
     a30:	ef 90       	pop	r14
     a32:	df 90       	pop	r13
     a34:	cf 90       	pop	r12
     a36:	bf 90       	pop	r11
     a38:	af 90       	pop	r10
     a3a:	9f 90       	pop	r9
     a3c:	8f 90       	pop	r8
     a3e:	7f 90       	pop	r7
     a40:	6f 90       	pop	r6
     a42:	5f 90       	pop	r5
     a44:	4f 90       	pop	r4
     a46:	08 95       	ret

00000a48 <TCP_GetConnectionState>:
 *  \return A value from the \ref TCP_ConnectionStates_t enum
 */
uint8_t TCP_GetConnectionState(const uint16_t Port,
                               const IP_Address_t RemoteAddress,
                               const uint16_t RemotePort)
{
     a48:	4f 92       	push	r4
     a4a:	5f 92       	push	r5
     a4c:	6f 92       	push	r6
     a4e:	7f 92       	push	r7
     a50:	8f 92       	push	r8
     a52:	9f 92       	push	r9
     a54:	af 92       	push	r10
     a56:	bf 92       	push	r11
     a58:	cf 92       	push	r12
     a5a:	df 92       	push	r13
     a5c:	ef 92       	push	r14
     a5e:	ff 92       	push	r15
     a60:	0f 93       	push	r16
     a62:	1f 93       	push	r17
     a64:	df 93       	push	r29
     a66:	cf 93       	push	r28
     a68:	00 d0       	rcall	.+0      	; 0xa6a <TCP_GetConnectionState+0x22>
     a6a:	00 d0       	rcall	.+0      	; 0xa6c <TCP_GetConnectionState+0x24>
     a6c:	cd b7       	in	r28, 0x3d	; 61
     a6e:	de b7       	in	r29, 0x3e	; 62
     a70:	4c 01       	movw	r8, r24
     a72:	49 83       	std	Y+1, r20	; 0x01
     a74:	5a 83       	std	Y+2, r21	; 0x02
     a76:	6b 83       	std	Y+3, r22	; 0x03
     a78:	7c 83       	std	Y+4, r23	; 0x04
     a7a:	59 01       	movw	r10, r18
     a7c:	e5 eb       	ldi	r30, 0xB5	; 181
     a7e:	ee 2e       	mov	r14, r30
     a80:	ed e0       	ldi	r30, 0x0D	; 13
     a82:	fe 2e       	mov	r15, r30
     a84:	00 e0       	ldi	r16, 0x00	; 0
     a86:	10 e0       	ldi	r17, 0x00	; 0
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     a88:	76 e1       	ldi	r23, 0x16	; 22
     a8a:	47 2e       	mov	r4, r23
     a8c:	72 e0       	ldi	r23, 0x02	; 2
     a8e:	57 2e       	mov	r5, r23
     a90:	3e 01       	movw	r6, r28
     a92:	08 94       	sec
     a94:	61 1c       	adc	r6, r1
     a96:	71 1c       	adc	r7, r1
     a98:	f7 01       	movw	r30, r14
     a9a:	80 81       	ld	r24, Z
     a9c:	91 81       	ldd	r25, Z+1	; 0x01
     a9e:	88 15       	cp	r24, r8
     aa0:	99 05       	cpc	r25, r9
     aa2:	e1 f4       	brne	.+56     	; 0xadc <TCP_GetConnectionState+0x94>
     aa4:	04 9d       	mul	r16, r4
     aa6:	60 01       	movw	r12, r0
     aa8:	05 9d       	mul	r16, r5
     aaa:	d0 0c       	add	r13, r0
     aac:	14 9d       	mul	r17, r4
     aae:	d0 0c       	add	r13, r0
     ab0:	11 24       	eor	r1, r1
     ab2:	c6 01       	movw	r24, r12
     ab4:	87 54       	subi	r24, 0x47	; 71
     ab6:	92 4f       	sbci	r25, 0xF2	; 242
     ab8:	b3 01       	movw	r22, r6
     aba:	44 e0       	ldi	r20, 0x04	; 4
     abc:	50 e0       	ldi	r21, 0x00	; 0
     abe:	0e 94 f0 16 	call	0x2de0	; 0x2de0 <memcmp>
     ac2:	00 97       	sbiw	r24, 0x00	; 0
     ac4:	59 f4       	brne	.+22     	; 0xadc <TCP_GetConnectionState+0x94>
     ac6:	f7 01       	movw	r30, r14
     ac8:	82 81       	ldd	r24, Z+2	; 0x02
     aca:	93 81       	ldd	r25, Z+3	; 0x03
     acc:	8a 15       	cp	r24, r10
     ace:	9b 05       	cpc	r25, r11
     ad0:	29 f4       	brne	.+10     	; 0xadc <TCP_GetConnectionState+0x94>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)

		{
			return ConnectionStateTable[CSTableEntry].State;
     ad2:	f6 01       	movw	r30, r12
     ad4:	e6 53       	subi	r30, 0x36	; 54
     ad6:	f0 4f       	sbci	r31, 0xF0	; 240
     ad8:	80 81       	ld	r24, Z
     ada:	0a c0       	rjmp	.+20     	; 0xaf0 <TCP_GetConnectionState+0xa8>
     adc:	0f 5f       	subi	r16, 0xFF	; 255
     ade:	1f 4f       	sbci	r17, 0xFF	; 255
     ae0:	86 e1       	ldi	r24, 0x16	; 22
     ae2:	92 e0       	ldi	r25, 0x02	; 2
     ae4:	e8 0e       	add	r14, r24
     ae6:	f9 1e       	adc	r15, r25
                               const IP_Address_t RemoteAddress,
                               const uint16_t RemotePort)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     ae8:	03 30       	cpi	r16, 0x03	; 3
     aea:	11 05       	cpc	r17, r1
     aec:	a9 f6       	brne	.-86     	; 0xa98 <TCP_GetConnectionState+0x50>
     aee:	8a e0       	ldi	r24, 0x0A	; 10
			return ConnectionStateTable[CSTableEntry].State;
		}
	}

	return TCP_Connection_Closed;
}
     af0:	0f 90       	pop	r0
     af2:	0f 90       	pop	r0
     af4:	0f 90       	pop	r0
     af6:	0f 90       	pop	r0
     af8:	cf 91       	pop	r28
     afa:	df 91       	pop	r29
     afc:	1f 91       	pop	r17
     afe:	0f 91       	pop	r16
     b00:	ff 90       	pop	r15
     b02:	ef 90       	pop	r14
     b04:	df 90       	pop	r13
     b06:	cf 90       	pop	r12
     b08:	bf 90       	pop	r11
     b0a:	af 90       	pop	r10
     b0c:	9f 90       	pop	r9
     b0e:	8f 90       	pop	r8
     b10:	7f 90       	pop	r7
     b12:	6f 90       	pop	r6
     b14:	5f 90       	pop	r5
     b16:	4f 90       	pop	r4
     b18:	08 95       	ret

00000b1a <TCP_SetConnectionState>:
 */
bool TCP_SetConnectionState(const uint16_t Port,
                            const IP_Address_t RemoteAddress,
                            const uint16_t RemotePort,
                            const uint8_t State)
{
     b1a:	3f 92       	push	r3
     b1c:	4f 92       	push	r4
     b1e:	5f 92       	push	r5
     b20:	6f 92       	push	r6
     b22:	7f 92       	push	r7
     b24:	8f 92       	push	r8
     b26:	9f 92       	push	r9
     b28:	af 92       	push	r10
     b2a:	bf 92       	push	r11
     b2c:	cf 92       	push	r12
     b2e:	df 92       	push	r13
     b30:	ef 92       	push	r14
     b32:	ff 92       	push	r15
     b34:	0f 93       	push	r16
     b36:	1f 93       	push	r17
     b38:	df 93       	push	r29
     b3a:	cf 93       	push	r28
     b3c:	00 d0       	rcall	.+0      	; 0xb3e <TCP_SetConnectionState+0x24>
     b3e:	00 d0       	rcall	.+0      	; 0xb40 <TCP_SetConnectionState+0x26>
     b40:	cd b7       	in	r28, 0x3d	; 61
     b42:	de b7       	in	r29, 0x3e	; 62
     b44:	5c 01       	movw	r10, r24
     b46:	49 83       	std	Y+1, r20	; 0x01
     b48:	5a 83       	std	Y+2, r21	; 0x02
     b4a:	6b 83       	std	Y+3, r22	; 0x03
     b4c:	7c 83       	std	Y+4, r23	; 0x04
     b4e:	49 01       	movw	r8, r18
     b50:	30 2e       	mov	r3, r16
     b52:	15 eb       	ldi	r17, 0xB5	; 181
     b54:	e1 2e       	mov	r14, r17
     b56:	1d e0       	ldi	r17, 0x0D	; 13
     b58:	f1 2e       	mov	r15, r17
     b5a:	00 e0       	ldi	r16, 0x00	; 0
     b5c:	10 e0       	ldi	r17, 0x00	; 0
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     b5e:	b6 e1       	ldi	r27, 0x16	; 22
     b60:	4b 2e       	mov	r4, r27
     b62:	b2 e0       	ldi	r27, 0x02	; 2
     b64:	5b 2e       	mov	r5, r27
     b66:	3e 01       	movw	r6, r28
     b68:	08 94       	sec
     b6a:	61 1c       	adc	r6, r1
     b6c:	71 1c       	adc	r7, r1
     b6e:	f7 01       	movw	r30, r14
     b70:	80 81       	ld	r24, Z
     b72:	91 81       	ldd	r25, Z+1	; 0x01
     b74:	8a 15       	cp	r24, r10
     b76:	9b 05       	cpc	r25, r11
     b78:	d9 f4       	brne	.+54     	; 0xbb0 <TCP_SetConnectionState+0x96>
     b7a:	04 9d       	mul	r16, r4
     b7c:	60 01       	movw	r12, r0
     b7e:	05 9d       	mul	r16, r5
     b80:	d0 0c       	add	r13, r0
     b82:	14 9d       	mul	r17, r4
     b84:	d0 0c       	add	r13, r0
     b86:	11 24       	eor	r1, r1
     b88:	c6 01       	movw	r24, r12
     b8a:	87 54       	subi	r24, 0x47	; 71
     b8c:	92 4f       	sbci	r25, 0xF2	; 242
     b8e:	b3 01       	movw	r22, r6
     b90:	44 e0       	ldi	r20, 0x04	; 4
     b92:	50 e0       	ldi	r21, 0x00	; 0
     b94:	0e 94 f0 16 	call	0x2de0	; 0x2de0 <memcmp>
     b98:	00 97       	sbiw	r24, 0x00	; 0
     b9a:	51 f4       	brne	.+20     	; 0xbb0 <TCP_SetConnectionState+0x96>
     b9c:	f7 01       	movw	r30, r14
     b9e:	82 81       	ldd	r24, Z+2	; 0x02
     ba0:	93 81       	ldd	r25, Z+3	; 0x03
     ba2:	88 15       	cp	r24, r8
     ba4:	99 05       	cpc	r25, r9
     ba6:	21 f4       	brne	.+8      	; 0xbb0 <TCP_SetConnectionState+0x96>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
		{
			ConnectionStateTable[CSTableEntry].State = State;
     ba8:	f6 01       	movw	r30, r12
     baa:	e6 53       	subi	r30, 0x36	; 54
     bac:	f0 4f       	sbci	r31, 0xF0	; 240
     bae:	47 c0       	rjmp	.+142    	; 0xc3e <TCP_SetConnectionState+0x124>
			return true;
     bb0:	0f 5f       	subi	r16, 0xFF	; 255
     bb2:	1f 4f       	sbci	r17, 0xFF	; 255
     bb4:	86 e1       	ldi	r24, 0x16	; 22
     bb6:	92 e0       	ldi	r25, 0x02	; 2
     bb8:	e8 0e       	add	r14, r24
     bba:	f9 1e       	adc	r15, r25
                            const uint16_t RemotePort,
                            const uint8_t State)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     bbc:	03 30       	cpi	r16, 0x03	; 3
     bbe:	11 05       	cpc	r17, r1
     bc0:	b1 f6       	brne	.-84     	; 0xb6e <TCP_SetConnectionState+0x54>
	}

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find empty entry in the table */
		if (ConnectionStateTable[CSTableEntry].State == TCP_Connection_Closed)
     bc2:	80 91 ca 0f 	lds	r24, 0x0FCA
     bc6:	8a 30       	cpi	r24, 0x0A	; 10
     bc8:	19 f4       	brne	.+6      	; 0xbd0 <TCP_SetConnectionState+0xb6>
     bca:	40 e0       	ldi	r20, 0x00	; 0
     bcc:	50 e0       	ldi	r21, 0x00	; 0
     bce:	0f c0       	rjmp	.+30     	; 0xbee <TCP_SetConnectionState+0xd4>
     bd0:	80 91 e0 11 	lds	r24, 0x11E0
     bd4:	8a 30       	cpi	r24, 0x0A	; 10
     bd6:	19 f4       	brne	.+6      	; 0xbde <TCP_SetConnectionState+0xc4>
     bd8:	41 e0       	ldi	r20, 0x01	; 1
     bda:	50 e0       	ldi	r21, 0x00	; 0
     bdc:	08 c0       	rjmp	.+16     	; 0xbee <TCP_SetConnectionState+0xd4>
     bde:	80 91 f6 13 	lds	r24, 0x13F6
     be2:	8a 30       	cpi	r24, 0x0A	; 10
     be4:	11 f0       	breq	.+4      	; 0xbea <TCP_SetConnectionState+0xd0>
     be6:	80 e0       	ldi	r24, 0x00	; 0
     be8:	2c c0       	rjmp	.+88     	; 0xc42 <TCP_SetConnectionState+0x128>
     bea:	42 e0       	ldi	r20, 0x02	; 2
     bec:	50 e0       	ldi	r21, 0x00	; 0
		{
			ConnectionStateTable[CSTableEntry].Port          = Port;
     bee:	86 e1       	ldi	r24, 0x16	; 22
     bf0:	92 e0       	ldi	r25, 0x02	; 2
     bf2:	48 9f       	mul	r20, r24
     bf4:	90 01       	movw	r18, r0
     bf6:	49 9f       	mul	r20, r25
     bf8:	30 0d       	add	r19, r0
     bfa:	58 9f       	mul	r21, r24
     bfc:	30 0d       	add	r19, r0
     bfe:	11 24       	eor	r1, r1
     c00:	2b 54       	subi	r18, 0x4B	; 75
     c02:	32 4f       	sbci	r19, 0xF2	; 242
     c04:	f9 01       	movw	r30, r18
     c06:	b1 82       	std	Z+1, r11	; 0x01
     c08:	a0 82       	st	Z, r10
			ConnectionStateTable[CSTableEntry].RemoteAddress = RemoteAddress;
     c0a:	89 81       	ldd	r24, Y+1	; 0x01
     c0c:	9a 81       	ldd	r25, Y+2	; 0x02
     c0e:	ab 81       	ldd	r26, Y+3	; 0x03
     c10:	bc 81       	ldd	r27, Y+4	; 0x04
     c12:	84 83       	std	Z+4, r24	; 0x04
     c14:	95 83       	std	Z+5, r25	; 0x05
     c16:	a6 83       	std	Z+6, r26	; 0x06
     c18:	b7 83       	std	Z+7, r27	; 0x07
			ConnectionStateTable[CSTableEntry].RemotePort    = RemotePort;
     c1a:	8b e0       	ldi	r24, 0x0B	; 11
     c1c:	91 e0       	ldi	r25, 0x01	; 1
     c1e:	48 9f       	mul	r20, r24
     c20:	f0 01       	movw	r30, r0
     c22:	49 9f       	mul	r20, r25
     c24:	f0 0d       	add	r31, r0
     c26:	58 9f       	mul	r21, r24
     c28:	f0 0d       	add	r31, r0
     c2a:	11 24       	eor	r1, r1
     c2c:	ee 0f       	add	r30, r30
     c2e:	ff 1f       	adc	r31, r31
     c30:	e9 54       	subi	r30, 0x49	; 73
     c32:	f2 4f       	sbci	r31, 0xF2	; 242
     c34:	91 82       	std	Z+1, r9	; 0x01
     c36:	80 82       	st	Z, r8
			ConnectionStateTable[CSTableEntry].State         = State;
     c38:	2b 5e       	subi	r18, 0xEB	; 235
     c3a:	3d 4f       	sbci	r19, 0xFD	; 253
     c3c:	f9 01       	movw	r30, r18
     c3e:	30 82       	st	Z, r3
     c40:	81 e0       	ldi	r24, 0x01	; 1
			return true;
		}
	}

	return false;
}
     c42:	0f 90       	pop	r0
     c44:	0f 90       	pop	r0
     c46:	0f 90       	pop	r0
     c48:	0f 90       	pop	r0
     c4a:	cf 91       	pop	r28
     c4c:	df 91       	pop	r29
     c4e:	1f 91       	pop	r17
     c50:	0f 91       	pop	r16
     c52:	ff 90       	pop	r15
     c54:	ef 90       	pop	r14
     c56:	df 90       	pop	r13
     c58:	cf 90       	pop	r12
     c5a:	bf 90       	pop	r11
     c5c:	af 90       	pop	r10
     c5e:	9f 90       	pop	r9
     c60:	8f 90       	pop	r8
     c62:	7f 90       	pop	r7
     c64:	6f 90       	pop	r6
     c66:	5f 90       	pop	r5
     c68:	4f 90       	pop	r4
     c6a:	3f 90       	pop	r3
     c6c:	08 95       	ret

00000c6e <TCP_ProcessTCPPacket>:
 *           next Ethernet packet handler iteration
 */
int16_t TCP_ProcessTCPPacket(void* IPHeaderInStart,
                             void* TCPHeaderInStart,
                             void* TCPHeaderOutStart)
{
     c6e:	af 92       	push	r10
     c70:	bf 92       	push	r11
     c72:	cf 92       	push	r12
     c74:	df 92       	push	r13
     c76:	ef 92       	push	r14
     c78:	ff 92       	push	r15
     c7a:	0f 93       	push	r16
     c7c:	1f 93       	push	r17
     c7e:	cf 93       	push	r28
     c80:	df 93       	push	r29
     c82:	7b 01       	movw	r14, r22
	IP_Header_t*  IPHeaderIN   = (IP_Header_t*)IPHeaderInStart;
     c84:	5c 01       	movw	r10, r24
	TCP_Header_t* TCPHeaderIN  = (TCP_Header_t*)TCPHeaderInStart;
	TCP_Header_t* TCPHeaderOUT = (TCP_Header_t*)TCPHeaderOutStart;
     c86:	6a 01       	movw	r12, r20

	TCP_ConnectionInfo_t* ConnectionInfo;

	DecodeTCPHeader(TCPHeaderInStart);
     c88:	cb 01       	movw	r24, r22
     c8a:	4e dd       	rcall	.-1380   	; 0x728 <DecodeTCPHeader>

	bool PacketResponse = false;

	/* Check if the destination port is open and allows incoming connections */
	if (TCP_GetPortState(TCPHeaderIN->DestinationPort) == TCP_Port_Open)
     c8c:	d7 01       	movw	r26, r14
     c8e:	12 96       	adiw	r26, 0x02	; 2
     c90:	8d 91       	ld	r24, X+
     c92:	9c 91       	ld	r25, X
     c94:	13 97       	sbiw	r26, 0x03	; 3
     c96:	bf dd       	rcall	.-1154   	; 0x816 <TCP_GetPortState>
     c98:	81 30       	cpi	r24, 0x01	; 1
     c9a:	09 f0       	breq	.+2      	; 0xc9e <TCP_ProcessTCPPacket+0x30>
     c9c:	02 c2       	rjmp	.+1028   	; 0x10a2 <TCP_ProcessTCPPacket+0x434>
	{
		/* Detect SYN from host to start a connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_SYN)
     c9e:	f7 01       	movw	r30, r14
     ca0:	85 85       	ldd	r24, Z+13	; 0x0d
     ca2:	81 ff       	sbrs	r24, 1
     ca4:	0d c0       	rjmp	.+26     	; 0xcc0 <TCP_ProcessTCPPacket+0x52>
		  TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort, TCP_Connection_Listen);
     ca6:	d5 01       	movw	r26, r10
     ca8:	1c 96       	adiw	r26, 0x0c	; 12
     caa:	4d 91       	ld	r20, X+
     cac:	5d 91       	ld	r21, X+
     cae:	6d 91       	ld	r22, X+
     cb0:	7c 91       	ld	r23, X
     cb2:	1f 97       	sbiw	r26, 0x0f	; 15
     cb4:	20 81       	ld	r18, Z
     cb6:	31 81       	ldd	r19, Z+1	; 0x01
     cb8:	82 81       	ldd	r24, Z+2	; 0x02
     cba:	93 81       	ldd	r25, Z+3	; 0x03
     cbc:	00 e0       	ldi	r16, 0x00	; 0
     cbe:	2d df       	rcall	.-422    	; 0xb1a <TCP_SetConnectionState>

		/* Detect RST from host to abort existing connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_RST)
     cc0:	f7 01       	movw	r30, r14
     cc2:	85 85       	ldd	r24, Z+13	; 0x0d
     cc4:	02 80       	ldd	r0, Z+2	; 0x02
     cc6:	f3 81       	ldd	r31, Z+3	; 0x03
     cc8:	e0 2d       	mov	r30, r0
     cca:	d5 01       	movw	r26, r10
     ccc:	1c 96       	adiw	r26, 0x0c	; 12
     cce:	4d 91       	ld	r20, X+
     cd0:	5d 91       	ld	r21, X+
     cd2:	6d 91       	ld	r22, X+
     cd4:	7c 91       	ld	r23, X
     cd6:	1f 97       	sbiw	r26, 0x0f	; 15
     cd8:	d7 01       	movw	r26, r14
     cda:	2d 91       	ld	r18, X+
     cdc:	3c 91       	ld	r19, X
     cde:	82 ff       	sbrs	r24, 2
     ce0:	07 c0       	rjmp	.+14     	; 0xcf0 <TCP_ProcessTCPPacket+0x82>
		{
			if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     ce2:	cf 01       	movw	r24, r30
     ce4:	0a e0       	ldi	r16, 0x0A	; 10
     ce6:	19 df       	rcall	.-462    	; 0xb1a <TCP_SetConnectionState>
     ce8:	88 23       	and	r24, r24
     cea:	09 f4       	brne	.+2      	; 0xcee <TCP_ProcessTCPPacket+0x80>
     cec:	15 c2       	rjmp	.+1066   	; 0x1118 <TCP_ProcessTCPPacket+0x4aa>
     cee:	d9 c1       	rjmp	.+946    	; 0x10a2 <TCP_ProcessTCPPacket+0x434>
			}
		}
		else
		{
			/* Process the incoming TCP packet based on the current connection state for the sender and port */
			switch (TCP_GetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort))
     cf0:	cf 01       	movw	r24, r30
     cf2:	aa de       	rcall	.-684    	; 0xa48 <TCP_GetConnectionState>
     cf4:	84 30       	cpi	r24, 0x04	; 4
     cf6:	09 f4       	brne	.+2      	; 0xcfa <TCP_ProcessTCPPacket+0x8c>
     cf8:	6f c1       	rjmp	.+734    	; 0xfd8 <TCP_ProcessTCPPacket+0x36a>
     cfa:	85 30       	cpi	r24, 0x05	; 5
     cfc:	48 f4       	brcc	.+18     	; 0xd10 <TCP_ProcessTCPPacket+0xa2>
     cfe:	82 30       	cpi	r24, 0x02	; 2
     d00:	09 f4       	brne	.+2      	; 0xd04 <TCP_ProcessTCPPacket+0x96>
     d02:	56 c0       	rjmp	.+172    	; 0xdb0 <TCP_ProcessTCPPacket+0x142>
     d04:	83 30       	cpi	r24, 0x03	; 3
     d06:	08 f0       	brcs	.+2      	; 0xd0a <TCP_ProcessTCPPacket+0x9c>
     d08:	82 c0       	rjmp	.+260    	; 0xe0e <TCP_ProcessTCPPacket+0x1a0>
     d0a:	88 23       	and	r24, r24
     d0c:	59 f0       	breq	.+22     	; 0xd24 <TCP_ProcessTCPPacket+0xb6>
     d0e:	04 c2       	rjmp	.+1032   	; 0x1118 <TCP_ProcessTCPPacket+0x4aa>
     d10:	86 30       	cpi	r24, 0x06	; 6
     d12:	09 f4       	brne	.+2      	; 0xd16 <TCP_ProcessTCPPacket+0xa8>
     d14:	b3 c1       	rjmp	.+870    	; 0x107c <TCP_ProcessTCPPacket+0x40e>
     d16:	86 30       	cpi	r24, 0x06	; 6
     d18:	08 f4       	brcc	.+2      	; 0xd1c <TCP_ProcessTCPPacket+0xae>
     d1a:	74 c1       	rjmp	.+744    	; 0x1004 <TCP_ProcessTCPPacket+0x396>
     d1c:	87 30       	cpi	r24, 0x07	; 7
     d1e:	09 f0       	breq	.+2      	; 0xd22 <TCP_ProcessTCPPacket+0xb4>
     d20:	fb c1       	rjmp	.+1014   	; 0x1118 <TCP_ProcessTCPPacket+0x4aa>
     d22:	36 c1       	rjmp	.+620    	; 0xf90 <TCP_ProcessTCPPacket+0x322>
			{
				case TCP_Connection_Listen:
					if (TCPHeaderIN->Flags == TCP_FLAG_SYN)
     d24:	d7 01       	movw	r26, r14
     d26:	1d 96       	adiw	r26, 0x0d	; 13
     d28:	8c 91       	ld	r24, X
     d2a:	1d 97       	sbiw	r26, 0x0d	; 13
     d2c:	82 30       	cpi	r24, 0x02	; 2
     d2e:	09 f0       	breq	.+2      	; 0xd32 <TCP_ProcessTCPPacket+0xc4>
     d30:	f3 c1       	rjmp	.+998    	; 0x1118 <TCP_ProcessTCPPacket+0x4aa>
					{
						/* SYN connection starts a connection with a peer */
						if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     d32:	f5 01       	movw	r30, r10
     d34:	44 85       	ldd	r20, Z+12	; 0x0c
     d36:	55 85       	ldd	r21, Z+13	; 0x0d
     d38:	66 85       	ldd	r22, Z+14	; 0x0e
     d3a:	77 85       	ldd	r23, Z+15	; 0x0f
     d3c:	2d 91       	ld	r18, X+
     d3e:	3c 91       	ld	r19, X
     d40:	11 97       	sbiw	r26, 0x01	; 1
     d42:	12 96       	adiw	r26, 0x02	; 2
     d44:	8d 91       	ld	r24, X+
     d46:	9c 91       	ld	r25, X
     d48:	13 97       	sbiw	r26, 0x03	; 3
     d4a:	02 e0       	ldi	r16, 0x02	; 2
     d4c:	e6 de       	rcall	.-564    	; 0xb1a <TCP_SetConnectionState>
     d4e:	88 23       	and	r24, r24
     d50:	69 f1       	breq	.+90     	; 0xdac <TCP_ProcessTCPPacket+0x13e>
						                           TCPHeaderIN->SourcePort, TCP_Connection_SYNReceived))
						{
							TCPHeaderOUT->Flags = (TCP_FLAG_SYN | TCP_FLAG_ACK);
     d52:	82 e1       	ldi	r24, 0x12	; 18
     d54:	d6 01       	movw	r26, r12
     d56:	1d 96       	adiw	r26, 0x0d	; 13
     d58:	8c 93       	st	X, r24

							ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort);
     d5a:	f5 01       	movw	r30, r10
     d5c:	44 85       	ldd	r20, Z+12	; 0x0c
     d5e:	55 85       	ldd	r21, Z+13	; 0x0d
     d60:	66 85       	ldd	r22, Z+14	; 0x0e
     d62:	77 85       	ldd	r23, Z+15	; 0x0f
     d64:	d7 01       	movw	r26, r14
     d66:	2d 91       	ld	r18, X+
     d68:	3c 91       	ld	r19, X
     d6a:	11 97       	sbiw	r26, 0x01	; 1
     d6c:	12 96       	adiw	r26, 0x02	; 2
     d6e:	8d 91       	ld	r24, X+
     d70:	9c 91       	ld	r25, X
     d72:	13 97       	sbiw	r26, 0x03	; 3
     d74:	ff dd       	rcall	.-1026   	; 0x974 <TCP_GetConnectionInfo>
     d76:	8c 01       	movw	r16, r24

							ConnectionInfo->SequenceNumberIn  = (SwapEndian_32(TCPHeaderIN->SequenceNumber) + 1);
     d78:	f7 01       	movw	r30, r14
     d7a:	64 81       	ldd	r22, Z+4	; 0x04
     d7c:	75 81       	ldd	r23, Z+5	; 0x05
     d7e:	86 81       	ldd	r24, Z+6	; 0x06
     d80:	97 81       	ldd	r25, Z+7	; 0x07
     d82:	55 dd       	rcall	.-1366   	; 0x82e <SwapEndian_32>
     d84:	6f 5f       	subi	r22, 0xFF	; 255
     d86:	7f 4f       	sbci	r23, 0xFF	; 255
     d88:	8f 4f       	sbci	r24, 0xFF	; 255
     d8a:	9f 4f       	sbci	r25, 0xFF	; 255
     d8c:	d8 01       	movw	r26, r16
     d8e:	6d 93       	st	X+, r22
     d90:	7d 93       	st	X+, r23
     d92:	8d 93       	st	X+, r24
     d94:	9c 93       	st	X, r25
     d96:	13 97       	sbiw	r26, 0x03	; 3
							ConnectionInfo->SequenceNumberOut = 0;
     d98:	f8 01       	movw	r30, r16
     d9a:	14 82       	std	Z+4, r1	; 0x04
     d9c:	15 82       	std	Z+5, r1	; 0x05
     d9e:	16 82       	std	Z+6, r1	; 0x06
     da0:	17 82       	std	Z+7, r1	; 0x07
							ConnectionInfo->Buffer.InUse      = false;
     da2:	04 5f       	subi	r16, 0xF4	; 244
     da4:	1d 4f       	sbci	r17, 0xFD	; 253
     da6:	d8 01       	movw	r26, r16
     da8:	1c 92       	st	X, r1
     daa:	c4 c1       	rjmp	.+904    	; 0x1134 <TCP_ProcessTCPPacket+0x4c6>
						}
						else
						{
							TCPHeaderOUT->Flags = TCP_FLAG_RST;
     dac:	84 e0       	ldi	r24, 0x04	; 4
     dae:	ed c0       	rjmp	.+474    	; 0xf8a <TCP_ProcessTCPPacket+0x31c>
						PacketResponse      = true;
					}

					break;
				case TCP_Connection_SYNReceived:
					if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
     db0:	d7 01       	movw	r26, r14
     db2:	1d 96       	adiw	r26, 0x0d	; 13
     db4:	8c 91       	ld	r24, X
     db6:	1d 97       	sbiw	r26, 0x0d	; 13
     db8:	80 31       	cpi	r24, 0x10	; 16
     dba:	09 f0       	breq	.+2      	; 0xdbe <TCP_ProcessTCPPacket+0x150>
     dbc:	ad c1       	rjmp	.+858    	; 0x1118 <TCP_ProcessTCPPacket+0x4aa>
					{
						/* ACK during the connection process completes the connection to a peer */

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     dbe:	f5 01       	movw	r30, r10
     dc0:	44 85       	ldd	r20, Z+12	; 0x0c
     dc2:	55 85       	ldd	r21, Z+13	; 0x0d
     dc4:	66 85       	ldd	r22, Z+14	; 0x0e
     dc6:	77 85       	ldd	r23, Z+15	; 0x0f
     dc8:	2d 91       	ld	r18, X+
     dca:	3c 91       	ld	r19, X
     dcc:	11 97       	sbiw	r26, 0x01	; 1
     dce:	12 96       	adiw	r26, 0x02	; 2
     dd0:	8d 91       	ld	r24, X+
     dd2:	9c 91       	ld	r25, X
     dd4:	13 97       	sbiw	r26, 0x03	; 3
     dd6:	03 e0       	ldi	r16, 0x03	; 3
     dd8:	a0 de       	rcall	.-704    	; 0xb1a <TCP_SetConnectionState>
											   TCPHeaderIN->SourcePort, TCP_Connection_Established);

						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     dda:	d5 01       	movw	r26, r10
     ddc:	1c 96       	adiw	r26, 0x0c	; 12
     dde:	4d 91       	ld	r20, X+
     de0:	5d 91       	ld	r21, X+
     de2:	6d 91       	ld	r22, X+
     de4:	7c 91       	ld	r23, X
     de6:	1f 97       	sbiw	r26, 0x0f	; 15
     de8:	f7 01       	movw	r30, r14
     dea:	20 81       	ld	r18, Z
     dec:	31 81       	ldd	r19, Z+1	; 0x01
     dee:	82 81       	ldd	r24, Z+2	; 0x02
     df0:	93 81       	ldd	r25, Z+3	; 0x03
     df2:	c0 dd       	rcall	.-1152   	; 0x974 <TCP_GetConnectionInfo>
     df4:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						ConnectionInfo->SequenceNumberOut++;
     df6:	84 81       	ldd	r24, Z+4	; 0x04
     df8:	95 81       	ldd	r25, Z+5	; 0x05
     dfa:	a6 81       	ldd	r26, Z+6	; 0x06
     dfc:	b7 81       	ldd	r27, Z+7	; 0x07
     dfe:	01 96       	adiw	r24, 0x01	; 1
     e00:	a1 1d       	adc	r26, r1
     e02:	b1 1d       	adc	r27, r1
     e04:	84 83       	std	Z+4, r24	; 0x04
     e06:	95 83       	std	Z+5, r25	; 0x05
     e08:	a6 83       	std	Z+6, r26	; 0x06
     e0a:	b7 83       	std	Z+7, r27	; 0x07
     e0c:	85 c1       	rjmp	.+778    	; 0x1118 <TCP_ProcessTCPPacket+0x4aa>
					}

					break;
				case TCP_Connection_Established:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
     e0e:	d7 01       	movw	r26, r14
     e10:	1d 96       	adiw	r26, 0x0d	; 13
     e12:	8c 91       	ld	r24, X
     e14:	81 31       	cpi	r24, 0x11	; 17
     e16:	a9 f5       	brne	.+106    	; 0xe82 <TCP_ProcessTCPPacket+0x214>
					{
						/* FIN ACK when connected to a peer starts the finalization process */

						TCPHeaderOUT->Flags = (TCP_FLAG_FIN | TCP_FLAG_ACK);
     e18:	f6 01       	movw	r30, r12
     e1a:	85 87       	std	Z+13, r24	; 0x0d
						PacketResponse      = true;

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     e1c:	d5 01       	movw	r26, r10
     e1e:	1c 96       	adiw	r26, 0x0c	; 12
     e20:	4d 91       	ld	r20, X+
     e22:	5d 91       	ld	r21, X+
     e24:	6d 91       	ld	r22, X+
     e26:	7c 91       	ld	r23, X
     e28:	1f 97       	sbiw	r26, 0x0f	; 15
     e2a:	f7 01       	movw	r30, r14
     e2c:	20 81       	ld	r18, Z
     e2e:	31 81       	ldd	r19, Z+1	; 0x01
     e30:	82 81       	ldd	r24, Z+2	; 0x02
     e32:	93 81       	ldd	r25, Z+3	; 0x03
     e34:	06 e0       	ldi	r16, 0x06	; 6
     e36:	71 de       	rcall	.-798    	; 0xb1a <TCP_SetConnectionState>
											   TCPHeaderIN->SourcePort, TCP_Connection_CloseWait);

						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     e38:	d5 01       	movw	r26, r10
     e3a:	1c 96       	adiw	r26, 0x0c	; 12
     e3c:	4d 91       	ld	r20, X+
     e3e:	5d 91       	ld	r21, X+
     e40:	6d 91       	ld	r22, X+
     e42:	7c 91       	ld	r23, X
     e44:	1f 97       	sbiw	r26, 0x0f	; 15
     e46:	f7 01       	movw	r30, r14
     e48:	20 81       	ld	r18, Z
     e4a:	31 81       	ldd	r19, Z+1	; 0x01
     e4c:	82 81       	ldd	r24, Z+2	; 0x02
     e4e:	93 81       	ldd	r25, Z+3	; 0x03
     e50:	91 dd       	rcall	.-1246   	; 0x974 <TCP_GetConnectionInfo>
     e52:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						ConnectionInfo->SequenceNumberIn++;
     e54:	80 81       	ld	r24, Z
     e56:	91 81       	ldd	r25, Z+1	; 0x01
     e58:	a2 81       	ldd	r26, Z+2	; 0x02
     e5a:	b3 81       	ldd	r27, Z+3	; 0x03
     e5c:	01 96       	adiw	r24, 0x01	; 1
     e5e:	a1 1d       	adc	r26, r1
     e60:	b1 1d       	adc	r27, r1
     e62:	80 83       	st	Z, r24
     e64:	91 83       	std	Z+1, r25	; 0x01
     e66:	a2 83       	std	Z+2, r26	; 0x02
     e68:	b3 83       	std	Z+3, r27	; 0x03
						ConnectionInfo->SequenceNumberOut++;
     e6a:	84 81       	ldd	r24, Z+4	; 0x04
     e6c:	95 81       	ldd	r25, Z+5	; 0x05
     e6e:	a6 81       	ldd	r26, Z+6	; 0x06
     e70:	b7 81       	ldd	r27, Z+7	; 0x07
     e72:	01 96       	adiw	r24, 0x01	; 1
     e74:	a1 1d       	adc	r26, r1
     e76:	b1 1d       	adc	r27, r1
     e78:	84 83       	std	Z+4, r24	; 0x04
     e7a:	95 83       	std	Z+5, r25	; 0x05
     e7c:	a6 83       	std	Z+6, r26	; 0x06
     e7e:	b7 83       	std	Z+7, r27	; 0x07
     e80:	59 c1       	rjmp	.+690    	; 0x1134 <TCP_ProcessTCPPacket+0x4c6>
					}
					else if ((TCPHeaderIN->Flags == TCP_FLAG_ACK) || (TCPHeaderIN->Flags == (TCP_FLAG_ACK | TCP_FLAG_PSH)))
     e82:	80 31       	cpi	r24, 0x10	; 16
     e84:	19 f0       	breq	.+6      	; 0xe8c <TCP_ProcessTCPPacket+0x21e>
     e86:	88 31       	cpi	r24, 0x18	; 24
     e88:	09 f0       	breq	.+2      	; 0xe8c <TCP_ProcessTCPPacket+0x21e>
     e8a:	46 c1       	rjmp	.+652    	; 0x1118 <TCP_ProcessTCPPacket+0x4aa>
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     e8c:	d5 01       	movw	r26, r10
     e8e:	1c 96       	adiw	r26, 0x0c	; 12
     e90:	4d 91       	ld	r20, X+
     e92:	5d 91       	ld	r21, X+
     e94:	6d 91       	ld	r22, X+
     e96:	7c 91       	ld	r23, X
     e98:	1f 97       	sbiw	r26, 0x0f	; 15
     e9a:	f7 01       	movw	r30, r14
     e9c:	20 81       	ld	r18, Z
     e9e:	31 81       	ldd	r19, Z+1	; 0x01
     ea0:	82 81       	ldd	r24, Z+2	; 0x02
     ea2:	93 81       	ldd	r25, Z+3	; 0x03
     ea4:	67 dd       	rcall	.-1330   	; 0x974 <TCP_GetConnectionInfo>
     ea6:	ec 01       	movw	r28, r24
															   TCPHeaderIN->SourcePort);

						/* Check if the buffer is currently in use either by a buffered data to send, or receive */
						if ((ConnectionInfo->Buffer.InUse == false) && (ConnectionInfo->Buffer.Ready == false))
     ea8:	fc 01       	movw	r30, r24
     eaa:	e4 5f       	subi	r30, 0xF4	; 244
     eac:	fd 4f       	sbci	r31, 0xFD	; 253
     eae:	80 81       	ld	r24, Z
     eb0:	88 23       	and	r24, r24
     eb2:	81 f4       	brne	.+32     	; 0xed4 <TCP_ProcessTCPPacket+0x266>
     eb4:	c5 5f       	subi	r28, 0xF5	; 245
     eb6:	dd 4f       	sbci	r29, 0xFD	; 253
     eb8:	88 81       	ld	r24, Y
     eba:	cb 50       	subi	r28, 0x0B	; 11
     ebc:	d2 40       	sbci	r29, 0x02	; 2
     ebe:	88 23       	and	r24, r24
     ec0:	49 f4       	brne	.+18     	; 0xed4 <TCP_ProcessTCPPacket+0x266>
						{
							ConnectionInfo->Buffer.Direction = TCP_PACKETDIR_IN;
     ec2:	c6 5f       	subi	r28, 0xF6	; 246
     ec4:	dd 4f       	sbci	r29, 0xFD	; 253
     ec6:	18 82       	st	Y, r1
     ec8:	ca 50       	subi	r28, 0x0A	; 10
     eca:	d2 40       	sbci	r29, 0x02	; 2
							ConnectionInfo->Buffer.InUse     = true;
     ecc:	81 e0       	ldi	r24, 0x01	; 1
     ece:	80 83       	st	Z, r24
							ConnectionInfo->Buffer.Length    = 0;
     ed0:	19 86       	std	Y+9, r1	; 0x09
     ed2:	18 86       	std	Y+8, r1	; 0x08
						}

						/* Check if the buffer has been claimed by us to read in data from the peer */
						if ((ConnectionInfo->Buffer.Direction == TCP_PACKETDIR_IN) &&
     ed4:	c6 5f       	subi	r28, 0xF6	; 246
     ed6:	dd 4f       	sbci	r29, 0xFD	; 253
     ed8:	88 81       	ld	r24, Y
     eda:	ca 50       	subi	r28, 0x0A	; 10
     edc:	d2 40       	sbci	r29, 0x02	; 2
     ede:	88 23       	and	r24, r24
     ee0:	09 f0       	breq	.+2      	; 0xee4 <TCP_ProcessTCPPacket+0x276>
     ee2:	17 c1       	rjmp	.+558    	; 0x1112 <TCP_ProcessTCPPacket+0x4a4>
     ee4:	68 85       	ldd	r22, Y+8	; 0x08
     ee6:	79 85       	ldd	r23, Y+9	; 0x09
     ee8:	f2 e0       	ldi	r31, 0x02	; 2
     eea:	60 30       	cpi	r22, 0x00	; 0
     eec:	7f 07       	cpc	r23, r31
     eee:	09 f4       	brne	.+2      	; 0xef2 <TCP_ProcessTCPPacket+0x284>
     ef0:	10 c1       	rjmp	.+544    	; 0x1112 <TCP_ProcessTCPPacket+0x4a4>
							(ConnectionInfo->Buffer.Length != TCP_WINDOW_SIZE))
						{
							uint16_t IPOffset   = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
     ef2:	d5 01       	movw	r26, r10
     ef4:	8c 91       	ld	r24, X
     ef6:	8f 70       	andi	r24, 0x0F	; 15
							uint16_t TCPOffset  = (TCPHeaderIN->DataOffset * sizeof(uint32_t));
     ef8:	f7 01       	movw	r30, r14
     efa:	44 85       	ldd	r20, Z+12	; 0x0c
     efc:	42 95       	swap	r20
     efe:	4f 70       	andi	r20, 0x0F	; 15
     f00:	50 e0       	ldi	r21, 0x00	; 0
     f02:	44 0f       	add	r20, r20
     f04:	55 1f       	adc	r21, r21
     f06:	44 0f       	add	r20, r20
     f08:	55 1f       	adc	r21, r21
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
     f0a:	12 96       	adiw	r26, 0x02	; 2
     f0c:	0d 91       	ld	r16, X+
     f0e:	1c 91       	ld	r17, X
     f10:	13 97       	sbiw	r26, 0x03	; 3

				Temp = Data.Bytes[0];
     f12:	20 2f       	mov	r18, r16
				Data.Bytes[0] = Data.Bytes[1];
     f14:	01 2f       	mov	r16, r17
				Data.Bytes[1] = Temp;
     f16:	12 2f       	mov	r17, r18
							uint16_t DataLength = (SwapEndian_16(IPHeaderIN->TotalLength) - IPOffset - TCPOffset);
     f18:	90 e0       	ldi	r25, 0x00	; 0
     f1a:	88 0f       	add	r24, r24
     f1c:	99 1f       	adc	r25, r25
     f1e:	88 0f       	add	r24, r24
     f20:	99 1f       	adc	r25, r25
     f22:	08 1b       	sub	r16, r24
     f24:	19 0b       	sbc	r17, r25
     f26:	04 1b       	sub	r16, r20
     f28:	15 0b       	sbc	r17, r21

							/* Copy the packet data into the buffer */
							memcpy(&ConnectionInfo->Buffer.Data[ConnectionInfo->Buffer.Length],
     f2a:	9b 01       	movw	r18, r22
     f2c:	26 5f       	subi	r18, 0xF6	; 246
     f2e:	3f 4f       	sbci	r19, 0xFF	; 255
     f30:	2c 0f       	add	r18, r28
     f32:	3d 1f       	adc	r19, r29
     f34:	4e 0d       	add	r20, r14
     f36:	5f 1d       	adc	r21, r15
     f38:	c9 01       	movw	r24, r18
     f3a:	ba 01       	movw	r22, r20
     f3c:	a8 01       	movw	r20, r16
     f3e:	0e 94 fd 16 	call	0x2dfa	; 0x2dfa <memcpy>
								   &((uint8_t*)TCPHeaderInStart)[TCPOffset],
								   DataLength);

							ConnectionInfo->SequenceNumberIn += DataLength;
     f42:	98 01       	movw	r18, r16
     f44:	40 e0       	ldi	r20, 0x00	; 0
     f46:	50 e0       	ldi	r21, 0x00	; 0
     f48:	88 81       	ld	r24, Y
     f4a:	99 81       	ldd	r25, Y+1	; 0x01
     f4c:	aa 81       	ldd	r26, Y+2	; 0x02
     f4e:	bb 81       	ldd	r27, Y+3	; 0x03
     f50:	82 0f       	add	r24, r18
     f52:	93 1f       	adc	r25, r19
     f54:	a4 1f       	adc	r26, r20
     f56:	b5 1f       	adc	r27, r21
     f58:	88 83       	st	Y, r24
     f5a:	99 83       	std	Y+1, r25	; 0x01
     f5c:	aa 83       	std	Y+2, r26	; 0x02
     f5e:	bb 83       	std	Y+3, r27	; 0x03
							ConnectionInfo->Buffer.Length    += DataLength;
     f60:	88 85       	ldd	r24, Y+8	; 0x08
     f62:	99 85       	ldd	r25, Y+9	; 0x09
     f64:	80 0f       	add	r24, r16
     f66:	91 1f       	adc	r25, r17
     f68:	99 87       	std	Y+9, r25	; 0x09
     f6a:	88 87       	std	Y+8, r24	; 0x08

							/* Check if the buffer is full or if the PSH flag is set, if so indicate buffer ready */
							if ((!(TCP_WINDOW_SIZE - ConnectionInfo->Buffer.Length)) || (TCPHeaderIN->Flags & TCP_FLAG_PSH))
     f6c:	80 50       	subi	r24, 0x00	; 0
     f6e:	92 40       	sbci	r25, 0x02	; 2
     f70:	29 f0       	breq	.+10     	; 0xf7c <TCP_ProcessTCPPacket+0x30e>
     f72:	d7 01       	movw	r26, r14
     f74:	1d 96       	adiw	r26, 0x0d	; 13
     f76:	8c 91       	ld	r24, X
     f78:	83 ff       	sbrs	r24, 3
     f7a:	ce c0       	rjmp	.+412    	; 0x1118 <TCP_ProcessTCPPacket+0x4aa>
							{
								ConnectionInfo->Buffer.InUse = false;
     f7c:	c4 5f       	subi	r28, 0xF4	; 244
     f7e:	dd 4f       	sbci	r29, 0xFD	; 253
     f80:	18 82       	st	Y, r1
								ConnectionInfo->Buffer.Ready = true;
     f82:	fe 01       	movw	r30, r28
     f84:	81 e0       	ldi	r24, 0x01	; 1
     f86:	82 93       	st	-Z, r24

								TCPHeaderOUT->Flags = TCP_FLAG_ACK;
     f88:	80 e1       	ldi	r24, 0x10	; 16
     f8a:	f6 01       	movw	r30, r12
     f8c:	85 87       	std	Z+13, r24	; 0x0d
     f8e:	d2 c0       	rjmp	.+420    	; 0x1134 <TCP_ProcessTCPPacket+0x4c6>
						}
					}

					break;
				case TCP_Connection_Closing:
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     f90:	d5 01       	movw	r26, r10
     f92:	1c 96       	adiw	r26, 0x0c	; 12
     f94:	4d 91       	ld	r20, X+
     f96:	5d 91       	ld	r21, X+
     f98:	6d 91       	ld	r22, X+
     f9a:	7c 91       	ld	r23, X
     f9c:	1f 97       	sbiw	r26, 0x0f	; 15
     f9e:	f7 01       	movw	r30, r14
     fa0:	20 81       	ld	r18, Z
     fa2:	31 81       	ldd	r19, Z+1	; 0x01
     fa4:	82 81       	ldd	r24, Z+2	; 0x02
     fa6:	93 81       	ldd	r25, Z+3	; 0x03
     fa8:	e5 dc       	rcall	.-1590   	; 0x974 <TCP_GetConnectionInfo>
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = (TCP_FLAG_ACK | TCP_FLAG_FIN);
     faa:	21 e1       	ldi	r18, 0x11	; 17
     fac:	d6 01       	movw	r26, r12
     fae:	1d 96       	adiw	r26, 0x0d	; 13
     fb0:	2c 93       	st	X, r18
						PacketResponse      = true;

						ConnectionInfo->Buffer.InUse = false;
     fb2:	fc 01       	movw	r30, r24
     fb4:	e4 5f       	subi	r30, 0xF4	; 244
     fb6:	fd 4f       	sbci	r31, 0xFD	; 253
     fb8:	10 82       	st	Z, r1

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     fba:	f5 01       	movw	r30, r10
     fbc:	44 85       	ldd	r20, Z+12	; 0x0c
     fbe:	55 85       	ldd	r21, Z+13	; 0x0d
     fc0:	66 85       	ldd	r22, Z+14	; 0x0e
     fc2:	77 85       	ldd	r23, Z+15	; 0x0f
     fc4:	d7 01       	movw	r26, r14
     fc6:	2d 91       	ld	r18, X+
     fc8:	3c 91       	ld	r19, X
     fca:	11 97       	sbiw	r26, 0x01	; 1
     fcc:	12 96       	adiw	r26, 0x02	; 2
     fce:	8d 91       	ld	r24, X+
     fd0:	9c 91       	ld	r25, X
     fd2:	13 97       	sbiw	r26, 0x03	; 3
     fd4:	04 e0       	ldi	r16, 0x04	; 4
     fd6:	50 c0       	rjmp	.+160    	; 0x1078 <TCP_ProcessTCPPacket+0x40a>
											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait1);

					break;
				case TCP_Connection_FINWait1:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
     fd8:	f7 01       	movw	r30, r14
     fda:	85 85       	ldd	r24, Z+13	; 0x0d
     fdc:	81 31       	cpi	r24, 0x11	; 17
     fde:	b9 f0       	breq	.+46     	; 0x100e <TCP_ProcessTCPPacket+0x3a0>
						ConnectionInfo->SequenceNumberOut++;

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
					}
					else if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
     fe0:	80 31       	cpi	r24, 0x10	; 16
     fe2:	09 f0       	breq	.+2      	; 0xfe6 <TCP_ProcessTCPPacket+0x378>
     fe4:	99 c0       	rjmp	.+306    	; 0x1118 <TCP_ProcessTCPPacket+0x4aa>
					{
						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     fe6:	f5 01       	movw	r30, r10
     fe8:	44 85       	ldd	r20, Z+12	; 0x0c
     fea:	55 85       	ldd	r21, Z+13	; 0x0d
     fec:	66 85       	ldd	r22, Z+14	; 0x0e
     fee:	77 85       	ldd	r23, Z+15	; 0x0f
     ff0:	d7 01       	movw	r26, r14
     ff2:	2d 91       	ld	r18, X+
     ff4:	3c 91       	ld	r19, X
     ff6:	11 97       	sbiw	r26, 0x01	; 1
     ff8:	12 96       	adiw	r26, 0x02	; 2
     ffa:	8d 91       	ld	r24, X+
     ffc:	9c 91       	ld	r25, X
     ffe:	13 97       	sbiw	r26, 0x03	; 3
    1000:	05 e0       	ldi	r16, 0x05	; 5
    1002:	4d c0       	rjmp	.+154    	; 0x109e <TCP_ProcessTCPPacket+0x430>
											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait2);
					}

					break;
				case TCP_Connection_FINWait2:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    1004:	f7 01       	movw	r30, r14
    1006:	85 85       	ldd	r24, Z+13	; 0x0d
    1008:	81 31       	cpi	r24, 0x11	; 17
    100a:	09 f0       	breq	.+2      	; 0x100e <TCP_ProcessTCPPacket+0x3a0>
    100c:	85 c0       	rjmp	.+266    	; 0x1118 <TCP_ProcessTCPPacket+0x4aa>
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    100e:	d5 01       	movw	r26, r10
    1010:	1c 96       	adiw	r26, 0x0c	; 12
    1012:	4d 91       	ld	r20, X+
    1014:	5d 91       	ld	r21, X+
    1016:	6d 91       	ld	r22, X+
    1018:	7c 91       	ld	r23, X
    101a:	1f 97       	sbiw	r26, 0x0f	; 15
    101c:	20 81       	ld	r18, Z
    101e:	31 81       	ldd	r19, Z+1	; 0x01
    1020:	82 81       	ldd	r24, Z+2	; 0x02
    1022:	93 81       	ldd	r25, Z+3	; 0x03
    1024:	a7 dc       	rcall	.-1714   	; 0x974 <TCP_GetConnectionInfo>
    1026:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = TCP_FLAG_ACK;
    1028:	80 e1       	ldi	r24, 0x10	; 16
    102a:	d6 01       	movw	r26, r12
    102c:	1d 96       	adiw	r26, 0x0d	; 13
    102e:	8c 93       	st	X, r24
						PacketResponse      = true;

						ConnectionInfo->SequenceNumberIn++;
    1030:	80 81       	ld	r24, Z
    1032:	91 81       	ldd	r25, Z+1	; 0x01
    1034:	a2 81       	ldd	r26, Z+2	; 0x02
    1036:	b3 81       	ldd	r27, Z+3	; 0x03
    1038:	01 96       	adiw	r24, 0x01	; 1
    103a:	a1 1d       	adc	r26, r1
    103c:	b1 1d       	adc	r27, r1
    103e:	80 83       	st	Z, r24
    1040:	91 83       	std	Z+1, r25	; 0x01
    1042:	a2 83       	std	Z+2, r26	; 0x02
    1044:	b3 83       	std	Z+3, r27	; 0x03
						ConnectionInfo->SequenceNumberOut++;
    1046:	84 81       	ldd	r24, Z+4	; 0x04
    1048:	95 81       	ldd	r25, Z+5	; 0x05
    104a:	a6 81       	ldd	r26, Z+6	; 0x06
    104c:	b7 81       	ldd	r27, Z+7	; 0x07
    104e:	01 96       	adiw	r24, 0x01	; 1
    1050:	a1 1d       	adc	r26, r1
    1052:	b1 1d       	adc	r27, r1
    1054:	84 83       	std	Z+4, r24	; 0x04
    1056:	95 83       	std	Z+5, r25	; 0x05
    1058:	a6 83       	std	Z+6, r26	; 0x06
    105a:	b7 83       	std	Z+7, r27	; 0x07

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    105c:	f5 01       	movw	r30, r10
    105e:	44 85       	ldd	r20, Z+12	; 0x0c
    1060:	55 85       	ldd	r21, Z+13	; 0x0d
    1062:	66 85       	ldd	r22, Z+14	; 0x0e
    1064:	77 85       	ldd	r23, Z+15	; 0x0f
    1066:	d7 01       	movw	r26, r14
    1068:	2d 91       	ld	r18, X+
    106a:	3c 91       	ld	r19, X
    106c:	11 97       	sbiw	r26, 0x01	; 1
    106e:	12 96       	adiw	r26, 0x02	; 2
    1070:	8d 91       	ld	r24, X+
    1072:	9c 91       	ld	r25, X
    1074:	13 97       	sbiw	r26, 0x03	; 3
    1076:	0a e0       	ldi	r16, 0x0A	; 10
    1078:	50 dd       	rcall	.-1376   	; 0xb1a <TCP_SetConnectionState>
    107a:	5c c0       	rjmp	.+184    	; 0x1134 <TCP_ProcessTCPPacket+0x4c6>
											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
					}

					break;
				case TCP_Connection_CloseWait:
					if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    107c:	f7 01       	movw	r30, r14
    107e:	85 85       	ldd	r24, Z+13	; 0x0d
    1080:	80 31       	cpi	r24, 0x10	; 16
    1082:	09 f0       	breq	.+2      	; 0x1086 <TCP_ProcessTCPPacket+0x418>
    1084:	49 c0       	rjmp	.+146    	; 0x1118 <TCP_ProcessTCPPacket+0x4aa>
					{
						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1086:	d5 01       	movw	r26, r10
    1088:	1c 96       	adiw	r26, 0x0c	; 12
    108a:	4d 91       	ld	r20, X+
    108c:	5d 91       	ld	r21, X+
    108e:	6d 91       	ld	r22, X+
    1090:	7c 91       	ld	r23, X
    1092:	1f 97       	sbiw	r26, 0x0f	; 15
    1094:	20 81       	ld	r18, Z
    1096:	31 81       	ldd	r19, Z+1	; 0x01
    1098:	82 81       	ldd	r24, Z+2	; 0x02
    109a:	93 81       	ldd	r25, Z+3	; 0x03
    109c:	0a e0       	ldi	r16, 0x0A	; 10
    109e:	3d dd       	rcall	.-1414   	; 0xb1a <TCP_SetConnectionState>
    10a0:	3b c0       	rjmp	.+118    	; 0x1118 <TCP_ProcessTCPPacket+0x4aa>
		}
	}
	else
	{
		/* Port is not open, indicate via a RST/ACK response to the sender */
		TCPHeaderOUT->Flags = (TCP_FLAG_RST | TCP_FLAG_ACK);
    10a2:	84 e1       	ldi	r24, 0x14	; 20
    10a4:	72 cf       	rjmp	.-284    	; 0xf8a <TCP_ProcessTCPPacket+0x31c>
		TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionInfo->SequenceNumberOut);
		TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionInfo->SequenceNumberIn);
		TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));

		if (!(ConnectionInfo->Buffer.InUse))
		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE);
    10a6:	82 e0       	ldi	r24, 0x02	; 2
    10a8:	90 e0       	ldi	r25, 0x00	; 0
    10aa:	d6 01       	movw	r26, r12
    10ac:	1f 96       	adiw	r26, 0x0f	; 15
    10ae:	9c 93       	st	X, r25
    10b0:	8e 93       	st	-X, r24
    10b2:	1e 97       	sbiw	r26, 0x0e	; 14
    10b4:	09 c0       	rjmp	.+18     	; 0x10c8 <TCP_ProcessTCPPacket+0x45a>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    10b6:	80 e0       	ldi	r24, 0x00	; 0
    10b8:	92 e0       	ldi	r25, 0x02	; 2
    10ba:	28 85       	ldd	r18, Y+8	; 0x08
    10bc:	39 85       	ldd	r19, Y+9	; 0x09
    10be:	82 1b       	sub	r24, r18
    10c0:	93 0b       	sbc	r25, r19
		else
		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE - ConnectionInfo->Buffer.Length);
    10c2:	f6 01       	movw	r30, r12
    10c4:	96 87       	std	Z+14, r25	; 0x0e
    10c6:	87 87       	std	Z+15, r24	; 0x0f

		TCPHeaderOUT->UrgentPointer        = 0;
    10c8:	d6 01       	movw	r26, r12
    10ca:	53 96       	adiw	r26, 0x13	; 19
    10cc:	1c 92       	st	X, r1
    10ce:	1e 92       	st	-X, r1
    10d0:	52 97       	sbiw	r26, 0x12	; 18
		TCPHeaderOUT->Checksum             = 0;
    10d2:	51 96       	adiw	r26, 0x11	; 17
    10d4:	1c 92       	st	X, r1
    10d6:	1e 92       	st	-X, r1
    10d8:	50 97       	sbiw	r26, 0x10	; 16
		TCPHeaderOUT->Reserved             = 0;
    10da:	1c 96       	adiw	r26, 0x0c	; 12
    10dc:	8c 91       	ld	r24, X
    10de:	1c 97       	sbiw	r26, 0x0c	; 12
    10e0:	80 7f       	andi	r24, 0xF0	; 240
    10e2:	1c 96       	adiw	r26, 0x0c	; 12
    10e4:	8c 93       	st	X, r24

		TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, IPHeaderIN->DestinationAddress,
    10e6:	f5 01       	movw	r30, r10
    10e8:	40 89       	ldd	r20, Z+16	; 0x10
    10ea:	51 89       	ldd	r21, Z+17	; 0x11
    10ec:	62 89       	ldd	r22, Z+18	; 0x12
    10ee:	73 89       	ldd	r23, Z+19	; 0x13
    10f0:	04 85       	ldd	r16, Z+12	; 0x0c
    10f2:	15 85       	ldd	r17, Z+13	; 0x0d
    10f4:	26 85       	ldd	r18, Z+14	; 0x0e
    10f6:	37 85       	ldd	r19, Z+15	; 0x0f
    10f8:	c6 01       	movw	r24, r12
    10fa:	e4 e1       	ldi	r30, 0x14	; 20
    10fc:	ee 2e       	mov	r14, r30
    10fe:	f1 2c       	mov	r15, r1
    1100:	9c db       	rcall	.-2248   	; 0x83a <TCP_Checksum16>
    1102:	d6 01       	movw	r26, r12
    1104:	51 96       	adiw	r26, 0x11	; 17
    1106:	9c 93       	st	X, r25
    1108:	8e 93       	st	-X, r24
    110a:	50 97       	sbiw	r26, 0x10	; 16
    110c:	24 e1       	ldi	r18, 0x14	; 20
    110e:	30 e0       	ldi	r19, 0x00	; 0
    1110:	05 c0       	rjmp	.+10     	; 0x111c <TCP_ProcessTCPPacket+0x4ae>
		                                                    IPHeaderIN->SourceAddress, sizeof(TCP_Header_t));

		return sizeof(TCP_Header_t);
    1112:	2f ef       	ldi	r18, 0xFF	; 255
    1114:	3f ef       	ldi	r19, 0xFF	; 255
    1116:	02 c0       	rjmp	.+4      	; 0x111c <TCP_ProcessTCPPacket+0x4ae>
    1118:	20 e0       	ldi	r18, 0x00	; 0
    111a:	30 e0       	ldi	r19, 0x00	; 0
	}

	return NO_RESPONSE;
}
    111c:	c9 01       	movw	r24, r18
    111e:	df 91       	pop	r29
    1120:	cf 91       	pop	r28
    1122:	1f 91       	pop	r17
    1124:	0f 91       	pop	r16
    1126:	ff 90       	pop	r15
    1128:	ef 90       	pop	r14
    112a:	df 90       	pop	r13
    112c:	cf 90       	pop	r12
    112e:	bf 90       	pop	r11
    1130:	af 90       	pop	r10
    1132:	08 95       	ret
	}

	/* Check if we need to respond to the sent packet */
	if (PacketResponse)
	{
		ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1134:	f5 01       	movw	r30, r10
    1136:	44 85       	ldd	r20, Z+12	; 0x0c
    1138:	55 85       	ldd	r21, Z+13	; 0x0d
    113a:	66 85       	ldd	r22, Z+14	; 0x0e
    113c:	77 85       	ldd	r23, Z+15	; 0x0f
    113e:	d7 01       	movw	r26, r14
    1140:	2d 91       	ld	r18, X+
    1142:	3c 91       	ld	r19, X
    1144:	11 97       	sbiw	r26, 0x01	; 1
    1146:	12 96       	adiw	r26, 0x02	; 2
    1148:	8d 91       	ld	r24, X+
    114a:	9c 91       	ld	r25, X
    114c:	13 97       	sbiw	r26, 0x03	; 3
    114e:	12 dc       	rcall	.-2012   	; 0x974 <TCP_GetConnectionInfo>
    1150:	ec 01       	movw	r28, r24
		                                       TCPHeaderIN->SourcePort);

		TCPHeaderOUT->SourcePort           = TCPHeaderIN->DestinationPort;
    1152:	f7 01       	movw	r30, r14
    1154:	82 81       	ldd	r24, Z+2	; 0x02
    1156:	93 81       	ldd	r25, Z+3	; 0x03
    1158:	d6 01       	movw	r26, r12
    115a:	11 96       	adiw	r26, 0x01	; 1
    115c:	9c 93       	st	X, r25
    115e:	8e 93       	st	-X, r24
		TCPHeaderOUT->DestinationPort      = TCPHeaderIN->SourcePort;
    1160:	80 81       	ld	r24, Z
    1162:	91 81       	ldd	r25, Z+1	; 0x01
    1164:	13 96       	adiw	r26, 0x03	; 3
    1166:	9c 93       	st	X, r25
    1168:	8e 93       	st	-X, r24
    116a:	12 97       	sbiw	r26, 0x02	; 2
		TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionInfo->SequenceNumberOut);
    116c:	6c 81       	ldd	r22, Y+4	; 0x04
    116e:	7d 81       	ldd	r23, Y+5	; 0x05
    1170:	8e 81       	ldd	r24, Y+6	; 0x06
    1172:	9f 81       	ldd	r25, Y+7	; 0x07
    1174:	5c db       	rcall	.-2376   	; 0x82e <SwapEndian_32>
    1176:	f6 01       	movw	r30, r12
    1178:	64 83       	std	Z+4, r22	; 0x04
    117a:	75 83       	std	Z+5, r23	; 0x05
    117c:	86 83       	std	Z+6, r24	; 0x06
    117e:	97 83       	std	Z+7, r25	; 0x07
		TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionInfo->SequenceNumberIn);
    1180:	68 81       	ld	r22, Y
    1182:	79 81       	ldd	r23, Y+1	; 0x01
    1184:	8a 81       	ldd	r24, Y+2	; 0x02
    1186:	9b 81       	ldd	r25, Y+3	; 0x03
    1188:	52 db       	rcall	.-2396   	; 0x82e <SwapEndian_32>
    118a:	d6 01       	movw	r26, r12
    118c:	18 96       	adiw	r26, 0x08	; 8
    118e:	6d 93       	st	X+, r22
    1190:	7d 93       	st	X+, r23
    1192:	8d 93       	st	X+, r24
    1194:	9c 93       	st	X, r25
    1196:	1b 97       	sbiw	r26, 0x0b	; 11
		TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));
    1198:	1c 96       	adiw	r26, 0x0c	; 12
    119a:	8c 91       	ld	r24, X
    119c:	1c 97       	sbiw	r26, 0x0c	; 12
    119e:	8f 70       	andi	r24, 0x0F	; 15
    11a0:	80 65       	ori	r24, 0x50	; 80
    11a2:	1c 96       	adiw	r26, 0x0c	; 12
    11a4:	8c 93       	st	X, r24

		if (!(ConnectionInfo->Buffer.InUse))
    11a6:	c4 5f       	subi	r28, 0xF4	; 244
    11a8:	dd 4f       	sbci	r29, 0xFD	; 253
    11aa:	88 81       	ld	r24, Y
    11ac:	cc 50       	subi	r28, 0x0C	; 12
    11ae:	d2 40       	sbci	r29, 0x02	; 2
    11b0:	88 23       	and	r24, r24
    11b2:	09 f4       	brne	.+2      	; 0x11b6 <TCP_ProcessTCPPacket+0x548>
    11b4:	78 cf       	rjmp	.-272    	; 0x10a6 <TCP_ProcessTCPPacket+0x438>
    11b6:	7f cf       	rjmp	.-258    	; 0x10b6 <TCP_ProcessTCPPacket+0x448>

000011b8 <TCP_TCPTask>:
 *  level. If an application produces a response, this task constructs the appropriate Ethernet frame and places it into the Ethernet OUT
 *  buffer for later transmission.
 */
void TCP_TCPTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
		         Ethernet_Frame_Info_t* const FrameOUT)
{
    11b8:	2f 92       	push	r2
    11ba:	3f 92       	push	r3
    11bc:	4f 92       	push	r4
    11be:	5f 92       	push	r5
    11c0:	6f 92       	push	r6
    11c2:	7f 92       	push	r7
    11c4:	8f 92       	push	r8
    11c6:	9f 92       	push	r9
    11c8:	af 92       	push	r10
    11ca:	bf 92       	push	r11
    11cc:	cf 92       	push	r12
    11ce:	df 92       	push	r13
    11d0:	ef 92       	push	r14
    11d2:	ff 92       	push	r15
    11d4:	0f 93       	push	r16
    11d6:	1f 93       	push	r17
    11d8:	df 93       	push	r29
    11da:	cf 93       	push	r28
    11dc:	00 d0       	rcall	.+0      	; 0x11de <TCP_TCPTask+0x26>
    11de:	00 d0       	rcall	.+0      	; 0x11e0 <TCP_TCPTask+0x28>
    11e0:	cd b7       	in	r28, 0x3d	; 61
    11e2:	de b7       	in	r29, 0x3e	; 62
    11e4:	7c 83       	std	Y+4, r23	; 0x04
    11e6:	6b 83       	std	Y+3, r22	; 0x03
    11e8:	55 eb       	ldi	r21, 0xB5	; 181
    11ea:	e5 2e       	mov	r14, r21
    11ec:	5d e0       	ldi	r21, 0x0D	; 13
    11ee:	f5 2e       	mov	r15, r21
    11f0:	00 e0       	ldi	r16, 0x00	; 0
    11f2:	10 e0       	ldi	r17, 0x00	; 0
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
			    (PortStateTable[PTableEntry].State == TCP_Port_Open))
			{
				PortStateTable[PTableEntry].ApplicationHandler(&ConnectionStateTable[CSTableEntry],
    11f4:	46 e1       	ldi	r20, 0x16	; 22
    11f6:	c4 2e       	mov	r12, r20
    11f8:	42 e0       	ldi	r20, 0x02	; 2
    11fa:	d4 2e       	mov	r13, r20
    11fc:	1c c0       	rjmp	.+56     	; 0x1236 <TCP_TCPTask+0x7e>
	{
		/* Find the corresponding port entry in the port table */
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
    11fe:	80 91 f9 13 	lds	r24, 0x13F9
    1202:	81 30       	cpi	r24, 0x01	; 1
    1204:	79 f4       	brne	.+30     	; 0x1224 <TCP_TCPTask+0x6c>
			    (PortStateTable[PTableEntry].State == TCP_Port_Open))
			{
				PortStateTable[PTableEntry].ApplicationHandler(&ConnectionStateTable[CSTableEntry],
    1206:	0c 9d       	mul	r16, r12
    1208:	b0 01       	movw	r22, r0
    120a:	0d 9d       	mul	r16, r13
    120c:	70 0d       	add	r23, r0
    120e:	1c 9d       	mul	r17, r12
    1210:	70 0d       	add	r23, r0
    1212:	11 24       	eor	r1, r1
    1214:	6b 53       	subi	r22, 0x3B	; 59
    1216:	72 4f       	sbci	r23, 0xF2	; 242
    1218:	e0 91 fa 13 	lds	r30, 0x13FA
    121c:	f0 91 fb 13 	lds	r31, 0x13FB
    1220:	c7 01       	movw	r24, r14
    1222:	09 95       	icall
    1224:	0f 5f       	subi	r16, 0xFF	; 255
    1226:	1f 4f       	sbci	r17, 0xFF	; 255
    1228:	26 e1       	ldi	r18, 0x16	; 22
    122a:	32 e0       	ldi	r19, 0x02	; 2
    122c:	e2 0e       	add	r14, r18
    122e:	f3 1e       	adc	r15, r19
 */
void TCP_TCPTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
		         Ethernet_Frame_Info_t* const FrameOUT)
{
	/* Run each application in sequence, to process incoming and generate outgoing packets */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
    1230:	03 30       	cpi	r16, 0x03	; 3
    1232:	11 05       	cpc	r17, r1
    1234:	59 f0       	breq	.+22     	; 0x124c <TCP_TCPTask+0x94>
	{
		/* Find the corresponding port entry in the port table */
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
    1236:	20 91 f7 13 	lds	r18, 0x13F7
    123a:	30 91 f8 13 	lds	r19, 0x13F8
    123e:	d7 01       	movw	r26, r14
    1240:	8d 91       	ld	r24, X+
    1242:	9c 91       	ld	r25, X
    1244:	28 17       	cp	r18, r24
    1246:	39 07       	cpc	r19, r25
    1248:	69 f7       	brne	.-38     	; 0x1224 <TCP_TCPTask+0x6c>
    124a:	d9 cf       	rjmp	.-78     	; 0x11fe <TCP_TCPTask+0x46>
			}
		}
	}

	/* Bail out early if there is already a frame waiting to be sent in the Ethernet OUT buffer */
	if (FrameOUT->FrameLength)
    124c:	eb 81       	ldd	r30, Y+3	; 0x03
    124e:	fc 81       	ldd	r31, Y+4	; 0x04
    1250:	e4 52       	subi	r30, 0x24	; 36
    1252:	fa 4f       	sbci	r31, 0xFA	; 250
    1254:	80 81       	ld	r24, Z
    1256:	91 81       	ldd	r25, Z+1	; 0x01
    1258:	ec 5d       	subi	r30, 0xDC	; 220
    125a:	f5 40       	sbci	r31, 0x05	; 5
    125c:	fc 83       	std	Y+4, r31	; 0x04
    125e:	eb 83       	std	Y+3, r30	; 0x03
    1260:	89 2b       	or	r24, r25
    1262:	09 f0       	breq	.+2      	; 0x1266 <TCP_TCPTask+0xae>
    1264:	22 c1       	rjmp	.+580    	; 0x14aa <TCP_TCPTask+0x2f2>

	/* Send response packets from each application as the TCP packet buffers are filled by the applications */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* For each completely received packet, pass it along to the listening application */
		if ((ConnectionStateTable[CSTableEntry].Info.Buffer.Direction == TCP_PACKETDIR_OUT) &&
    1266:	80 91 c7 0f 	lds	r24, 0x0FC7
    126a:	88 23       	and	r24, r24
    126c:	39 f0       	breq	.+14     	; 0x127c <TCP_TCPTask+0xc4>
    126e:	80 91 c8 0f 	lds	r24, 0x0FC8
    1272:	88 23       	and	r24, r24
    1274:	19 f0       	breq	.+6      	; 0x127c <TCP_TCPTask+0xc4>
    1276:	1a 82       	std	Y+2, r1	; 0x02
    1278:	19 82       	std	Y+1, r1	; 0x01
    127a:	1b c0       	rjmp	.+54     	; 0x12b2 <TCP_TCPTask+0xfa>
    127c:	80 91 dd 11 	lds	r24, 0x11DD
    1280:	88 23       	and	r24, r24
    1282:	49 f0       	breq	.+18     	; 0x1296 <TCP_TCPTask+0xde>
    1284:	80 91 de 11 	lds	r24, 0x11DE
    1288:	88 23       	and	r24, r24
    128a:	29 f0       	breq	.+10     	; 0x1296 <TCP_TCPTask+0xde>
    128c:	21 e0       	ldi	r18, 0x01	; 1
    128e:	30 e0       	ldi	r19, 0x00	; 0
    1290:	3a 83       	std	Y+2, r19	; 0x02
    1292:	29 83       	std	Y+1, r18	; 0x01
    1294:	0e c0       	rjmp	.+28     	; 0x12b2 <TCP_TCPTask+0xfa>
    1296:	80 91 f3 13 	lds	r24, 0x13F3
    129a:	88 23       	and	r24, r24
    129c:	09 f4       	brne	.+2      	; 0x12a0 <TCP_TCPTask+0xe8>
    129e:	05 c1       	rjmp	.+522    	; 0x14aa <TCP_TCPTask+0x2f2>
    12a0:	80 91 f4 13 	lds	r24, 0x13F4
    12a4:	88 23       	and	r24, r24
    12a6:	09 f4       	brne	.+2      	; 0x12aa <TCP_TCPTask+0xf2>
    12a8:	00 c1       	rjmp	.+512    	; 0x14aa <TCP_TCPTask+0x2f2>
    12aa:	82 e0       	ldi	r24, 0x02	; 2
    12ac:	90 e0       	ldi	r25, 0x00	; 0
    12ae:	9a 83       	std	Y+2, r25	; 0x02
    12b0:	89 83       	std	Y+1, r24	; 0x01
		    (ConnectionStateTable[CSTableEntry].Info.Buffer.Ready))
		{
			Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT->FrameData;
			IP_Header_t*             IPHeaderOUT    = (IP_Header_t*)&FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t)];
    12b2:	3e e0       	ldi	r19, 0x0E	; 14
    12b4:	a3 2e       	mov	r10, r19
    12b6:	b1 2c       	mov	r11, r1
    12b8:	ab 81       	ldd	r26, Y+3	; 0x03
    12ba:	bc 81       	ldd	r27, Y+4	; 0x04
    12bc:	aa 0e       	add	r10, r26
    12be:	bb 1e       	adc	r11, r27
			TCP_Header_t*            TCPHeaderOUT   = (TCP_Header_t*)&FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t) +
			                                                                              sizeof(IP_Header_t)];
    12c0:	22 e2       	ldi	r18, 0x22	; 34
    12c2:	c2 2e       	mov	r12, r18
    12c4:	d1 2c       	mov	r13, r1
    12c6:	ca 0e       	add	r12, r26
    12c8:	db 1e       	adc	r13, r27
			void*                    TCPDataOUT     = &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t) +
			                                                               sizeof(IP_Header_t) +
			                                                               sizeof(TCP_Header_t)];

			uint16_t PacketSize = ConnectionStateTable[CSTableEntry].Info.Buffer.Length;
    12ca:	86 e1       	ldi	r24, 0x16	; 22
    12cc:	92 e0       	ldi	r25, 0x02	; 2
    12ce:	e9 81       	ldd	r30, Y+1	; 0x01
    12d0:	fa 81       	ldd	r31, Y+2	; 0x02
    12d2:	e8 9f       	mul	r30, r24
    12d4:	80 01       	movw	r16, r0
    12d6:	e9 9f       	mul	r30, r25
    12d8:	10 0d       	add	r17, r0
    12da:	f8 9f       	mul	r31, r24
    12dc:	10 0d       	add	r17, r0
    12de:	11 24       	eor	r1, r1
    12e0:	95 eb       	ldi	r25, 0xB5	; 181
    12e2:	69 2e       	mov	r6, r25
    12e4:	9d e0       	ldi	r25, 0x0D	; 13
    12e6:	79 2e       	mov	r7, r25
    12e8:	60 0e       	add	r6, r16
    12ea:	71 1e       	adc	r7, r17
    12ec:	d3 01       	movw	r26, r6
    12ee:	50 96       	adiw	r26, 0x10	; 16
    12f0:	8d 90       	ld	r8, X+
    12f2:	9c 90       	ld	r9, X
    12f4:	51 97       	sbiw	r26, 0x11	; 17

			/* Fill out the TCP data */
			TCPHeaderOUT->SourcePort           = ConnectionStateTable[CSTableEntry].Port;
    12f6:	8d 91       	ld	r24, X+
    12f8:	9c 91       	ld	r25, X
    12fa:	eb 81       	ldd	r30, Y+3	; 0x03
    12fc:	fc 81       	ldd	r31, Y+4	; 0x04
    12fe:	93 a3       	std	Z+35, r25	; 0x23
    1300:	82 a3       	std	Z+34, r24	; 0x22
			TCPHeaderOUT->DestinationPort      = ConnectionStateTable[CSTableEntry].RemotePort;
    1302:	8b e0       	ldi	r24, 0x0B	; 11
    1304:	91 e0       	ldi	r25, 0x01	; 1
    1306:	29 81       	ldd	r18, Y+1	; 0x01
    1308:	3a 81       	ldd	r19, Y+2	; 0x02
    130a:	28 9f       	mul	r18, r24
    130c:	f0 01       	movw	r30, r0
    130e:	29 9f       	mul	r18, r25
    1310:	f0 0d       	add	r31, r0
    1312:	38 9f       	mul	r19, r24
    1314:	f0 0d       	add	r31, r0
    1316:	11 24       	eor	r1, r1
    1318:	ee 0f       	add	r30, r30
    131a:	ff 1f       	adc	r31, r31
    131c:	e9 54       	subi	r30, 0x49	; 73
    131e:	f2 4f       	sbci	r31, 0xF2	; 242
    1320:	80 81       	ld	r24, Z
    1322:	91 81       	ldd	r25, Z+1	; 0x01
    1324:	d6 01       	movw	r26, r12
    1326:	13 96       	adiw	r26, 0x03	; 3
    1328:	9c 93       	st	X, r25
    132a:	8e 93       	st	-X, r24
    132c:	12 97       	sbiw	r26, 0x02	; 2
			TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut);
    132e:	f3 01       	movw	r30, r6
    1330:	64 85       	ldd	r22, Z+12	; 0x0c
    1332:	75 85       	ldd	r23, Z+13	; 0x0d
    1334:	86 85       	ldd	r24, Z+14	; 0x0e
    1336:	97 85       	ldd	r25, Z+15	; 0x0f
    1338:	7a da       	rcall	.-2828   	; 0x82e <SwapEndian_32>
    133a:	d6 01       	movw	r26, r12
    133c:	14 96       	adiw	r26, 0x04	; 4
    133e:	6d 93       	st	X+, r22
    1340:	7d 93       	st	X+, r23
    1342:	8d 93       	st	X+, r24
    1344:	9c 93       	st	X, r25
    1346:	17 97       	sbiw	r26, 0x07	; 7
			TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.SequenceNumberIn);
    1348:	f3 01       	movw	r30, r6
    134a:	60 85       	ldd	r22, Z+8	; 0x08
    134c:	71 85       	ldd	r23, Z+9	; 0x09
    134e:	82 85       	ldd	r24, Z+10	; 0x0a
    1350:	93 85       	ldd	r25, Z+11	; 0x0b
    1352:	6d da       	rcall	.-2854   	; 0x82e <SwapEndian_32>
    1354:	d6 01       	movw	r26, r12
    1356:	18 96       	adiw	r26, 0x08	; 8
    1358:	6d 93       	st	X+, r22
    135a:	7d 93       	st	X+, r23
    135c:	8d 93       	st	X+, r24
    135e:	9c 93       	st	X, r25
    1360:	1b 97       	sbiw	r26, 0x0b	; 11
			TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));
			TCPHeaderOUT->WindowSize           = SwapEndian_16(TCP_WINDOW_SIZE);
    1362:	82 e0       	ldi	r24, 0x02	; 2
    1364:	90 e0       	ldi	r25, 0x00	; 0
    1366:	1f 96       	adiw	r26, 0x0f	; 15
    1368:	9c 93       	st	X, r25
    136a:	8e 93       	st	-X, r24
    136c:	1e 97       	sbiw	r26, 0x0e	; 14

			TCPHeaderOUT->Flags                = TCP_FLAG_ACK;
    136e:	80 e1       	ldi	r24, 0x10	; 16
    1370:	1d 96       	adiw	r26, 0x0d	; 13
    1372:	8c 93       	st	X, r24
    1374:	1d 97       	sbiw	r26, 0x0d	; 13
			TCPHeaderOUT->UrgentPointer        = 0;
    1376:	53 96       	adiw	r26, 0x13	; 19
    1378:	1c 92       	st	X, r1
    137a:	1e 92       	st	-X, r1
    137c:	52 97       	sbiw	r26, 0x12	; 18
			TCPHeaderOUT->Checksum             = 0;
    137e:	51 96       	adiw	r26, 0x11	; 17
    1380:	1c 92       	st	X, r1
    1382:	1e 92       	st	-X, r1
    1384:	50 97       	sbiw	r26, 0x10	; 16
			TCPHeaderOUT->Reserved             = 0;
    1386:	80 e5       	ldi	r24, 0x50	; 80
    1388:	1c 96       	adiw	r26, 0x0c	; 12
    138a:	8c 93       	st	X, r24

			memcpy(TCPDataOUT, ConnectionStateTable[CSTableEntry].Info.Buffer.Data, PacketSize);
    138c:	2b 81       	ldd	r18, Y+3	; 0x03
    138e:	3c 81       	ldd	r19, Y+4	; 0x04
    1390:	2a 5c       	subi	r18, 0xCA	; 202
    1392:	3f 4f       	sbci	r19, 0xFF	; 255
    1394:	09 53       	subi	r16, 0x39	; 57
    1396:	12 4f       	sbci	r17, 0xF2	; 242
    1398:	c9 01       	movw	r24, r18
    139a:	b8 01       	movw	r22, r16
    139c:	a4 01       	movw	r20, r8
    139e:	0e 94 fd 16 	call	0x2dfa	; 0x2dfa <memcpy>

			ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut += PacketSize;
    13a2:	c4 01       	movw	r24, r8
    13a4:	a0 e0       	ldi	r26, 0x00	; 0
    13a6:	b0 e0       	ldi	r27, 0x00	; 0
    13a8:	f3 01       	movw	r30, r6
    13aa:	24 85       	ldd	r18, Z+12	; 0x0c
    13ac:	35 85       	ldd	r19, Z+13	; 0x0d
    13ae:	46 85       	ldd	r20, Z+14	; 0x0e
    13b0:	57 85       	ldd	r21, Z+15	; 0x0f
    13b2:	82 0f       	add	r24, r18
    13b4:	93 1f       	adc	r25, r19
    13b6:	a4 1f       	adc	r26, r20
    13b8:	b5 1f       	adc	r27, r21
    13ba:	84 87       	std	Z+12, r24	; 0x0c
    13bc:	95 87       	std	Z+13, r25	; 0x0d
    13be:	a6 87       	std	Z+14, r26	; 0x0e
    13c0:	b7 87       	std	Z+15, r27	; 0x0f

			TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, ServerIPAddress,
    13c2:	24 e1       	ldi	r18, 0x14	; 20
    13c4:	30 e0       	ldi	r19, 0x00	; 0
    13c6:	82 0e       	add	r8, r18
    13c8:	93 1e       	adc	r9, r19
    13ca:	20 90 b9 01 	lds	r2, 0x01B9
    13ce:	30 90 ba 01 	lds	r3, 0x01BA
    13d2:	40 90 bb 01 	lds	r4, 0x01BB
    13d6:	50 90 bc 01 	lds	r5, 0x01BC
    13da:	04 81       	ldd	r16, Z+4	; 0x04
    13dc:	15 81       	ldd	r17, Z+5	; 0x05
    13de:	26 81       	ldd	r18, Z+6	; 0x06
    13e0:	37 81       	ldd	r19, Z+7	; 0x07
    13e2:	c6 01       	movw	r24, r12
    13e4:	b2 01       	movw	r22, r4
    13e6:	a1 01       	movw	r20, r2
    13e8:	74 01       	movw	r14, r8
    13ea:	27 da       	rcall	.-2994   	; 0x83a <TCP_Checksum16>
    13ec:	d6 01       	movw	r26, r12
    13ee:	51 96       	adiw	r26, 0x11	; 17
    13f0:	9c 93       	st	X, r25
    13f2:	8e 93       	st	-X, r24
    13f4:	50 97       	sbiw	r26, 0x10	; 16
			                                                    (sizeof(TCP_Header_t) + PacketSize));

			PacketSize += sizeof(TCP_Header_t);

			/* Fill out the response IP header */
			IPHeaderOUT->TotalLength        = SwapEndian_16(sizeof(IP_Header_t) + PacketSize);
    13f6:	84 01       	movw	r16, r8
    13f8:	0c 5e       	subi	r16, 0xEC	; 236
    13fa:	1f 4f       	sbci	r17, 0xFF	; 255
    13fc:	f5 01       	movw	r30, r10
    13fe:	12 83       	std	Z+2, r17	; 0x02
    1400:	03 83       	std	Z+3, r16	; 0x03
			IPHeaderOUT->TypeOfService      = 0;
    1402:	11 82       	std	Z+1, r1	; 0x01
			IPHeaderOUT->HeaderLength       = (sizeof(IP_Header_t) / sizeof(uint32_t));
			IPHeaderOUT->Version            = 4;
    1404:	85 e4       	ldi	r24, 0x45	; 69
    1406:	ab 81       	ldd	r26, Y+3	; 0x03
    1408:	bc 81       	ldd	r27, Y+4	; 0x04
    140a:	1e 96       	adiw	r26, 0x0e	; 14
    140c:	8c 93       	st	X, r24
			IPHeaderOUT->Flags              = 0;
			IPHeaderOUT->FragmentOffset     = 0;
    140e:	16 82       	std	Z+6, r1	; 0x06
    1410:	17 82       	std	Z+7, r1	; 0x07
			IPHeaderOUT->Identification     = 0;
    1412:	15 82       	std	Z+5, r1	; 0x05
    1414:	14 82       	std	Z+4, r1	; 0x04
			IPHeaderOUT->HeaderChecksum     = 0;
    1416:	13 86       	std	Z+11, r1	; 0x0b
    1418:	12 86       	std	Z+10, r1	; 0x0a
			IPHeaderOUT->Protocol           = PROTOCOL_TCP;
    141a:	86 e0       	ldi	r24, 0x06	; 6
    141c:	81 87       	std	Z+9, r24	; 0x09
			IPHeaderOUT->TTL                = DEFAULT_TTL;
    141e:	80 e8       	ldi	r24, 0x80	; 128
    1420:	80 87       	std	Z+8, r24	; 0x08
			IPHeaderOUT->SourceAddress      = ServerIPAddress;
    1422:	24 86       	std	Z+12, r2	; 0x0c
    1424:	35 86       	std	Z+13, r3	; 0x0d
    1426:	46 86       	std	Z+14, r4	; 0x0e
    1428:	57 86       	std	Z+15, r5	; 0x0f
			IPHeaderOUT->DestinationAddress = ConnectionStateTable[CSTableEntry].RemoteAddress;
    142a:	f3 01       	movw	r30, r6
    142c:	84 81       	ldd	r24, Z+4	; 0x04
    142e:	95 81       	ldd	r25, Z+5	; 0x05
    1430:	a6 81       	ldd	r26, Z+6	; 0x06
    1432:	b7 81       	ldd	r27, Z+7	; 0x07
    1434:	f5 01       	movw	r30, r10
    1436:	80 8b       	std	Z+16, r24	; 0x10
    1438:	91 8b       	std	Z+17, r25	; 0x11
    143a:	a2 8b       	std	Z+18, r26	; 0x12
    143c:	b3 8b       	std	Z+19, r27	; 0x13

			IPHeaderOUT->HeaderChecksum     = Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));
    143e:	c5 01       	movw	r24, r10
    1440:	64 e1       	ldi	r22, 0x14	; 20
    1442:	70 e0       	ldi	r23, 0x00	; 0
    1444:	c8 d8       	rcall	.-3696   	; 0x5d6 <Ethernet_Checksum16>
    1446:	d5 01       	movw	r26, r10
    1448:	1b 96       	adiw	r26, 0x0b	; 11
    144a:	9c 93       	st	X, r25
    144c:	8e 93       	st	-X, r24
    144e:	1a 97       	sbiw	r26, 0x0a	; 10

			PacketSize += sizeof(IP_Header_t);

			/* Fill out the response Ethernet frame header */
			FrameOUTHeader->Source          = ServerMACAddress;
    1450:	ab 81       	ldd	r26, Y+3	; 0x03
    1452:	bc 81       	ldd	r27, Y+4	; 0x04
    1454:	16 96       	adiw	r26, 0x06	; 6
    1456:	e3 eb       	ldi	r30, 0xB3	; 179
    1458:	f1 e0       	ldi	r31, 0x01	; 1
    145a:	86 e0       	ldi	r24, 0x06	; 6
    145c:	01 90       	ld	r0, Z+
    145e:	0d 92       	st	X+, r0
    1460:	81 50       	subi	r24, 0x01	; 1
    1462:	e1 f7       	brne	.-8      	; 0x145c <TCP_TCPTask+0x2a4>
			FrameOUTHeader->Destination     = (MAC_Address_t){{0x02, 0x00, 0x02, 0x00, 0x02, 0x00}};
    1464:	ab 81       	ldd	r26, Y+3	; 0x03
    1466:	bc 81       	ldd	r27, Y+4	; 0x04
    1468:	eb ec       	ldi	r30, 0xCB	; 203
    146a:	f1 e0       	ldi	r31, 0x01	; 1
    146c:	86 e0       	ldi	r24, 0x06	; 6
    146e:	01 90       	ld	r0, Z+
    1470:	0d 92       	st	X+, r0
    1472:	81 50       	subi	r24, 0x01	; 1
    1474:	e1 f7       	brne	.-8      	; 0x146e <TCP_TCPTask+0x2b6>
			FrameOUTHeader->EtherType       = SwapEndian_16(ETHERTYPE_IPV4);
    1476:	88 e0       	ldi	r24, 0x08	; 8
    1478:	90 e0       	ldi	r25, 0x00	; 0
    147a:	eb 81       	ldd	r30, Y+3	; 0x03
    147c:	fc 81       	ldd	r31, Y+4	; 0x04
    147e:	95 87       	std	Z+13, r25	; 0x0d
    1480:	84 87       	std	Z+12, r24	; 0x0c

			PacketSize += sizeof(Ethernet_Frame_Header_t);

			/* Set the response length in the buffer and indicate that a response is ready to be sent */
			FrameOUT->FrameLength           = PacketSize;
    1482:	e4 52       	subi	r30, 0x24	; 36
    1484:	fa 4f       	sbci	r31, 0xFA	; 250
    1486:	02 5f       	subi	r16, 0xF2	; 242
    1488:	1f 4f       	sbci	r17, 0xFF	; 255
    148a:	11 83       	std	Z+1, r17	; 0x01
    148c:	00 83       	st	Z, r16

			ConnectionStateTable[CSTableEntry].Info.Buffer.Ready = false;
    148e:	86 e1       	ldi	r24, 0x16	; 22
    1490:	92 e0       	ldi	r25, 0x02	; 2
    1492:	29 81       	ldd	r18, Y+1	; 0x01
    1494:	3a 81       	ldd	r19, Y+2	; 0x02
    1496:	28 9f       	mul	r18, r24
    1498:	f0 01       	movw	r30, r0
    149a:	29 9f       	mul	r18, r25
    149c:	f0 0d       	add	r31, r0
    149e:	38 9f       	mul	r19, r24
    14a0:	f0 0d       	add	r31, r0
    14a2:	11 24       	eor	r1, r1
    14a4:	e8 53       	subi	r30, 0x38	; 56
    14a6:	f0 4f       	sbci	r31, 0xF0	; 240
    14a8:	10 82       	st	Z, r1

			break;
		}
	}
}
    14aa:	0f 90       	pop	r0
    14ac:	0f 90       	pop	r0
    14ae:	0f 90       	pop	r0
    14b0:	0f 90       	pop	r0
    14b2:	cf 91       	pop	r28
    14b4:	df 91       	pop	r29
    14b6:	1f 91       	pop	r17
    14b8:	0f 91       	pop	r16
    14ba:	ff 90       	pop	r15
    14bc:	ef 90       	pop	r14
    14be:	df 90       	pop	r13
    14c0:	cf 90       	pop	r12
    14c2:	bf 90       	pop	r11
    14c4:	af 90       	pop	r10
    14c6:	9f 90       	pop	r9
    14c8:	8f 90       	pop	r8
    14ca:	7f 90       	pop	r7
    14cc:	6f 90       	pop	r6
    14ce:	5f 90       	pop	r5
    14d0:	4f 90       	pop	r4
    14d2:	3f 90       	pop	r3
    14d4:	2f 90       	pop	r2
    14d6:	08 95       	ret

000014d8 <UDP_ProcessUDPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t UDP_ProcessUDPPacket(void* IPHeaderInStart,
                             void* UDPHeaderInStart,
                             void* UDPHeaderOutStart)
{
    14d8:	ef 92       	push	r14
    14da:	ff 92       	push	r15
    14dc:	0f 93       	push	r16
    14de:	1f 93       	push	r17
    14e0:	cf 93       	push	r28
    14e2:	df 93       	push	r29
    14e4:	7c 01       	movw	r14, r24
    14e6:	eb 01       	movw	r28, r22
    14e8:	8a 01       	movw	r16, r20
	UDP_Header_t* UDPHeaderIN  = (UDP_Header_t*)UDPHeaderInStart;
	UDP_Header_t* UDPHeaderOUT = (UDP_Header_t*)UDPHeaderOutStart;

	int16_t RetSize = NO_RESPONSE;

	DecodeUDPHeader(UDPHeaderInStart);
    14ea:	cb 01       	movw	r24, r22
    14ec:	1e d9       	rcall	.-3524   	; 0x72a <DecodeUDPHeader>
    14ee:	8a 81       	ldd	r24, Y+2	; 0x02
    14f0:	9b 81       	ldd	r25, Y+3	; 0x03

				Temp = Data.Bytes[0];
    14f2:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[1];
    14f4:	89 2f       	mov	r24, r25
				Data.Bytes[1] = Temp;
    14f6:	92 2f       	mov	r25, r18

	switch (SwapEndian_16(UDPHeaderIN->DestinationPort))
    14f8:	83 34       	cpi	r24, 0x43	; 67
    14fa:	91 05       	cpc	r25, r1
    14fc:	e9 f4       	brne	.+58     	; 0x1538 <UDP_ProcessUDPPacket+0x60>
	{
		case UDP_PORT_DHCP_REQUEST:
			RetSize = DHCP_ProcessDHCPPacket(IPHeaderInStart,
    14fe:	be 01       	movw	r22, r28
    1500:	68 5f       	subi	r22, 0xF8	; 248
    1502:	7f 4f       	sbci	r23, 0xFF	; 255
    1504:	a8 01       	movw	r20, r16
    1506:	48 5f       	subi	r20, 0xF8	; 248
    1508:	5f 4f       	sbci	r21, 0xFF	; 255
    150a:	c7 01       	movw	r24, r14
    150c:	1f d0       	rcall	.+62     	; 0x154c <DHCP_ProcessDHCPPacket>
    150e:	9c 01       	movw	r18, r24
		                                     &((uint8_t*)UDPHeaderOutStart)[sizeof(UDP_Header_t)]);
			break;
	}

	/* Check to see if the protocol processing routine has filled out a response */
	if (RetSize > 0)
    1510:	18 16       	cp	r1, r24
    1512:	19 06       	cpc	r1, r25
    1514:	8c f4       	brge	.+34     	; 0x1538 <UDP_ProcessUDPPacket+0x60>
	{
		/* Fill out the response UDP packet header */
		UDPHeaderOUT->SourcePort      = UDPHeaderIN->DestinationPort;
    1516:	8a 81       	ldd	r24, Y+2	; 0x02
    1518:	9b 81       	ldd	r25, Y+3	; 0x03
    151a:	f8 01       	movw	r30, r16
    151c:	91 83       	std	Z+1, r25	; 0x01
    151e:	80 83       	st	Z, r24
		UDPHeaderOUT->DestinationPort = UDPHeaderIN->SourcePort;
    1520:	88 81       	ld	r24, Y
    1522:	99 81       	ldd	r25, Y+1	; 0x01
    1524:	93 83       	std	Z+3, r25	; 0x03
    1526:	82 83       	std	Z+2, r24	; 0x02
		UDPHeaderOUT->Checksum        = 0;
    1528:	17 82       	std	Z+7, r1	; 0x07
    152a:	16 82       	std	Z+6, r1	; 0x06
		UDPHeaderOUT->Length          = SwapEndian_16(sizeof(UDP_Header_t) + RetSize);
    152c:	c9 01       	movw	r24, r18
    152e:	08 96       	adiw	r24, 0x08	; 8
    1530:	94 83       	std	Z+4, r25	; 0x04
    1532:	85 83       	std	Z+5, r24	; 0x05

		/* Return the size of the response so far */
		return (sizeof(UDP_Header_t) + RetSize);
    1534:	9c 01       	movw	r18, r24
    1536:	02 c0       	rjmp	.+4      	; 0x153c <UDP_ProcessUDPPacket+0x64>
    1538:	20 e0       	ldi	r18, 0x00	; 0
    153a:	30 e0       	ldi	r19, 0x00	; 0
	}

	return NO_RESPONSE;
}
    153c:	c9 01       	movw	r24, r18
    153e:	df 91       	pop	r29
    1540:	cf 91       	pop	r28
    1542:	1f 91       	pop	r17
    1544:	0f 91       	pop	r16
    1546:	ff 90       	pop	r15
    1548:	ef 90       	pop	r14
    154a:	08 95       	ret

0000154c <DHCP_ProcessDHCPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t DHCP_ProcessDHCPPacket(void* IPHeaderInStart,
                               void* DHCPHeaderInStart,
                               void* DHCPHeaderOutStart)
{
    154c:	8f 92       	push	r8
    154e:	9f 92       	push	r9
    1550:	af 92       	push	r10
    1552:	bf 92       	push	r11
    1554:	cf 92       	push	r12
    1556:	df 92       	push	r13
    1558:	ef 92       	push	r14
    155a:	ff 92       	push	r15
    155c:	0f 93       	push	r16
    155e:	1f 93       	push	r17
    1560:	cf 93       	push	r28
    1562:	df 93       	push	r29
    1564:	8b 01       	movw	r16, r22
    1566:	ea 01       	movw	r28, r20
	IP_Header_t*   IPHeaderIN    = (IP_Header_t*)IPHeaderInStart;
    1568:	5c 01       	movw	r10, r24
	DHCP_Header_t* DHCPHeaderIN  = (DHCP_Header_t*)DHCPHeaderInStart;
	DHCP_Header_t* DHCPHeaderOUT = (DHCP_Header_t*)DHCPHeaderOutStart;

	uint8_t* DHCPOptionsINStart  = (uint8_t*)(DHCPHeaderInStart  + sizeof(DHCP_Header_t));
    156a:	80 ef       	ldi	r24, 0xF0	; 240
    156c:	88 2e       	mov	r8, r24
    156e:	91 2c       	mov	r9, r1
    1570:	86 0e       	add	r8, r22
    1572:	97 1e       	adc	r9, r23
	uint8_t* DHCPOptionsOUTStart = (uint8_t*)(DHCPHeaderOutStart + sizeof(DHCP_Header_t));

	DecodeDHCPHeader(DHCPHeaderInStart);
    1574:	cb 01       	movw	r24, r22
    1576:	da d8       	rcall	.-3660   	; 0x72c <DecodeDHCPHeader>

	/* Zero out the response DHCP packet, as much of it is legacy and left at 0 */
	memset(DHCPHeaderOUT, 0, sizeof(DHCP_Header_t));
    1578:	80 ef       	ldi	r24, 0xF0	; 240
    157a:	fe 01       	movw	r30, r28
    157c:	11 92       	st	Z+, r1
    157e:	8a 95       	dec	r24
    1580:	e9 f7       	brne	.-6      	; 0x157c <DHCP_ProcessDHCPPacket+0x30>

	/* Fill out the response DHCP packet */
	DHCPHeaderOUT->HardwareType          = DHCPHeaderIN->HardwareType;
    1582:	f8 01       	movw	r30, r16
    1584:	81 81       	ldd	r24, Z+1	; 0x01
    1586:	89 83       	std	Y+1, r24	; 0x01
	DHCPHeaderOUT->Operation             = DHCP_OP_BOOTREPLY;
    1588:	82 e0       	ldi	r24, 0x02	; 2
    158a:	88 83       	st	Y, r24
	DHCPHeaderOUT->HardwareAddressLength = DHCPHeaderIN->HardwareAddressLength;
    158c:	82 81       	ldd	r24, Z+2	; 0x02
    158e:	8a 83       	std	Y+2, r24	; 0x02
	DHCPHeaderOUT->Hops                  = 0;
    1590:	1b 82       	std	Y+3, r1	; 0x03
	DHCPHeaderOUT->TransactionID         = DHCPHeaderIN->TransactionID;
    1592:	84 81       	ldd	r24, Z+4	; 0x04
    1594:	95 81       	ldd	r25, Z+5	; 0x05
    1596:	a6 81       	ldd	r26, Z+6	; 0x06
    1598:	b7 81       	ldd	r27, Z+7	; 0x07
    159a:	8c 83       	std	Y+4, r24	; 0x04
    159c:	9d 83       	std	Y+5, r25	; 0x05
    159e:	ae 83       	std	Y+6, r26	; 0x06
    15a0:	bf 83       	std	Y+7, r27	; 0x07
	DHCPHeaderOUT->ElapsedSeconds        = 0;
    15a2:	19 86       	std	Y+9, r1	; 0x09
    15a4:	18 86       	std	Y+8, r1	; 0x08
	DHCPHeaderOUT->Flags                 = DHCPHeaderIN->Flags;
    15a6:	82 85       	ldd	r24, Z+10	; 0x0a
    15a8:	93 85       	ldd	r25, Z+11	; 0x0b
    15aa:	9b 87       	std	Y+11, r25	; 0x0b
    15ac:	8a 87       	std	Y+10, r24	; 0x0a
	DHCPHeaderOUT->YourIP                = ClientIPAddress;
    15ae:	c0 90 c7 01 	lds	r12, 0x01C7
    15b2:	d0 90 c8 01 	lds	r13, 0x01C8
    15b6:	e0 90 c9 01 	lds	r14, 0x01C9
    15ba:	f0 90 ca 01 	lds	r15, 0x01CA
    15be:	c8 8a       	std	Y+16, r12	; 0x10
    15c0:	d9 8a       	std	Y+17, r13	; 0x11
    15c2:	ea 8a       	std	Y+18, r14	; 0x12
    15c4:	fb 8a       	std	Y+19, r15	; 0x13
	memmove(&DHCPHeaderOUT->ClientHardwareAddress, &DHCPHeaderIN->ClientHardwareAddress, sizeof(MAC_Address_t));
    15c6:	04 5e       	subi	r16, 0xE4	; 228
    15c8:	1f 4f       	sbci	r17, 0xFF	; 255
    15ca:	ce 01       	movw	r24, r28
    15cc:	4c 96       	adiw	r24, 0x1c	; 28
    15ce:	b8 01       	movw	r22, r16
    15d0:	46 e0       	ldi	r20, 0x06	; 6
    15d2:	50 e0       	ldi	r21, 0x00	; 0
    15d4:	0e 94 06 17 	call	0x2e0c	; 0x2e0c <memmove>
	DHCPHeaderOUT->Cookie                = SwapEndian_32(DHCP_MAGIC_COOKIE);
    15d8:	c4 51       	subi	r28, 0x14	; 20
    15da:	df 4f       	sbci	r29, 0xFF	; 255
    15dc:	83 e6       	ldi	r24, 0x63	; 99
    15de:	92 e8       	ldi	r25, 0x82	; 130
    15e0:	a3 e5       	ldi	r26, 0x53	; 83
    15e2:	b3 e6       	ldi	r27, 0x63	; 99
    15e4:	88 83       	st	Y, r24
    15e6:	99 83       	std	Y+1, r25	; 0x01
    15e8:	aa 83       	std	Y+2, r26	; 0x02
    15ea:	bb 83       	std	Y+3, r27	; 0x03
    15ec:	cc 5e       	subi	r28, 0xEC	; 236
    15ee:	d0 40       	sbci	r29, 0x00	; 0

	/* Alter the incoming IP packet header so that the corrected IP source and destinations are used - this means that
	   when the response IP header is generated, it will use the corrected addresses and not the null/broatcast addresses */
	IPHeaderIN->SourceAddress      = ClientIPAddress;
    15f0:	f5 01       	movw	r30, r10
    15f2:	c4 86       	std	Z+12, r12	; 0x0c
    15f4:	d5 86       	std	Z+13, r13	; 0x0d
    15f6:	e6 86       	std	Z+14, r14	; 0x0e
    15f8:	f7 86       	std	Z+15, r15	; 0x0f
	IPHeaderIN->DestinationAddress = ServerIPAddress;
    15fa:	80 91 b9 01 	lds	r24, 0x01B9
    15fe:	90 91 ba 01 	lds	r25, 0x01BA
    1602:	a0 91 bb 01 	lds	r26, 0x01BB
    1606:	b0 91 bc 01 	lds	r27, 0x01BC
    160a:	80 8b       	std	Z+16, r24	; 0x10
    160c:	91 8b       	std	Z+17, r25	; 0x11
    160e:	a2 8b       	std	Z+18, r26	; 0x12
    1610:	b3 8b       	std	Z+19, r27	; 0x13
    1612:	5b c0       	rjmp	.+182    	; 0x16ca <DHCP_ProcessDHCPPacket+0x17e>

	/* Process the incoming DHCP packet options */
	while (DHCPOptionsINStart[0] != DHCP_OPTION_END)
	{
		/* Find the Message Type DHCP option, to determine the type of DHCP packet */
		if (DHCPOptionsINStart[0] == DHCP_OPTION_MESSAGETYPE)
    1614:	85 33       	cpi	r24, 0x35	; 53
    1616:	09 f0       	breq	.+2      	; 0x161a <DHCP_ProcessDHCPPacket+0xce>
    1618:	4d c0       	rjmp	.+154    	; 0x16b4 <DHCP_ProcessDHCPPacket+0x168>
		{
			if ((DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) || (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_REQUEST))
    161a:	94 01       	movw	r18, r8
    161c:	2e 5f       	subi	r18, 0xFE	; 254
    161e:	3f 4f       	sbci	r19, 0xFF	; 255
    1620:	f4 01       	movw	r30, r8
    1622:	82 81       	ldd	r24, Z+2	; 0x02
    1624:	81 30       	cpi	r24, 0x01	; 1
    1626:	19 f0       	breq	.+6      	; 0x162e <DHCP_ProcessDHCPPacket+0xe2>
    1628:	83 30       	cpi	r24, 0x03	; 3
    162a:	09 f0       	breq	.+2      	; 0x162e <DHCP_ProcessDHCPPacket+0xe2>
    162c:	48 c0       	rjmp	.+144    	; 0x16be <DHCP_ProcessDHCPPacket+0x172>
	IP_Header_t*   IPHeaderIN    = (IP_Header_t*)IPHeaderInStart;
	DHCP_Header_t* DHCPHeaderIN  = (DHCP_Header_t*)DHCPHeaderInStart;
	DHCP_Header_t* DHCPHeaderOUT = (DHCP_Header_t*)DHCPHeaderOutStart;

	uint8_t* DHCPOptionsINStart  = (uint8_t*)(DHCPHeaderInStart  + sizeof(DHCP_Header_t));
	uint8_t* DHCPOptionsOUTStart = (uint8_t*)(DHCPHeaderOutStart + sizeof(DHCP_Header_t));
    162e:	fe 01       	movw	r30, r28
    1630:	e0 51       	subi	r30, 0x10	; 16
    1632:	ff 4f       	sbci	r31, 0xFF	; 255
		{
			if ((DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) || (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_REQUEST))
			{
				/* Fill out the response DHCP packet options for a DHCP OFFER or ACK response */

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_MESSAGETYPE;
    1634:	df 01       	movw	r26, r30
    1636:	85 e3       	ldi	r24, 0x35	; 53
    1638:	8d 93       	st	X+, r24
				*(DHCPOptionsOUTStart++) = 1;
    163a:	81 e0       	ldi	r24, 0x01	; 1
    163c:	81 83       	std	Z+1, r24	; 0x01
    163e:	ed 01       	movw	r28, r26
    1640:	21 96       	adiw	r28, 0x01	; 1
				*(DHCPOptionsOUTStart++) = (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) ? DHCP_MESSAGETYPE_OFFER
    1642:	f9 01       	movw	r30, r18
    1644:	80 81       	ld	r24, Z
    1646:	81 30       	cpi	r24, 0x01	; 1
    1648:	11 f0       	breq	.+4      	; 0x164e <DHCP_ProcessDHCPPacket+0x102>
    164a:	85 e0       	ldi	r24, 0x05	; 5
    164c:	01 c0       	rjmp	.+2      	; 0x1650 <DHCP_ProcessDHCPPacket+0x104>
    164e:	82 e0       	ldi	r24, 0x02	; 2
    1650:	11 96       	adiw	r26, 0x01	; 1
    1652:	8c 93       	st	X, r24
    1654:	fe 01       	movw	r30, r28
    1656:	31 96       	adiw	r30, 0x01	; 1
																								: DHCP_MESSAGETYPE_ACK;

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_SUBNETMASK;
    1658:	81 e0       	ldi	r24, 0x01	; 1
    165a:	89 83       	std	Y+1, r24	; 0x01
    165c:	cf 01       	movw	r24, r30
    165e:	01 96       	adiw	r24, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 4;
    1660:	34 e0       	ldi	r19, 0x04	; 4
    1662:	31 83       	std	Z+1, r19	; 0x01
    1664:	dc 01       	movw	r26, r24
    1666:	11 96       	adiw	r26, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0xFF;
    1668:	2f ef       	ldi	r18, 0xFF	; 255
    166a:	fc 01       	movw	r30, r24
    166c:	21 83       	std	Z+1, r18	; 0x01
    166e:	fd 01       	movw	r30, r26
    1670:	31 96       	adiw	r30, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0xFF;
    1672:	11 96       	adiw	r26, 0x01	; 1
    1674:	2c 93       	st	X, r18
    1676:	df 01       	movw	r26, r30
    1678:	11 96       	adiw	r26, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0xFF;
    167a:	21 83       	std	Z+1, r18	; 0x01
    167c:	fd 01       	movw	r30, r26
    167e:	31 96       	adiw	r30, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0x00;
    1680:	11 96       	adiw	r26, 0x01	; 1
    1682:	1c 92       	st	X, r1
    1684:	df 01       	movw	r26, r30
    1686:	11 96       	adiw	r26, 0x01	; 1

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_DHCPSERVER;
    1688:	86 e3       	ldi	r24, 0x36	; 54
    168a:	81 83       	std	Z+1, r24	; 0x01
    168c:	fd 01       	movw	r30, r26
    168e:	31 96       	adiw	r30, 0x01	; 1
				*(DHCPOptionsOUTStart++) = sizeof(IP_Address_t);
    1690:	11 96       	adiw	r26, 0x01	; 1
    1692:	3c 93       	st	X, r19
				memcpy(DHCPOptionsOUTStart, &ServerIPAddress, sizeof(IP_Address_t));
    1694:	80 91 b9 01 	lds	r24, 0x01B9
    1698:	90 91 ba 01 	lds	r25, 0x01BA
    169c:	a0 91 bb 01 	lds	r26, 0x01BB
    16a0:	b0 91 bc 01 	lds	r27, 0x01BC
    16a4:	81 83       	std	Z+1, r24	; 0x01
    16a6:	92 83       	std	Z+2, r25	; 0x02
    16a8:	a3 83       	std	Z+3, r26	; 0x03
    16aa:	b4 83       	std	Z+4, r27	; 0x04
				DHCPOptionsOUTStart     += sizeof(IP_Address_t);

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_END;
    16ac:	25 83       	std	Z+5, r18	; 0x05
    16ae:	20 e0       	ldi	r18, 0x00	; 0
    16b0:	31 e0       	ldi	r19, 0x01	; 1
    16b2:	12 c0       	rjmp	.+36     	; 0x16d8 <DHCP_ProcessDHCPPacket+0x18c>
				return (sizeof(DHCP_Header_t) + 12 + sizeof(IP_Address_t));
			}
		}

		/* Go to the next DHCP option - skip one byte if option is a padding byte, else skip the complete option's size */
		DHCPOptionsINStart += ((DHCPOptionsINStart[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptionsINStart[1] + 2));
    16b4:	88 23       	and	r24, r24
    16b6:	19 f4       	brne	.+6      	; 0x16be <DHCP_ProcessDHCPPacket+0x172>
    16b8:	81 e0       	ldi	r24, 0x01	; 1
    16ba:	90 e0       	ldi	r25, 0x00	; 0
    16bc:	04 c0       	rjmp	.+8      	; 0x16c6 <DHCP_ProcessDHCPPacket+0x17a>
    16be:	f4 01       	movw	r30, r8
    16c0:	81 81       	ldd	r24, Z+1	; 0x01
    16c2:	90 e0       	ldi	r25, 0x00	; 0
    16c4:	02 96       	adiw	r24, 0x02	; 2
    16c6:	88 0e       	add	r8, r24
    16c8:	99 1e       	adc	r9, r25
	   when the response IP header is generated, it will use the corrected addresses and not the null/broatcast addresses */
	IPHeaderIN->SourceAddress      = ClientIPAddress;
	IPHeaderIN->DestinationAddress = ServerIPAddress;

	/* Process the incoming DHCP packet options */
	while (DHCPOptionsINStart[0] != DHCP_OPTION_END)
    16ca:	f4 01       	movw	r30, r8
    16cc:	80 81       	ld	r24, Z
    16ce:	8f 3f       	cpi	r24, 0xFF	; 255
    16d0:	09 f0       	breq	.+2      	; 0x16d4 <DHCP_ProcessDHCPPacket+0x188>
    16d2:	a0 cf       	rjmp	.-192    	; 0x1614 <DHCP_ProcessDHCPPacket+0xc8>
    16d4:	20 e0       	ldi	r18, 0x00	; 0
    16d6:	30 e0       	ldi	r19, 0x00	; 0
		/* Go to the next DHCP option - skip one byte if option is a padding byte, else skip the complete option's size */
		DHCPOptionsINStart += ((DHCPOptionsINStart[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptionsINStart[1] + 2));
	}

	return NO_RESPONSE;
}
    16d8:	c9 01       	movw	r24, r18
    16da:	df 91       	pop	r29
    16dc:	cf 91       	pop	r28
    16de:	1f 91       	pop	r17
    16e0:	0f 91       	pop	r16
    16e2:	ff 90       	pop	r15
    16e4:	ef 90       	pop	r14
    16e6:	df 90       	pop	r13
    16e8:	cf 90       	pop	r12
    16ea:	bf 90       	pop	r11
    16ec:	af 90       	pop	r10
    16ee:	9f 90       	pop	r9
    16f0:	8f 90       	pop	r8
    16f2:	08 95       	ret

000016f4 <ARP_ProcessARPPacket>:
 *
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t ARP_ProcessARPPacket(void* InDataStart,
                             void* OutDataStart)
{
    16f4:	ef 92       	push	r14
    16f6:	ff 92       	push	r15
    16f8:	0f 93       	push	r16
    16fa:	1f 93       	push	r17
    16fc:	cf 93       	push	r28
    16fe:	df 93       	push	r29
    1700:	18 2f       	mov	r17, r24
    1702:	09 2f       	mov	r16, r25
    1704:	f6 2e       	mov	r15, r22
    1706:	e7 2e       	mov	r14, r23
	DecodeARPHeader(InDataStart);
    1708:	0c d8       	rcall	.-4072   	; 0x722 <DecodeARPHeader>

	ARP_Header_t* ARPHeaderIN  = (ARP_Header_t*)InDataStart;
    170a:	c1 2f       	mov	r28, r17
    170c:	d0 2f       	mov	r29, r16
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    170e:	8a 81       	ldd	r24, Y+2	; 0x02
    1710:	9b 81       	ldd	r25, Y+3	; 0x03

				Temp = Data.Bytes[0];
    1712:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[1];
    1714:	89 2f       	mov	r24, r25
				Data.Bytes[1] = Temp;
    1716:	92 2f       	mov	r25, r18
	ARP_Header_t* ARPHeaderOUT = (ARP_Header_t*)OutDataStart;

	/* Ensure that the ARP request is a IPv4 request packet */
	if ((SwapEndian_16(ARPHeaderIN->ProtocolType) == ETHERTYPE_IPV4) &&
    1718:	80 50       	subi	r24, 0x00	; 0
    171a:	98 40       	sbci	r25, 0x08	; 8
    171c:	09 f0       	breq	.+2      	; 0x1720 <ARP_ProcessARPPacket+0x2c>
    171e:	5e c0       	rjmp	.+188    	; 0x17dc <ARP_ProcessARPPacket+0xe8>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    1720:	8e 81       	ldd	r24, Y+6	; 0x06
    1722:	9f 81       	ldd	r25, Y+7	; 0x07

				Temp = Data.Bytes[0];
    1724:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[1];
    1726:	89 2f       	mov	r24, r25
				Data.Bytes[1] = Temp;
    1728:	92 2f       	mov	r25, r18
    172a:	01 97       	sbiw	r24, 0x01	; 1
    172c:	09 f0       	breq	.+2      	; 0x1730 <ARP_ProcessARPPacket+0x3c>
    172e:	56 c0       	rjmp	.+172    	; 0x17dc <ARP_ProcessARPPacket+0xe8>
	    (SwapEndian_16(ARPHeaderIN->Operation) == ARP_OPERATION_REQUEST))
	{
		/* If the ARP packet is requesting the MAC or IP of the virtual webserver, return the response */
		if (IP_COMPARE(&ARPHeaderIN->TPA, &ServerIPAddress) ||
    1730:	ce 01       	movw	r24, r28
    1732:	48 96       	adiw	r24, 0x18	; 24
    1734:	69 eb       	ldi	r22, 0xB9	; 185
    1736:	71 e0       	ldi	r23, 0x01	; 1
    1738:	44 e0       	ldi	r20, 0x04	; 4
    173a:	50 e0       	ldi	r21, 0x00	; 0
    173c:	0e 94 f0 16 	call	0x2de0	; 0x2de0 <memcmp>
    1740:	00 97       	sbiw	r24, 0x00	; 0
    1742:	59 f0       	breq	.+22     	; 0x175a <ARP_ProcessARPPacket+0x66>
    1744:	ce 01       	movw	r24, r28
    1746:	42 96       	adiw	r24, 0x12	; 18
    1748:	63 eb       	ldi	r22, 0xB3	; 179
    174a:	71 e0       	ldi	r23, 0x01	; 1
    174c:	46 e0       	ldi	r20, 0x06	; 6
    174e:	50 e0       	ldi	r21, 0x00	; 0
    1750:	0e 94 f0 16 	call	0x2de0	; 0x2de0 <memcmp>
    1754:	00 97       	sbiw	r24, 0x00	; 0
    1756:	09 f0       	breq	.+2      	; 0x175a <ARP_ProcessARPPacket+0x66>
    1758:	41 c0       	rjmp	.+130    	; 0x17dc <ARP_ProcessARPPacket+0xe8>
                             void* OutDataStart)
{
	DecodeARPHeader(InDataStart);

	ARP_Header_t* ARPHeaderIN  = (ARP_Header_t*)InDataStart;
	ARP_Header_t* ARPHeaderOUT = (ARP_Header_t*)OutDataStart;
    175a:	ef 2d       	mov	r30, r15
    175c:	fe 2d       	mov	r31, r14
		/* If the ARP packet is requesting the MAC or IP of the virtual webserver, return the response */
		if (IP_COMPARE(&ARPHeaderIN->TPA, &ServerIPAddress) ||
		    MAC_COMPARE(&ARPHeaderIN->THA, &ServerMACAddress))
		{
			/* Fill out the ARP response header */
			ARPHeaderOUT->HardwareType = ARPHeaderIN->HardwareType;
    175e:	88 81       	ld	r24, Y
    1760:	99 81       	ldd	r25, Y+1	; 0x01
    1762:	91 83       	std	Z+1, r25	; 0x01
    1764:	80 83       	st	Z, r24
			ARPHeaderOUT->ProtocolType = ARPHeaderIN->ProtocolType;
    1766:	8a 81       	ldd	r24, Y+2	; 0x02
    1768:	9b 81       	ldd	r25, Y+3	; 0x03
    176a:	93 83       	std	Z+3, r25	; 0x03
    176c:	82 83       	std	Z+2, r24	; 0x02
			ARPHeaderOUT->HLEN         = ARPHeaderIN->HLEN;
    176e:	8c 81       	ldd	r24, Y+4	; 0x04
    1770:	84 83       	std	Z+4, r24	; 0x04
			ARPHeaderOUT->PLEN         = ARPHeaderIN->PLEN;
    1772:	8d 81       	ldd	r24, Y+5	; 0x05
    1774:	85 83       	std	Z+5, r24	; 0x05
			ARPHeaderOUT->Operation    = SwapEndian_16(ARP_OPERATION_REPLY);
    1776:	80 e0       	ldi	r24, 0x00	; 0
    1778:	92 e0       	ldi	r25, 0x02	; 2
    177a:	97 83       	std	Z+7, r25	; 0x07
    177c:	86 83       	std	Z+6, r24	; 0x06

			/* Copy over the sender MAC/IP to the target fields for the response */
			ARPHeaderOUT->THA = ARPHeaderIN->SHA;
    177e:	9f 01       	movw	r18, r30
    1780:	2e 5e       	subi	r18, 0xEE	; 238
    1782:	3f 4f       	sbci	r19, 0xFF	; 255
    1784:	ae 01       	movw	r20, r28
    1786:	48 5f       	subi	r20, 0xF8	; 248
    1788:	5f 4f       	sbci	r21, 0xFF	; 255
    178a:	86 e0       	ldi	r24, 0x06	; 6
    178c:	da 01       	movw	r26, r20
    178e:	0d 90       	ld	r0, X+
    1790:	ad 01       	movw	r20, r26
    1792:	d9 01       	movw	r26, r18
    1794:	0d 92       	st	X+, r0
    1796:	9d 01       	movw	r18, r26
    1798:	81 50       	subi	r24, 0x01	; 1
    179a:	c1 f7       	brne	.-16     	; 0x178c <ARP_ProcessARPPacket+0x98>
			ARPHeaderOUT->TPA = ARPHeaderIN->SPA;
    179c:	8e 85       	ldd	r24, Y+14	; 0x0e
    179e:	9f 85       	ldd	r25, Y+15	; 0x0f
    17a0:	a8 89       	ldd	r26, Y+16	; 0x10
    17a2:	b9 89       	ldd	r27, Y+17	; 0x11
    17a4:	80 8f       	std	Z+24, r24	; 0x18
    17a6:	91 8f       	std	Z+25, r25	; 0x19
    17a8:	a2 8f       	std	Z+26, r26	; 0x1a
    17aa:	b3 8f       	std	Z+27, r27	; 0x1b

			/* Copy over the new sender MAC/IP - MAC and IP addresses of the virtual webserver */
			ARPHeaderOUT->SHA = ServerMACAddress;
    17ac:	ef 01       	movw	r28, r30
    17ae:	28 96       	adiw	r28, 0x08	; 8
    17b0:	a3 eb       	ldi	r26, 0xB3	; 179
    17b2:	b1 e0       	ldi	r27, 0x01	; 1
    17b4:	86 e0       	ldi	r24, 0x06	; 6
    17b6:	0d 90       	ld	r0, X+
    17b8:	09 92       	st	Y+, r0
    17ba:	81 50       	subi	r24, 0x01	; 1
    17bc:	e1 f7       	brne	.-8      	; 0x17b6 <ARP_ProcessARPPacket+0xc2>
			ARPHeaderOUT->SPA = ServerIPAddress;
    17be:	80 91 b9 01 	lds	r24, 0x01B9
    17c2:	90 91 ba 01 	lds	r25, 0x01BA
    17c6:	a0 91 bb 01 	lds	r26, 0x01BB
    17ca:	b0 91 bc 01 	lds	r27, 0x01BC
    17ce:	86 87       	std	Z+14, r24	; 0x0e
    17d0:	97 87       	std	Z+15, r25	; 0x0f
    17d2:	a0 8b       	std	Z+16, r26	; 0x10
    17d4:	b1 8b       	std	Z+17, r27	; 0x11
    17d6:	2c e1       	ldi	r18, 0x1C	; 28
    17d8:	30 e0       	ldi	r19, 0x00	; 0
    17da:	02 c0       	rjmp	.+4      	; 0x17e0 <ARP_ProcessARPPacket+0xec>

			/* Return the size of the response so far */
			return sizeof(ARP_Header_t);
    17dc:	20 e0       	ldi	r18, 0x00	; 0
    17de:	30 e0       	ldi	r19, 0x00	; 0
		}
	}

	return NO_RESPONSE;
}
    17e0:	c9 01       	movw	r24, r18
    17e2:	df 91       	pop	r29
    17e4:	cf 91       	pop	r28
    17e6:	1f 91       	pop	r17
    17e8:	0f 91       	pop	r16
    17ea:	ff 90       	pop	r15
    17ec:	ef 90       	pop	r14
    17ee:	08 95       	ret

000017f0 <IP_ProcessIPPacket>:
 *           next Ethernet packet handler iteration
 */
int16_t IP_ProcessIPPacket(Ethernet_Frame_Info_t* const FrameIN,
                           void* InDataStart,
                           void* OutDataStart)
{
    17f0:	af 92       	push	r10
    17f2:	bf 92       	push	r11
    17f4:	df 92       	push	r13
    17f6:	ef 92       	push	r14
    17f8:	ff 92       	push	r15
    17fa:	0f 93       	push	r16
    17fc:	1f 93       	push	r17
    17fe:	cf 93       	push	r28
    1800:	df 93       	push	r29
    1802:	5c 01       	movw	r10, r24
    1804:	7b 01       	movw	r14, r22
    1806:	ea 01       	movw	r28, r20
	DecodeIPHeader(InDataStart);
    1808:	cb 01       	movw	r24, r22
    180a:	0e 94 92 03 	call	0x724	; 0x724 <DecodeIPHeader>

	IP_Header_t* IPHeaderIN  = (IP_Header_t*)InDataStart;
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    180e:	f7 01       	movw	r30, r14
    1810:	d0 80       	ld	r13, Z
    1812:	ff e0       	ldi	r31, 0x0F	; 15
    1814:	df 22       	and	r13, r31

	int16_t  RetSize = NO_RESPONSE;

	/* Check to ensure the IP packet is addressed to the virtual webserver's IP or the broadcast IP address */
	if (!(IP_COMPARE(&IPHeaderIN->DestinationAddress, &ServerIPAddress)) &&
    1816:	87 01       	movw	r16, r14
    1818:	00 5f       	subi	r16, 0xF0	; 240
    181a:	1f 4f       	sbci	r17, 0xFF	; 255
    181c:	c8 01       	movw	r24, r16
    181e:	69 eb       	ldi	r22, 0xB9	; 185
    1820:	71 e0       	ldi	r23, 0x01	; 1
    1822:	44 e0       	ldi	r20, 0x04	; 4
    1824:	50 e0       	ldi	r21, 0x00	; 0
    1826:	0e 94 f0 16 	call	0x2de0	; 0x2de0 <memcmp>
    182a:	00 97       	sbiw	r24, 0x00	; 0
    182c:	49 f0       	breq	.+18     	; 0x1840 <IP_ProcessIPPacket+0x50>
    182e:	c8 01       	movw	r24, r16
    1830:	63 ec       	ldi	r22, 0xC3	; 195
    1832:	71 e0       	ldi	r23, 0x01	; 1
    1834:	44 e0       	ldi	r20, 0x04	; 4
    1836:	50 e0       	ldi	r21, 0x00	; 0
    1838:	0e 94 f0 16 	call	0x2de0	; 0x2de0 <memcmp>
    183c:	00 97       	sbiw	r24, 0x00	; 0
    183e:	71 f4       	brne	.+28     	; 0x185c <IP_ProcessIPPacket+0x6c>

	IP_Header_t* IPHeaderIN  = (IP_Header_t*)InDataStart;
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    1840:	6d 2d       	mov	r22, r13
    1842:	70 e0       	ldi	r23, 0x00	; 0
    1844:	66 0f       	add	r22, r22
    1846:	77 1f       	adc	r23, r23
    1848:	66 0f       	add	r22, r22
    184a:	77 1f       	adc	r23, r23
	{
		return NO_RESPONSE;
	}

	/* Pass off the IP payload to the appropriate protocol processing routine */
	switch (IPHeaderIN->Protocol)
    184c:	f7 01       	movw	r30, r14
    184e:	81 85       	ldd	r24, Z+9	; 0x09
    1850:	86 30       	cpi	r24, 0x06	; 6
    1852:	81 f0       	breq	.+32     	; 0x1874 <IP_ProcessIPPacket+0x84>
    1854:	81 31       	cpi	r24, 0x11	; 17
    1856:	b1 f0       	breq	.+44     	; 0x1884 <IP_ProcessIPPacket+0x94>
    1858:	81 30       	cpi	r24, 0x01	; 1
    185a:	19 f0       	breq	.+6      	; 0x1862 <IP_ProcessIPPacket+0x72>
    185c:	20 e0       	ldi	r18, 0x00	; 0
    185e:	30 e0       	ldi	r19, 0x00	; 0
    1860:	47 c0       	rjmp	.+142    	; 0x18f0 <IP_ProcessIPPacket+0x100>
	{
		case PROTOCOL_ICMP:
			RetSize = ICMP_ProcessICMPPacket(FrameIN,
    1862:	6e 0d       	add	r22, r14
    1864:	7f 1d       	adc	r23, r15
    1866:	ae 01       	movw	r20, r28
    1868:	4c 5e       	subi	r20, 0xEC	; 236
    186a:	5f 4f       	sbci	r21, 0xFF	; 255
    186c:	c5 01       	movw	r24, r10
    186e:	0e 94 97 03 	call	0x72e	; 0x72e <ICMP_ProcessICMPPacket>
    1872:	0f c0       	rjmp	.+30     	; 0x1892 <IP_ProcessIPPacket+0xa2>
			                                 &((uint8_t*)InDataStart)[HeaderLengthBytes],
			                                 &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
		case PROTOCOL_TCP:
			RetSize = TCP_ProcessTCPPacket(InDataStart,
    1874:	6e 0d       	add	r22, r14
    1876:	7f 1d       	adc	r23, r15
    1878:	ae 01       	movw	r20, r28
    187a:	4c 5e       	subi	r20, 0xEC	; 236
    187c:	5f 4f       	sbci	r21, 0xFF	; 255
    187e:	c7 01       	movw	r24, r14
    1880:	f6 d9       	rcall	.-3092   	; 0xc6e <TCP_ProcessTCPPacket>
    1882:	07 c0       	rjmp	.+14     	; 0x1892 <IP_ProcessIPPacket+0xa2>
			                               &((uint8_t*)InDataStart)[HeaderLengthBytes],
			                               &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
		case PROTOCOL_UDP:
			RetSize = UDP_ProcessUDPPacket(InDataStart,
    1884:	6e 0d       	add	r22, r14
    1886:	7f 1d       	adc	r23, r15
    1888:	ae 01       	movw	r20, r28
    188a:	4c 5e       	subi	r20, 0xEC	; 236
    188c:	5f 4f       	sbci	r21, 0xFF	; 255
    188e:	c7 01       	movw	r24, r14
    1890:	23 de       	rcall	.-954    	; 0x14d8 <UDP_ProcessUDPPacket>
    1892:	9c 01       	movw	r18, r24
			                               &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
	}

	/* Check to see if the protocol processing routine has filled out a response */
	if (RetSize > 0)
    1894:	18 16       	cp	r1, r24
    1896:	19 06       	cpc	r1, r25
    1898:	5c f5       	brge	.+86     	; 0x18f0 <IP_ProcessIPPacket+0x100>
	{
		/* Fill out the response IP packet header */
		IPHeaderOUT->TotalLength        = SwapEndian_16(sizeof(IP_Header_t) + RetSize);
    189a:	8c 01       	movw	r16, r24
    189c:	0c 5e       	subi	r16, 0xEC	; 236
    189e:	1f 4f       	sbci	r17, 0xFF	; 255
    18a0:	1a 83       	std	Y+2, r17	; 0x02
    18a2:	0b 83       	std	Y+3, r16	; 0x03
		IPHeaderOUT->TypeOfService      = 0;
    18a4:	19 82       	std	Y+1, r1	; 0x01
		IPHeaderOUT->HeaderLength       = (sizeof(IP_Header_t) / sizeof(uint32_t));
		IPHeaderOUT->Version            = 4;
    18a6:	85 e4       	ldi	r24, 0x45	; 69
    18a8:	88 83       	st	Y, r24
		IPHeaderOUT->Flags              = 0;
		IPHeaderOUT->FragmentOffset     = 0;
    18aa:	1e 82       	std	Y+6, r1	; 0x06
    18ac:	1f 82       	std	Y+7, r1	; 0x07
		IPHeaderOUT->Identification     = 0;
    18ae:	1d 82       	std	Y+5, r1	; 0x05
    18b0:	1c 82       	std	Y+4, r1	; 0x04
		IPHeaderOUT->HeaderChecksum     = 0;
    18b2:	1b 86       	std	Y+11, r1	; 0x0b
    18b4:	1a 86       	std	Y+10, r1	; 0x0a
		IPHeaderOUT->Protocol           = IPHeaderIN->Protocol;
    18b6:	f7 01       	movw	r30, r14
    18b8:	81 85       	ldd	r24, Z+9	; 0x09
    18ba:	89 87       	std	Y+9, r24	; 0x09
		IPHeaderOUT->TTL                = DEFAULT_TTL;
    18bc:	80 e8       	ldi	r24, 0x80	; 128
    18be:	88 87       	std	Y+8, r24	; 0x08
		IPHeaderOUT->SourceAddress      = IPHeaderIN->DestinationAddress;
    18c0:	80 89       	ldd	r24, Z+16	; 0x10
    18c2:	91 89       	ldd	r25, Z+17	; 0x11
    18c4:	a2 89       	ldd	r26, Z+18	; 0x12
    18c6:	b3 89       	ldd	r27, Z+19	; 0x13
    18c8:	8c 87       	std	Y+12, r24	; 0x0c
    18ca:	9d 87       	std	Y+13, r25	; 0x0d
    18cc:	ae 87       	std	Y+14, r26	; 0x0e
    18ce:	bf 87       	std	Y+15, r27	; 0x0f
		IPHeaderOUT->DestinationAddress = IPHeaderIN->SourceAddress;
    18d0:	84 85       	ldd	r24, Z+12	; 0x0c
    18d2:	95 85       	ldd	r25, Z+13	; 0x0d
    18d4:	a6 85       	ldd	r26, Z+14	; 0x0e
    18d6:	b7 85       	ldd	r27, Z+15	; 0x0f
    18d8:	88 8b       	std	Y+16, r24	; 0x10
    18da:	99 8b       	std	Y+17, r25	; 0x11
    18dc:	aa 8b       	std	Y+18, r26	; 0x12
    18de:	bb 8b       	std	Y+19, r27	; 0x13

		IPHeaderOUT->HeaderChecksum     = Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));
    18e0:	ce 01       	movw	r24, r28
    18e2:	64 e1       	ldi	r22, 0x14	; 20
    18e4:	70 e0       	ldi	r23, 0x00	; 0
    18e6:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <Ethernet_Checksum16>
    18ea:	9b 87       	std	Y+11, r25	; 0x0b
    18ec:	8a 87       	std	Y+10, r24	; 0x0a

		/* Return the size of the response so far */
		return (sizeof(IP_Header_t) + RetSize);
    18ee:	98 01       	movw	r18, r16
	}

	return RetSize;
}
    18f0:	c9 01       	movw	r24, r18
    18f2:	df 91       	pop	r29
    18f4:	cf 91       	pop	r28
    18f6:	1f 91       	pop	r17
    18f8:	0f 91       	pop	r16
    18fa:	ff 90       	pop	r15
    18fc:	ef 90       	pop	r14
    18fe:	df 90       	pop	r13
    1900:	bf 90       	pop	r11
    1902:	af 90       	pop	r10
    1904:	08 95       	ret

00001906 <IsHTTPCommand>:
 */
static bool IsHTTPCommand(uint8_t* RequestHeader,
                          char* Command)
{
	/* Returns true if the non null terminated string in RequestHeader matches the null terminated string Command */
	return (strncmp((char*)RequestHeader, Command, strlen(Command)) == 0);
    1906:	db 01       	movw	r26, r22
    1908:	0d 90       	ld	r0, X+
    190a:	00 20       	and	r0, r0
    190c:	e9 f7       	brne	.-6      	; 0x1908 <IsHTTPCommand+0x2>
    190e:	11 97       	sbiw	r26, 0x01	; 1
    1910:	a6 1b       	sub	r26, r22
    1912:	b7 0b       	sbc	r27, r23
    1914:	ad 01       	movw	r20, r26
    1916:	0e 94 17 17 	call	0x2e2e	; 0x2e2e <strncmp>
    191a:	9c 01       	movw	r18, r24
    191c:	80 e0       	ldi	r24, 0x00	; 0
    191e:	23 2b       	or	r18, r19
    1920:	09 f4       	brne	.+2      	; 0x1924 <IsHTTPCommand+0x1e>
    1922:	81 e0       	ldi	r24, 0x01	; 1
}
    1924:	08 95       	ret

00001926 <Webserver_ApplicationCallback>:
 *  \param[in] ConnectionState  Pointer to a TCP Connection State structure giving connection information
 *  \param[in,out] Buffer       Pointer to the application's send/receive packet buffer
 */
void Webserver_ApplicationCallback(TCP_ConnectionState_t* const ConnectionState,
                                   TCP_ConnectionBuffer_t* const Buffer)
{
    1926:	af 92       	push	r10
    1928:	bf 92       	push	r11
    192a:	cf 92       	push	r12
    192c:	df 92       	push	r13
    192e:	ef 92       	push	r14
    1930:	ff 92       	push	r15
    1932:	0f 93       	push	r16
    1934:	1f 93       	push	r17
    1936:	cf 93       	push	r28
    1938:	df 93       	push	r29
    193a:	5c 01       	movw	r10, r24
    193c:	eb 01       	movw	r28, r22
	char*          BufferDataStr = (char*)Buffer->Data;
    193e:	8b 01       	movw	r16, r22
    1940:	0e 5f       	subi	r16, 0xFE	; 254
    1942:	1f 4f       	sbci	r17, 0xFF	; 255
	static uint8_t PageBlock     = 0;

	/* Check to see if a packet has been received on the HTTP port from a remote host */
	if (TCP_APP_HAS_RECEIVED_PACKET(Buffer))
    1944:	33 e0       	ldi	r19, 0x03	; 3
    1946:	c3 2e       	mov	r12, r19
    1948:	32 e0       	ldi	r19, 0x02	; 2
    194a:	d3 2e       	mov	r13, r19
    194c:	c6 0e       	add	r12, r22
    194e:	d7 1e       	adc	r13, r23
    1950:	f6 01       	movw	r30, r12
    1952:	80 81       	ld	r24, Z
    1954:	88 23       	and	r24, r24
    1956:	09 f4       	brne	.+2      	; 0x195a <Webserver_ApplicationCallback+0x34>
    1958:	66 c0       	rjmp	.+204    	; 0x1a26 <Webserver_ApplicationCallback+0x100>
    195a:	22 e0       	ldi	r18, 0x02	; 2
    195c:	e2 2e       	mov	r14, r18
    195e:	f2 2e       	mov	r15, r18
    1960:	e6 0e       	add	r14, r22
    1962:	f7 1e       	adc	r15, r23
    1964:	f7 01       	movw	r30, r14
    1966:	80 81       	ld	r24, Z
    1968:	88 23       	and	r24, r24
    196a:	09 f0       	breq	.+2      	; 0x196e <Webserver_ApplicationCallback+0x48>
    196c:	a7 c0       	rjmp	.+334    	; 0x1abc <Webserver_ApplicationCallback+0x196>
	{
		if (IsHTTPCommand(Buffer->Data, "GET"))
    196e:	c8 01       	movw	r24, r16
    1970:	61 ed       	ldi	r22, 0xD1	; 209
    1972:	71 e0       	ldi	r23, 0x01	; 1
    1974:	c8 df       	rcall	.-112    	; 0x1906 <IsHTTPCommand>
    1976:	88 23       	and	r24, r24
    1978:	f9 f0       	breq	.+62     	; 0x19b8 <Webserver_ApplicationCallback+0x92>
		{
			if (IsHTTPCommand(Buffer->Data, "GET / "))
    197a:	c8 01       	movw	r24, r16
    197c:	65 ed       	ldi	r22, 0xD5	; 213
    197e:	71 e0       	ldi	r23, 0x01	; 1
    1980:	c2 df       	rcall	.-124    	; 0x1906 <IsHTTPCommand>
    1982:	88 23       	and	r24, r24
    1984:	49 f1       	breq	.+82     	; 0x19d8 <Webserver_ApplicationCallback+0xb2>
			{
				PageBlock = 0;
    1986:	10 92 b4 0d 	sts	0x0DB4, r1

				/* Copy the HTTP 200 response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP200Header);
    198a:	c8 01       	movw	r24, r16
    198c:	60 e3       	ldi	r22, 0x30	; 48
    198e:	71 e0       	ldi	r23, 0x01	; 1
    1990:	0e 94 d1 16 	call	0x2da2	; 0x2da2 <strcpy_P>

				/* Send the buffer contents to the host */
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
    1994:	81 e0       	ldi	r24, 0x01	; 1
    1996:	f7 01       	movw	r30, r14
    1998:	80 83       	st	Z, r24
    199a:	f8 01       	movw	r30, r16
    199c:	01 90       	ld	r0, Z+
    199e:	00 20       	and	r0, r0
    19a0:	e9 f7       	brne	.-6      	; 0x199c <Webserver_ApplicationCallback+0x76>
    19a2:	31 97       	sbiw	r30, 0x01	; 1
    19a4:	e0 1b       	sub	r30, r16
    19a6:	f1 0b       	sbc	r31, r17
    19a8:	f9 83       	std	Y+1, r31	; 0x01
    19aa:	e8 83       	st	Y, r30
    19ac:	f6 01       	movw	r30, r12
    19ae:	80 83       	st	Z, r24

				/* Lock the buffer to Device->Host transmissions only while we send the page contents */
				TCP_APP_CAPTURE_BUFFER(Buffer);
    19b0:	cc 5f       	subi	r28, 0xFC	; 252
    19b2:	dd 4f       	sbci	r29, 0xFD	; 253
    19b4:	88 83       	st	Y, r24
    19b6:	82 c0       	rjmp	.+260    	; 0x1abc <Webserver_ApplicationCallback+0x196>

				/* All data sent, close the connection */
				TCP_APP_CLOSECONNECTION(ConnectionState);
			}
		}
		else if (IsHTTPCommand(Buffer->Data, "HEAD"))
    19b8:	c8 01       	movw	r24, r16
    19ba:	6c ed       	ldi	r22, 0xDC	; 220
    19bc:	71 e0       	ldi	r23, 0x01	; 1
    19be:	a3 df       	rcall	.-186    	; 0x1906 <IsHTTPCommand>
    19c0:	88 23       	and	r24, r24
    19c2:	11 f1       	breq	.+68     	; 0x1a08 <Webserver_ApplicationCallback+0xe2>
		{
			if (IsHTTPCommand(Buffer->Data, "HEAD / "))
    19c4:	c8 01       	movw	r24, r16
    19c6:	61 ee       	ldi	r22, 0xE1	; 225
    19c8:	71 e0       	ldi	r23, 0x01	; 1
    19ca:	9d df       	rcall	.-198    	; 0x1906 <IsHTTPCommand>
    19cc:	88 23       	and	r24, r24
    19ce:	21 f0       	breq	.+8      	; 0x19d8 <Webserver_ApplicationCallback+0xb2>
			{
				/* Copy the HTTP response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP200Header);
    19d0:	c8 01       	movw	r24, r16
    19d2:	60 e3       	ldi	r22, 0x30	; 48
    19d4:	71 e0       	ldi	r23, 0x01	; 1
    19d6:	03 c0       	rjmp	.+6      	; 0x19de <Webserver_ApplicationCallback+0xb8>
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
			}
			else
			{
				/* Copy the HTTP response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP404Header);
    19d8:	c8 01       	movw	r24, r16
    19da:	64 e8       	ldi	r22, 0x84	; 132
    19dc:	71 e0       	ldi	r23, 0x01	; 1
    19de:	0e 94 d1 16 	call	0x2da2	; 0x2da2 <strcpy_P>

				/* Send the buffer contents to the host */
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
    19e2:	81 e0       	ldi	r24, 0x01	; 1
    19e4:	f7 01       	movw	r30, r14
    19e6:	80 83       	st	Z, r24
    19e8:	f8 01       	movw	r30, r16
    19ea:	01 90       	ld	r0, Z+
    19ec:	00 20       	and	r0, r0
    19ee:	e9 f7       	brne	.-6      	; 0x19ea <Webserver_ApplicationCallback+0xc4>
    19f0:	31 97       	sbiw	r30, 0x01	; 1
    19f2:	e0 1b       	sub	r30, r16
    19f4:	f1 0b       	sbc	r31, r17
    19f6:	f9 83       	std	Y+1, r31	; 0x01
    19f8:	e8 83       	st	Y, r30
    19fa:	f6 01       	movw	r30, r12
    19fc:	80 83       	st	Z, r24
			}

			/* All data sent, close the connection */
			TCP_APP_CLOSECONNECTION(ConnectionState);
    19fe:	85 e1       	ldi	r24, 0x15	; 21
    1a00:	92 e0       	ldi	r25, 0x02	; 2
    1a02:	a8 0e       	add	r10, r24
    1a04:	b9 1e       	adc	r11, r25
    1a06:	57 c0       	rjmp	.+174    	; 0x1ab6 <Webserver_ApplicationCallback+0x190>
		}
		else if (IsHTTPCommand(Buffer->Data, "TRACE"))
    1a08:	c8 01       	movw	r24, r16
    1a0a:	69 ee       	ldi	r22, 0xE9	; 233
    1a0c:	71 e0       	ldi	r23, 0x01	; 1
    1a0e:	7b df       	rcall	.-266    	; 0x1906 <IsHTTPCommand>
    1a10:	88 23       	and	r24, r24
    1a12:	21 f0       	breq	.+8      	; 0x1a1c <Webserver_ApplicationCallback+0xf6>
		{
			/* Echo the host's query back to the host */
			TCP_APP_SEND_BUFFER(Buffer, Buffer->Length);
    1a14:	81 e0       	ldi	r24, 0x01	; 1
    1a16:	f7 01       	movw	r30, r14
    1a18:	80 83       	st	Z, r24
    1a1a:	ef cf       	rjmp	.-34     	; 0x19fa <Webserver_ApplicationCallback+0xd4>
			TCP_APP_CLOSECONNECTION(ConnectionState);
		}
		else
		{
			/* Unknown request, just clear the buffer (drop the packet) */
			TCP_APP_CLEAR_BUFFER(Buffer);
    1a1c:	f6 01       	movw	r30, r12
    1a1e:	10 82       	st	Z, r1
    1a20:	19 82       	std	Y+1, r1	; 0x01
    1a22:	18 82       	st	Y, r1
    1a24:	4b c0       	rjmp	.+150    	; 0x1abc <Webserver_ApplicationCallback+0x196>
		}
	}
	else if (TCP_APP_HAVE_CAPTURED_BUFFER(Buffer))
    1a26:	cc 5f       	subi	r28, 0xFC	; 252
    1a28:	dd 4f       	sbci	r29, 0xFD	; 253
    1a2a:	88 81       	ld	r24, Y
    1a2c:	c4 50       	subi	r28, 0x04	; 4
    1a2e:	d2 40       	sbci	r29, 0x02	; 2
    1a30:	88 23       	and	r24, r24
    1a32:	09 f4       	brne	.+2      	; 0x1a36 <Webserver_ApplicationCallback+0x110>
    1a34:	43 c0       	rjmp	.+134    	; 0x1abc <Webserver_ApplicationCallback+0x196>
    1a36:	ce 5f       	subi	r28, 0xFE	; 254
    1a38:	dd 4f       	sbci	r29, 0xFD	; 253
    1a3a:	88 81       	ld	r24, Y
    1a3c:	c2 50       	subi	r28, 0x02	; 2
    1a3e:	d2 40       	sbci	r29, 0x02	; 2
    1a40:	88 23       	and	r24, r24
    1a42:	e1 f1       	breq	.+120    	; 0x1abc <Webserver_ApplicationCallback+0x196>
	{
		uint16_t RemLength = strlen_P(&HTTPPage[PageBlock * HTTP_REPLY_BLOCK_SIZE]);
    1a44:	80 91 b4 0d 	lds	r24, 0x0DB4
    1a48:	c8 2e       	mov	r12, r24
    1a4a:	dd 24       	eor	r13, r13
    1a4c:	d6 94       	lsr	r13
    1a4e:	dc 2c       	mov	r13, r12
    1a50:	cc 24       	eor	r12, r12
    1a52:	d7 94       	ror	r13
    1a54:	c7 94       	ror	r12
    1a56:	86 ec       	ldi	r24, 0xC6	; 198
    1a58:	91 e0       	ldi	r25, 0x01	; 1
    1a5a:	c8 0e       	add	r12, r24
    1a5c:	d9 1e       	adc	r13, r25
    1a5e:	c6 01       	movw	r24, r12
    1a60:	0e 94 d8 16 	call	0x2db0	; 0x2db0 <strlen_P>
		uint16_t Length;

		/* Determine the length of the loaded block */
		Length = ((RemLength > HTTP_REPLY_BLOCK_SIZE) ? HTTP_REPLY_BLOCK_SIZE : RemLength);
    1a64:	7c 01       	movw	r14, r24
    1a66:	91 e8       	ldi	r25, 0x81	; 129
    1a68:	e9 16       	cp	r14, r25
    1a6a:	f1 04       	cpc	r15, r1
    1a6c:	18 f0       	brcs	.+6      	; 0x1a74 <Webserver_ApplicationCallback+0x14e>
    1a6e:	80 e8       	ldi	r24, 0x80	; 128
    1a70:	e8 2e       	mov	r14, r24
    1a72:	f1 2c       	mov	r15, r1

		/* Copy the next buffer sized block of the page to the packet buffer */
		strncpy_P(BufferDataStr, &HTTPPage[PageBlock * HTTP_REPLY_BLOCK_SIZE], Length);
    1a74:	c8 01       	movw	r24, r16
    1a76:	b6 01       	movw	r22, r12
    1a78:	a7 01       	movw	r20, r14
    1a7a:	0e 94 e1 16 	call	0x2dc2	; 0x2dc2 <strncpy_P>

		/* Send the buffer contents to the host */
		TCP_APP_SEND_BUFFER(Buffer, Length);
    1a7e:	ce 5f       	subi	r28, 0xFE	; 254
    1a80:	dd 4f       	sbci	r29, 0xFD	; 253
    1a82:	81 e0       	ldi	r24, 0x01	; 1
    1a84:	88 83       	st	Y, r24
    1a86:	c2 50       	subi	r28, 0x02	; 2
    1a88:	d2 40       	sbci	r29, 0x02	; 2
    1a8a:	f9 82       	std	Y+1, r15	; 0x01
    1a8c:	e8 82       	st	Y, r14
    1a8e:	cd 5f       	subi	r28, 0xFD	; 253
    1a90:	dd 4f       	sbci	r29, 0xFD	; 253
    1a92:	88 83       	st	Y, r24
    1a94:	c3 50       	subi	r28, 0x03	; 3
    1a96:	d2 40       	sbci	r29, 0x02	; 2

		/* Check to see if the entire page has been sent */
		if (PageBlock++ == (sizeof(HTTPPage) / HTTP_REPLY_BLOCK_SIZE))
    1a98:	80 91 b4 0d 	lds	r24, 0x0DB4
    1a9c:	8f 5f       	subi	r24, 0xFF	; 255
    1a9e:	80 93 b4 0d 	sts	0x0DB4, r24
    1aa2:	81 50       	subi	r24, 0x01	; 1
    1aa4:	83 30       	cpi	r24, 0x03	; 3
    1aa6:	51 f4       	brne	.+20     	; 0x1abc <Webserver_ApplicationCallback+0x196>
		{
			/* Unlock the buffer so that the host can fill it with future packets */
			TCP_APP_RELEASE_BUFFER(Buffer);
    1aa8:	cc 5f       	subi	r28, 0xFC	; 252
    1aaa:	dd 4f       	sbci	r29, 0xFD	; 253
    1aac:	18 82       	st	Y, r1

			/* Close the connection to the host */
			TCP_APP_CLOSECONNECTION(ConnectionState);
    1aae:	e5 e1       	ldi	r30, 0x15	; 21
    1ab0:	f2 e0       	ldi	r31, 0x02	; 2
    1ab2:	ae 0e       	add	r10, r30
    1ab4:	bf 1e       	adc	r11, r31
    1ab6:	87 e0       	ldi	r24, 0x07	; 7
    1ab8:	f5 01       	movw	r30, r10
    1aba:	80 83       	st	Z, r24
		}
	}
}
    1abc:	df 91       	pop	r29
    1abe:	cf 91       	pop	r28
    1ac0:	1f 91       	pop	r17
    1ac2:	0f 91       	pop	r16
    1ac4:	ff 90       	pop	r15
    1ac6:	ef 90       	pop	r14
    1ac8:	df 90       	pop	r13
    1aca:	cf 90       	pop	r12
    1acc:	bf 90       	pop	r11
    1ace:	af 90       	pop	r10
    1ad0:	08 95       	ret

00001ad2 <Webserver_Init>:
 *  callback routine for packets sent to the HTTP protocol port.
 */
void Webserver_Init(void)
{
	/* Open the HTTP port in the TCP protocol so that HTTP connections to the device can be established */
	TCP_SetPortState(TCP_PORT_HTTP, TCP_Port_Open, Webserver_ApplicationCallback);
    1ad2:	80 e0       	ldi	r24, 0x00	; 0
    1ad4:	90 e5       	ldi	r25, 0x50	; 80
    1ad6:	61 e0       	ldi	r22, 0x01	; 1
    1ad8:	43 e9       	ldi	r20, 0x93	; 147
    1ada:	5c e0       	ldi	r21, 0x0C	; 12
    1adc:	0c 94 e6 03 	jmp	0x7cc	; 0x7cc <TCP_SetPortState>

00001ae0 <Endpoint_ConfigureEndpoint_Prv>:
#endif

bool Endpoint_ConfigureEndpoint_Prv(const uint8_t Number,
                                    const uint8_t UECFG0XData,
                                    const uint8_t UECFG1XData)
{
    1ae0:	38 2f       	mov	r19, r24
    1ae2:	28 2f       	mov	r18, r24
    1ae4:	2c c0       	rjmp	.+88     	; 0x1b3e <Endpoint_ConfigureEndpoint_Prv+0x5e>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    1ae6:	20 93 e9 00 	sts	0x00E9, r18
		uint8_t UECFG1XTemp;
		uint8_t UEIENXTemp;

		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
    1aea:	23 17       	cp	r18, r19
    1aec:	21 f4       	brne	.+8      	; 0x1af6 <Endpoint_ConfigureEndpoint_Prv+0x16>
    1aee:	76 2f       	mov	r23, r22
    1af0:	94 2f       	mov	r25, r20
    1af2:	50 e0       	ldi	r21, 0x00	; 0
    1af4:	06 c0       	rjmp	.+12     	; 0x1b02 <Endpoint_ConfigureEndpoint_Prv+0x22>
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
		}
		else
		{
			UECFG0XTemp = UECFG0X;
    1af6:	70 91 ec 00 	lds	r23, 0x00EC
			UECFG1XTemp = UECFG1X;
    1afa:	90 91 ed 00 	lds	r25, 0x00ED
			UEIENXTemp  = UEIENX;
    1afe:	50 91 f0 00 	lds	r21, 0x00F0
		}

		if (!(UECFG1XTemp & (1 << ALLOC)))
    1b02:	91 ff       	sbrs	r25, 1
    1b04:	1b c0       	rjmp	.+54     	; 0x1b3c <Endpoint_ConfigureEndpoint_Prv+0x5c>
			 *  to and from a host.
			 */
			static inline void Endpoint_DisableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_DisableEndpoint(void)
			{
				UECONX &= ~(1 << EPEN);
    1b06:	80 91 eb 00 	lds	r24, 0x00EB
    1b0a:	8e 7f       	andi	r24, 0xFE	; 254
    1b0c:	80 93 eb 00 	sts	0x00EB, r24
		  continue;

		Endpoint_DisableEndpoint();
		UECFG1X &= ~(1 << ALLOC);
    1b10:	80 91 ed 00 	lds	r24, 0x00ED
    1b14:	8d 7f       	andi	r24, 0xFD	; 253
    1b16:	80 93 ed 00 	sts	0x00ED, r24
			 *  \note Endpoints must first be configured properly via \ref Endpoint_ConfigureEndpoint().
			 */
			static inline void Endpoint_EnableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_EnableEndpoint(void)
			{
				UECONX |= (1 << EPEN);
    1b1a:	80 91 eb 00 	lds	r24, 0x00EB
    1b1e:	81 60       	ori	r24, 0x01	; 1
    1b20:	80 93 eb 00 	sts	0x00EB, r24

		Endpoint_EnableEndpoint();
		UECFG0X = UECFG0XTemp;
    1b24:	70 93 ec 00 	sts	0x00EC, r23
		UECFG1X = UECFG1XTemp;
    1b28:	90 93 ed 00 	sts	0x00ED, r25
		UEIENX  = UEIENXTemp;
    1b2c:	50 93 f0 00 	sts	0x00F0, r21
			 *  \return Boolean \c true if the currently selected endpoint has been configured, \c false otherwise.
			 */
			static inline bool Endpoint_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsConfigured(void)
			{
				return ((UESTA0X & (1 << CFGOK)) ? true : false);
    1b30:	80 91 ee 00 	lds	r24, 0x00EE

		if (!(Endpoint_IsConfigured()))
    1b34:	87 fd       	sbrc	r24, 7
    1b36:	02 c0       	rjmp	.+4      	; 0x1b3c <Endpoint_ConfigureEndpoint_Prv+0x5c>
    1b38:	80 e0       	ldi	r24, 0x00	; 0
    1b3a:	08 95       	ret
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    1b3c:	2f 5f       	subi	r18, 0xFF	; 255
    1b3e:	27 30       	cpi	r18, 0x07	; 7
    1b40:	90 f2       	brcs	.-92     	; 0x1ae6 <Endpoint_ConfigureEndpoint_Prv+0x6>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    1b42:	30 93 e9 00 	sts	0x00E9, r19
    1b46:	81 e0       	ldi	r24, 0x01	; 1
	}

	Endpoint_SelectEndpoint(Number);
	return true;
#endif
}
    1b48:	08 95       	ret

00001b4a <Endpoint_ClearStatusStage>:
	}
}

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    1b4a:	80 91 01 14 	lds	r24, 0x1401
    1b4e:	88 23       	and	r24, r24
    1b50:	9c f4       	brge	.+38     	; 0x1b78 <Endpoint_ClearStatusStage+0x2e>
    1b52:	04 c0       	rjmp	.+8      	; 0x1b5c <Endpoint_ClearStatusStage+0x12>
	{
		while (!(Endpoint_IsOUTReceived()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    1b54:	80 91 00 14 	lds	r24, 0x1400
    1b58:	88 23       	and	r24, r24
    1b5a:	b9 f0       	breq	.+46     	; 0x1b8a <Endpoint_ClearStatusStage+0x40>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1b5c:	80 91 e8 00 	lds	r24, 0x00E8

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
	{
		while (!(Endpoint_IsOUTReceived()))
    1b60:	82 ff       	sbrs	r24, 2
    1b62:	f8 cf       	rjmp	.-16     	; 0x1b54 <Endpoint_ClearStatusStage+0xa>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    1b64:	80 91 e8 00 	lds	r24, 0x00E8
    1b68:	8b 77       	andi	r24, 0x7B	; 123
    1b6a:	80 93 e8 00 	sts	0x00E8, r24
    1b6e:	08 95       	ret
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    1b70:	80 91 00 14 	lds	r24, 0x1400
    1b74:	88 23       	and	r24, r24
    1b76:	49 f0       	breq	.+18     	; 0x1b8a <Endpoint_ClearStatusStage+0x40>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1b78:	80 91 e8 00 	lds	r24, 0x00E8

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    1b7c:	80 ff       	sbrs	r24, 0
    1b7e:	f8 cf       	rjmp	.-16     	; 0x1b70 <Endpoint_ClearStatusStage+0x26>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1b80:	80 91 e8 00 	lds	r24, 0x00E8
    1b84:	8e 77       	andi	r24, 0x7E	; 126
    1b86:	80 93 e8 00 	sts	0x00E8, r24
    1b8a:	08 95       	ret

00001b8c <Endpoint_WaitUntilReady>:
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
    1b8c:	40 91 e4 00 	lds	r20, 0x00E4
    1b90:	50 91 e5 00 	lds	r21, 0x00E5
    1b94:	24 e6       	ldi	r18, 0x64	; 100
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    1b96:	80 91 ec 00 	lds	r24, 0x00EC
    1b9a:	80 ff       	sbrs	r24, 0
    1b9c:	24 c0       	rjmp	.+72     	; 0x1be6 <Endpoint_WaitUntilReady+0x5a>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1b9e:	80 91 e8 00 	lds	r24, 0x00E8

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
    1ba2:	80 fd       	sbrc	r24, 0
    1ba4:	1e c0       	rjmp	.+60     	; 0x1be2 <Endpoint_WaitUntilReady+0x56>
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1ba6:	80 91 00 14 	lds	r24, 0x1400

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1baa:	88 23       	and	r24, r24
    1bac:	11 f4       	brne	.+4      	; 0x1bb2 <Endpoint_WaitUntilReady+0x26>
    1bae:	82 e0       	ldi	r24, 0x02	; 2
    1bb0:	08 95       	ret
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1bb2:	85 30       	cpi	r24, 0x05	; 5
    1bb4:	11 f4       	brne	.+4      	; 0x1bba <Endpoint_WaitUntilReady+0x2e>
    1bb6:	83 e0       	ldi	r24, 0x03	; 3
    1bb8:	08 95       	ret
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    1bba:	80 91 eb 00 	lds	r24, 0x00EB
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    1bbe:	85 ff       	sbrs	r24, 5
    1bc0:	02 c0       	rjmp	.+4      	; 0x1bc6 <Endpoint_WaitUntilReady+0x3a>
    1bc2:	81 e0       	ldi	r24, 0x01	; 1
    1bc4:	08 95       	ret
    1bc6:	80 91 e4 00 	lds	r24, 0x00E4
    1bca:	90 91 e5 00 	lds	r25, 0x00E5
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    1bce:	84 17       	cp	r24, r20
    1bd0:	95 07       	cpc	r25, r21
    1bd2:	09 f3       	breq	.-62     	; 0x1b96 <Endpoint_WaitUntilReady+0xa>
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    1bd4:	22 23       	and	r18, r18
    1bd6:	11 f4       	brne	.+4      	; 0x1bdc <Endpoint_WaitUntilReady+0x50>
    1bd8:	84 e0       	ldi	r24, 0x04	; 4
    1bda:	08 95       	ret
    1bdc:	21 50       	subi	r18, 0x01	; 1
    1bde:	ac 01       	movw	r20, r24
    1be0:	da cf       	rjmp	.-76     	; 0x1b96 <Endpoint_WaitUntilReady+0xa>
    1be2:	80 e0       	ldi	r24, 0x00	; 0
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
    1be4:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1be6:	80 91 e8 00 	lds	r24, 0x00E8
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    1bea:	82 ff       	sbrs	r24, 2
    1bec:	dc cf       	rjmp	.-72     	; 0x1ba6 <Endpoint_WaitUntilReady+0x1a>
    1bee:	f9 cf       	rjmp	.-14     	; 0x1be2 <Endpoint_WaitUntilReady+0x56>

00001bf0 <USB_ResetInterface>:

void USB_ResetInterface(void)
{
    1bf0:	ef 92       	push	r14
    1bf2:	ff 92       	push	r15
    1bf4:	0f 93       	push	r16
    1bf6:	1f 93       	push	r17
	#if defined(USB_CAN_BE_BOTH)
	bool UIDModeSelectEnabled = ((UHWCON & (1 << UIDE)) != 0);
	#endif

	USB_INT_DisableAllInterrupts();
    1bf8:	4d d0       	rcall	.+154    	; 0x1c94 <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    1bfa:	54 d0       	rcall	.+168    	; 0x1ca4 <USB_INT_ClearAllInterrupts>
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				USBCON &= ~(1 << USBE);
    1bfc:	08 ed       	ldi	r16, 0xD8	; 216
    1bfe:	10 e0       	ldi	r17, 0x00	; 0
    1c00:	f8 01       	movw	r30, r16
    1c02:	80 81       	ld	r24, Z
    1c04:	8f 77       	andi	r24, 0x7F	; 127
    1c06:	80 83       	st	Z, r24
				USBCON |=  (1 << USBE);
    1c08:	80 81       	ld	r24, Z
    1c0a:	80 68       	ori	r24, 0x80	; 128
    1c0c:	80 83       	st	Z, r24
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    1c0e:	80 81       	ld	r24, Z
    1c10:	8f 7d       	andi	r24, 0xDF	; 223
    1c12:	80 83       	st	Z, r24

	if (USB_CurrentMode == USB_MODE_Device)
	{
		#if defined(USB_CAN_BE_DEVICE)
		#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
		UHWCON |=  (1 << UIMOD);
    1c14:	e7 ed       	ldi	r30, 0xD7	; 215
    1c16:	f0 e0       	ldi	r31, 0x00	; 0
    1c18:	80 81       	ld	r24, Z
    1c1a:	80 68       	ori	r24, 0x80	; 128
    1c1c:	80 83       	st	Z, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    1c1e:	19 bc       	out	0x29, r1	; 41
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState                 = DEVICE_STATE_Unattached;
    1c20:	10 92 00 14 	sts	0x1400, r1
	USB_Device_ConfigurationNumber  = 0;
    1c24:	10 92 fc 13 	sts	0x13FC, r1

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_Device_RemoteWakeupEnabled  = false;
    1c28:	10 92 fe 13 	sts	0x13FE, r1
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_Device_CurrentlySelfPowered = false;
    1c2c:	10 92 fd 13 	sts	0x13FD, r1
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				UDCON &= ~(1 << LSM);
    1c30:	80 ee       	ldi	r24, 0xE0	; 224
    1c32:	e8 2e       	mov	r14, r24
    1c34:	f1 2c       	mov	r15, r1
    1c36:	f7 01       	movw	r30, r14
    1c38:	80 81       	ld	r24, Z
    1c3a:	8b 7f       	andi	r24, 0xFB	; 251
    1c3c:	80 83       	st	Z, r24
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBCON |= (1 << VBUSTE);
    1c3e:	f8 01       	movw	r30, r16
    1c40:	80 81       	ld	r24, Z
    1c42:	81 60       	ori	r24, 0x01	; 1
    1c44:	80 83       	st	Z, r24
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | (Direction ? (1 << EPDIR) : 0)),
    1c46:	80 e0       	ldi	r24, 0x00	; 0
    1c48:	60 e0       	ldi	r22, 0x00	; 0
    1c4a:	42 e0       	ldi	r20, 0x02	; 2
    1c4c:	49 df       	rcall	.-366    	; 0x1ae0 <Endpoint_ConfigureEndpoint_Prv>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    1c4e:	e1 ee       	ldi	r30, 0xE1	; 225
    1c50:	f0 e0       	ldi	r31, 0x00	; 0
    1c52:	80 81       	ld	r24, Z
    1c54:	8e 7f       	andi	r24, 0xFE	; 254
    1c56:	80 83       	st	Z, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    1c58:	e2 ee       	ldi	r30, 0xE2	; 226
    1c5a:	f0 e0       	ldi	r31, 0x00	; 0
    1c5c:	80 81       	ld	r24, Z
    1c5e:	81 60       	ori	r24, 0x01	; 1
    1c60:	80 83       	st	Z, r24
						break;
					case USB_INT_EORSTI:
						UDIEN  |= (1 << EORSTE);
    1c62:	80 81       	ld	r24, Z
    1c64:	88 60       	ori	r24, 0x08	; 8
    1c66:	80 83       	st	Z, r24
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				UDCON  &= ~(1 << DETACH);
    1c68:	f7 01       	movw	r30, r14
    1c6a:	80 81       	ld	r24, Z
    1c6c:	8e 7f       	andi	r24, 0xFE	; 254
    1c6e:	80 83       	st	Z, r24

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON |=  (1 << OTGPADE);
    1c70:	f8 01       	movw	r30, r16
    1c72:	80 81       	ld	r24, Z
    1c74:	80 61       	ori	r24, 0x10	; 16
    1c76:	80 83       	st	Z, r24
	}

	#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
	USB_OTGPAD_On();
	#endif
}
    1c78:	1f 91       	pop	r17
    1c7a:	0f 91       	pop	r16
    1c7c:	ff 90       	pop	r15
    1c7e:	ef 90       	pop	r14
    1c80:	08 95       	ret

00001c82 <USB_Init>:

			static inline void USB_REG_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON |=  (1 << UVREGE);
    1c82:	e7 ed       	ldi	r30, 0xD7	; 215
    1c84:	f0 e0       	ldi	r31, 0x00	; 0
    1c86:	80 81       	ld	r24, Z
    1c88:	81 60       	ori	r24, 0x01	; 1
    1c8a:	80 83       	st	Z, r24
		UHWCON &= ~(1 << UIDE);
		USB_CurrentMode = Mode;
	}
	#endif

	USB_IsInitialized = true;
    1c8c:	81 e0       	ldi	r24, 0x01	; 1
    1c8e:	80 93 ff 13 	sts	0x13FF, r24

	USB_ResetInterface();
}
    1c92:	ae cf       	rjmp	.-164    	; 0x1bf0 <USB_ResetInterface>

00001c94 <USB_INT_DisableAllInterrupts>:
#include "../USBInterrupt.h"

void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));
    1c94:	e8 ed       	ldi	r30, 0xD8	; 216
    1c96:	f0 e0       	ldi	r31, 0x00	; 0
    1c98:	80 81       	ld	r24, Z
    1c9a:	8c 7f       	andi	r24, 0xFC	; 252
    1c9c:	80 83       	st	Z, r24
	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
    1c9e:	10 92 e2 00 	sts	0x00E2, r1
	#endif
}
    1ca2:	08 95       	ret

00001ca4 <USB_INT_ClearAllInterrupts>:

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT = 0;
    1ca4:	10 92 da 00 	sts	0x00DA, r1
	#if defined(USB_CAN_BE_HOST)
	UHINT  = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDINT  = 0;
    1ca8:	10 92 e1 00 	sts	0x00E1, r1
	#endif
}
    1cac:	08 95       	ret

00001cae <__vector_10>:

ISR(USB_GEN_vect, ISR_BLOCK)
{
    1cae:	1f 92       	push	r1
    1cb0:	0f 92       	push	r0
    1cb2:	0f b6       	in	r0, 0x3f	; 63
    1cb4:	0f 92       	push	r0
    1cb6:	0b b6       	in	r0, 0x3b	; 59
    1cb8:	0f 92       	push	r0
    1cba:	11 24       	eor	r1, r1
    1cbc:	2f 93       	push	r18
    1cbe:	3f 93       	push	r19
    1cc0:	4f 93       	push	r20
    1cc2:	5f 93       	push	r21
    1cc4:	6f 93       	push	r22
    1cc6:	7f 93       	push	r23
    1cc8:	8f 93       	push	r24
    1cca:	9f 93       	push	r25
    1ccc:	af 93       	push	r26
    1cce:	bf 93       	push	r27
    1cd0:	ef 93       	push	r30
    1cd2:	ff 93       	push	r31
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
					case USB_INT_SOFI:
						return (UDINT  & (1 << SOFI));
    1cd4:	80 91 e1 00 	lds	r24, 0x00E1
	#if defined(USB_CAN_BE_DEVICE)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    1cd8:	82 ff       	sbrs	r24, 2
    1cda:	0a c0       	rjmp	.+20     	; 0x1cf0 <__vector_10+0x42>
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
					case USB_INT_SOFI:
						return (UDIEN  & (1 << SOFE));
    1cdc:	80 91 e2 00 	lds	r24, 0x00E2
    1ce0:	82 ff       	sbrs	r24, 2
    1ce2:	06 c0       	rjmp	.+12     	; 0x1cf0 <__vector_10+0x42>
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
						break;
					case USB_INT_SOFI:
						UDINT  &= ~(1 << SOFI);
    1ce4:	80 91 e1 00 	lds	r24, 0x00E1
    1ce8:	8b 7f       	andi	r24, 0xFB	; 251
    1cea:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
    1cee:	bb d3       	rcall	.+1910   	; 0x2466 <USB_Event_Stub>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
    1cf0:	80 91 da 00 	lds	r24, 0x00DA
	}
	#endif

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUSTI) && USB_INT_IsEnabled(USB_INT_VBUSTI))
    1cf4:	80 ff       	sbrs	r24, 0
    1cf6:	1f c0       	rjmp	.+62     	; 0x1d36 <__vector_10+0x88>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
    1cf8:	80 91 d8 00 	lds	r24, 0x00D8
    1cfc:	80 ff       	sbrs	r24, 0
    1cfe:	1b c0       	rjmp	.+54     	; 0x1d36 <__vector_10+0x88>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBINT &= ~(1 << VBUSTI);
    1d00:	80 91 da 00 	lds	r24, 0x00DA
    1d04:	8e 7f       	andi	r24, 0xFE	; 254
    1d06:	80 93 da 00 	sts	0x00DA, r24
				 *  \return Boolean \c true if the VBUS line is currently detecting power from a host, \c false otherwise.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
    1d0a:	80 91 d9 00 	lds	r24, 0x00D9
	{
		USB_INT_Clear(USB_INT_VBUSTI);

		if (USB_VBUS_GetStatus())
    1d0e:	80 ff       	sbrs	r24, 0
    1d10:	0d c0       	rjmp	.+26     	; 0x1d2c <__vector_10+0x7e>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    1d12:	8c e0       	ldi	r24, 0x0C	; 12
    1d14:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    1d16:	8e e0       	ldi	r24, 0x0E	; 14
    1d18:	89 bd       	out	0x29, r24	; 41
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			{
				USB_PLL_On();
				while (!(USB_PLL_IsReady()));
    1d1a:	09 b4       	in	r0, 0x29	; 41
    1d1c:	00 fe       	sbrs	r0, 0
    1d1e:	fd cf       	rjmp	.-6      	; 0x1d1a <__vector_10+0x6c>
			}

			USB_DeviceState = DEVICE_STATE_Powered;
    1d20:	81 e0       	ldi	r24, 0x01	; 1
    1d22:	80 93 00 14 	sts	0x1400, r24
			EVENT_USB_Device_Connect();
    1d26:	0e 94 30 02 	call	0x460	; 0x460 <EVENT_USB_Device_Connect>
    1d2a:	05 c0       	rjmp	.+10     	; 0x1d36 <__vector_10+0x88>
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    1d2c:	19 bc       	out	0x29, r1	; 41
		else
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			  USB_PLL_Off();

			USB_DeviceState = DEVICE_STATE_Unattached;
    1d2e:	10 92 00 14 	sts	0x1400, r1
			EVENT_USB_Device_Disconnect();
    1d32:	0e 94 35 02 	call	0x46a	; 0x46a <EVENT_USB_Device_Disconnect>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
    1d36:	80 91 e1 00 	lds	r24, 0x00E1
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
    1d3a:	80 ff       	sbrs	r24, 0
    1d3c:	18 c0       	rjmp	.+48     	; 0x1d6e <__vector_10+0xc0>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
    1d3e:	80 91 e2 00 	lds	r24, 0x00E2
    1d42:	80 ff       	sbrs	r24, 0
    1d44:	14 c0       	rjmp	.+40     	; 0x1d6e <__vector_10+0xc0>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    1d46:	80 91 e2 00 	lds	r24, 0x00E2
    1d4a:	8e 7f       	andi	r24, 0xFE	; 254
    1d4c:	80 93 e2 00 	sts	0x00E2, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    1d50:	80 91 e2 00 	lds	r24, 0x00E2
    1d54:	80 61       	ori	r24, 0x10	; 16
    1d56:	80 93 e2 00 	sts	0x00E2, r24
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON |=  (1 << FRZCLK);
    1d5a:	80 91 d8 00 	lds	r24, 0x00D8
    1d5e:	80 62       	ori	r24, 0x20	; 32
    1d60:	80 93 d8 00 	sts	0x00D8, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    1d64:	19 bc       	out	0x29, r1	; 41

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
    1d66:	85 e0       	ldi	r24, 0x05	; 5
    1d68:	80 93 00 14 	sts	0x1400, r24
		EVENT_USB_Device_Suspend();
    1d6c:	7c d3       	rcall	.+1784   	; 0x2466 <USB_Event_Stub>
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
    1d6e:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
    1d72:	84 ff       	sbrs	r24, 4
    1d74:	2d c0       	rjmp	.+90     	; 0x1dd0 <__vector_10+0x122>
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
    1d76:	80 91 e2 00 	lds	r24, 0x00E2
    1d7a:	84 ff       	sbrs	r24, 4
    1d7c:	29 c0       	rjmp	.+82     	; 0x1dd0 <__vector_10+0x122>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    1d7e:	8c e0       	ldi	r24, 0x0C	; 12
    1d80:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    1d82:	8e e0       	ldi	r24, 0x0E	; 14
    1d84:	89 bd       	out	0x29, r24	; 41
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    1d86:	09 b4       	in	r0, 0x29	; 41
    1d88:	00 fe       	sbrs	r0, 0
    1d8a:	fd cf       	rjmp	.-6      	; 0x1d86 <__vector_10+0xd8>
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    1d8c:	80 91 d8 00 	lds	r24, 0x00D8
    1d90:	8f 7d       	andi	r24, 0xDF	; 223
    1d92:	80 93 d8 00 	sts	0x00D8, r24
						USBINT &= ~(1 << IDTI);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
    1d96:	80 91 e1 00 	lds	r24, 0x00E1
    1d9a:	8f 7e       	andi	r24, 0xEF	; 239
    1d9c:	80 93 e1 00 	sts	0x00E1, r24
						USBCON &= ~(1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
    1da0:	80 91 e2 00 	lds	r24, 0x00E2
    1da4:	8f 7e       	andi	r24, 0xEF	; 239
    1da6:	80 93 e2 00 	sts	0x00E2, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    1daa:	80 91 e2 00 	lds	r24, 0x00E2
    1dae:	81 60       	ori	r24, 0x01	; 1
    1db0:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Clear(USB_INT_WAKEUPI);

		USB_INT_Disable(USB_INT_WAKEUPI);
		USB_INT_Enable(USB_INT_SUSPI);

		if (USB_Device_ConfigurationNumber)
    1db4:	80 91 fc 13 	lds	r24, 0x13FC
    1db8:	88 23       	and	r24, r24
    1dba:	31 f4       	brne	.+12     	; 0x1dc8 <__vector_10+0x11a>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    1dbc:	80 91 e3 00 	lds	r24, 0x00E3
		  USB_DeviceState = DEVICE_STATE_Configured;
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    1dc0:	87 fd       	sbrc	r24, 7
    1dc2:	02 c0       	rjmp	.+4      	; 0x1dc8 <__vector_10+0x11a>
    1dc4:	81 e0       	ldi	r24, 0x01	; 1
    1dc6:	01 c0       	rjmp	.+2      	; 0x1dca <__vector_10+0x11c>
    1dc8:	84 e0       	ldi	r24, 0x04	; 4
    1dca:	80 93 00 14 	sts	0x1400, r24

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
    1dce:	4b d3       	rcall	.+1686   	; 0x2466 <USB_Event_Stub>
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
    1dd0:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
    1dd4:	83 ff       	sbrs	r24, 3
    1dd6:	22 c0       	rjmp	.+68     	; 0x1e1c <__vector_10+0x16e>
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
    1dd8:	80 91 e2 00 	lds	r24, 0x00E2
    1ddc:	83 ff       	sbrs	r24, 3
    1dde:	1e c0       	rjmp	.+60     	; 0x1e1c <__vector_10+0x16e>
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
    1de0:	80 91 e1 00 	lds	r24, 0x00E1
    1de4:	87 7f       	andi	r24, 0xF7	; 247
    1de6:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_EORSTI);

		USB_DeviceState                = DEVICE_STATE_Default;
    1dea:	82 e0       	ldi	r24, 0x02	; 2
    1dec:	80 93 00 14 	sts	0x1400, r24
		USB_Device_ConfigurationNumber = 0;
    1df0:	10 92 fc 13 	sts	0x13FC, r1
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    1df4:	80 91 e1 00 	lds	r24, 0x00E1
    1df8:	8e 7f       	andi	r24, 0xFE	; 254
    1dfa:	80 93 e1 00 	sts	0x00E1, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    1dfe:	80 91 e2 00 	lds	r24, 0x00E2
    1e02:	8e 7f       	andi	r24, 0xFE	; 254
    1e04:	80 93 e2 00 	sts	0x00E2, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    1e08:	80 91 e2 00 	lds	r24, 0x00E2
    1e0c:	80 61       	ori	r24, 0x10	; 16
    1e0e:	80 93 e2 00 	sts	0x00E2, r24
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | (Direction ? (1 << EPDIR) : 0)),
    1e12:	80 e0       	ldi	r24, 0x00	; 0
    1e14:	60 e0       	ldi	r22, 0x00	; 0
    1e16:	42 e0       	ldi	r20, 0x02	; 2
    1e18:	63 de       	rcall	.-826    	; 0x1ae0 <Endpoint_ConfigureEndpoint_Prv>

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
    1e1a:	25 d3       	rcall	.+1610   	; 0x2466 <USB_Event_Stub>
		USB_ResetInterface();

		EVENT_USB_UIDChange();
	}
	#endif
}
    1e1c:	ff 91       	pop	r31
    1e1e:	ef 91       	pop	r30
    1e20:	bf 91       	pop	r27
    1e22:	af 91       	pop	r26
    1e24:	9f 91       	pop	r25
    1e26:	8f 91       	pop	r24
    1e28:	7f 91       	pop	r23
    1e2a:	6f 91       	pop	r22
    1e2c:	5f 91       	pop	r21
    1e2e:	4f 91       	pop	r20
    1e30:	3f 91       	pop	r19
    1e32:	2f 91       	pop	r18
    1e34:	0f 90       	pop	r0
    1e36:	0b be       	out	0x3b, r0	; 59
    1e38:	0f 90       	pop	r0
    1e3a:	0f be       	out	0x3f, r0	; 63
    1e3c:	0f 90       	pop	r0
    1e3e:	1f 90       	pop	r1
    1e40:	18 95       	reti

00001e42 <Endpoint_Write_Control_Stream_LE>:
    1e42:	9c 01       	movw	r18, r24
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    1e44:	40 91 07 14 	lds	r20, 0x1407
    1e48:	50 91 08 14 	lds	r21, 0x1408
    1e4c:	46 17       	cp	r20, r22
    1e4e:	57 07       	cpc	r21, r23
    1e50:	18 f4       	brcc	.+6      	; 0x1e58 <Endpoint_Write_Control_Stream_LE+0x16>
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    1e52:	f9 01       	movw	r30, r18
    1e54:	90 e0       	ldi	r25, 0x00	; 0
    1e56:	3d c0       	rjmp	.+122    	; 0x1ed2 <Endpoint_Write_Control_Stream_LE+0x90>
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    1e58:	61 15       	cp	r22, r1
    1e5a:	71 05       	cpc	r23, r1
    1e5c:	11 f0       	breq	.+4      	; 0x1e62 <Endpoint_Write_Control_Stream_LE+0x20>
    1e5e:	ab 01       	movw	r20, r22
    1e60:	f8 cf       	rjmp	.-16     	; 0x1e52 <Endpoint_Write_Control_Stream_LE+0x10>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1e62:	80 91 e8 00 	lds	r24, 0x00E8
    1e66:	8e 77       	andi	r24, 0x7E	; 126
    1e68:	80 93 e8 00 	sts	0x00E8, r24
    1e6c:	40 e0       	ldi	r20, 0x00	; 0
    1e6e:	50 e0       	ldi	r21, 0x00	; 0
    1e70:	f0 cf       	rjmp	.-32     	; 0x1e52 <Endpoint_Write_Control_Stream_LE+0x10>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1e72:	80 91 00 14 	lds	r24, 0x1400

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1e76:	88 23       	and	r24, r24
    1e78:	f1 f1       	breq	.+124    	; 0x1ef6 <Endpoint_Write_Control_Stream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1e7a:	85 30       	cpi	r24, 0x05	; 5
    1e7c:	f1 f1       	breq	.+124    	; 0x1efa <Endpoint_Write_Control_Stream_LE+0xb8>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    1e7e:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    1e82:	83 ff       	sbrs	r24, 3
    1e84:	02 c0       	rjmp	.+4      	; 0x1e8a <Endpoint_Write_Control_Stream_LE+0x48>
    1e86:	81 e0       	ldi	r24, 0x01	; 1
    1e88:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1e8a:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    1e8e:	82 fd       	sbrc	r24, 2
    1e90:	2c c0       	rjmp	.+88     	; 0x1eea <Endpoint_Write_Control_Stream_LE+0xa8>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1e92:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    1e96:	80 ff       	sbrs	r24, 0
    1e98:	1c c0       	rjmp	.+56     	; 0x1ed2 <Endpoint_Write_Control_Stream_LE+0x90>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    1e9a:	20 91 f2 00 	lds	r18, 0x00F2
    1e9e:	30 91 f3 00 	lds	r19, 0x00F3
    1ea2:	07 c0       	rjmp	.+14     	; 0x1eb2 <Endpoint_Write_Control_Stream_LE+0x70>
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    1ea4:	81 91       	ld	r24, Z+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    1ea6:	80 93 f1 00 	sts	0x00F1, r24
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
    1eaa:	41 50       	subi	r20, 0x01	; 1
    1eac:	50 40       	sbci	r21, 0x00	; 0
				BytesInEndpoint++;
    1eae:	2f 5f       	subi	r18, 0xFF	; 255
    1eb0:	3f 4f       	sbci	r19, 0xFF	; 255

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    1eb2:	41 15       	cp	r20, r1
    1eb4:	51 05       	cpc	r21, r1
    1eb6:	19 f0       	breq	.+6      	; 0x1ebe <Endpoint_Write_Control_Stream_LE+0x7c>
    1eb8:	28 30       	cpi	r18, 0x08	; 8
    1eba:	31 05       	cpc	r19, r1
    1ebc:	98 f3       	brcs	.-26     	; 0x1ea4 <Endpoint_Write_Control_Stream_LE+0x62>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    1ebe:	90 e0       	ldi	r25, 0x00	; 0
    1ec0:	28 30       	cpi	r18, 0x08	; 8
    1ec2:	31 05       	cpc	r19, r1
    1ec4:	09 f4       	brne	.+2      	; 0x1ec8 <Endpoint_Write_Control_Stream_LE+0x86>
    1ec6:	91 e0       	ldi	r25, 0x01	; 1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1ec8:	80 91 e8 00 	lds	r24, 0x00E8
    1ecc:	8e 77       	andi	r24, 0x7E	; 126
    1ece:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    1ed2:	41 15       	cp	r20, r1
    1ed4:	51 05       	cpc	r21, r1
    1ed6:	69 f6       	brne	.-102    	; 0x1e72 <Endpoint_Write_Control_Stream_LE+0x30>
    1ed8:	99 23       	and	r25, r25
    1eda:	59 f6       	brne	.-106    	; 0x1e72 <Endpoint_Write_Control_Stream_LE+0x30>
    1edc:	06 c0       	rjmp	.+12     	; 0x1eea <Endpoint_Write_Control_Stream_LE+0xa8>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1ede:	80 91 00 14 	lds	r24, 0x1400

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1ee2:	88 23       	and	r24, r24
    1ee4:	41 f0       	breq	.+16     	; 0x1ef6 <Endpoint_Write_Control_Stream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1ee6:	85 30       	cpi	r24, 0x05	; 5
    1ee8:	41 f0       	breq	.+16     	; 0x1efa <Endpoint_Write_Control_Stream_LE+0xb8>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1eea:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    1eee:	82 ff       	sbrs	r24, 2
    1ef0:	f6 cf       	rjmp	.-20     	; 0x1ede <Endpoint_Write_Control_Stream_LE+0x9c>
    1ef2:	80 e0       	ldi	r24, 0x00	; 0
    1ef4:	08 95       	ret
    1ef6:	82 e0       	ldi	r24, 0x02	; 2
    1ef8:	08 95       	ret
    1efa:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    1efc:	08 95       	ret

00001efe <Endpoint_Read_Control_Stream_LE>:

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (void* const Buffer,
                            uint16_t Length)
{
    1efe:	9c 01       	movw	r18, r24
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
    1f00:	61 15       	cp	r22, r1
    1f02:	71 05       	cpc	r23, r1
    1f04:	29 f4       	brne	.+10     	; 0x1f10 <Endpoint_Read_Control_Stream_LE+0x12>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    1f06:	80 91 e8 00 	lds	r24, 0x00E8
    1f0a:	8b 77       	andi	r24, 0x7B	; 123
    1f0c:	80 93 e8 00 	sts	0x00E8, r24
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    1f10:	f9 01       	movw	r30, r18
    1f12:	22 c0       	rjmp	.+68     	; 0x1f58 <Endpoint_Read_Control_Stream_LE+0x5a>
	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1f14:	80 91 00 14 	lds	r24, 0x1400

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1f18:	88 23       	and	r24, r24
    1f1a:	71 f1       	breq	.+92     	; 0x1f78 <Endpoint_Read_Control_Stream_LE+0x7a>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1f1c:	85 30       	cpi	r24, 0x05	; 5
    1f1e:	71 f1       	breq	.+92     	; 0x1f7c <Endpoint_Read_Control_Stream_LE+0x7e>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    1f20:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    1f24:	83 ff       	sbrs	r24, 3
    1f26:	02 c0       	rjmp	.+4      	; 0x1f2c <Endpoint_Read_Control_Stream_LE+0x2e>
    1f28:	81 e0       	ldi	r24, 0x01	; 1
    1f2a:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1f2c:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
    1f30:	82 ff       	sbrs	r24, 2
    1f32:	f0 cf       	rjmp	.-32     	; 0x1f14 <Endpoint_Read_Control_Stream_LE+0x16>
    1f34:	06 c0       	rjmp	.+12     	; 0x1f42 <Endpoint_Read_Control_Stream_LE+0x44>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    1f36:	80 91 f1 00 	lds	r24, 0x00F1
		{
			while (Length && Endpoint_BytesInEndpoint())
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    1f3a:	81 93       	st	Z+, r24
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
    1f3c:	61 50       	subi	r22, 0x01	; 1
    1f3e:	70 40       	sbci	r23, 0x00	; 0
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
		{
			while (Length && Endpoint_BytesInEndpoint())
    1f40:	31 f0       	breq	.+12     	; 0x1f4e <Endpoint_Read_Control_Stream_LE+0x50>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    1f42:	80 91 f2 00 	lds	r24, 0x00F2
    1f46:	90 91 f3 00 	lds	r25, 0x00F3
    1f4a:	89 2b       	or	r24, r25
    1f4c:	a1 f7       	brne	.-24     	; 0x1f36 <Endpoint_Read_Control_Stream_LE+0x38>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    1f4e:	80 91 e8 00 	lds	r24, 0x00E8
    1f52:	8b 77       	andi	r24, 0x7B	; 123
    1f54:	80 93 e8 00 	sts	0x00E8, r24
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
    1f58:	61 15       	cp	r22, r1
    1f5a:	71 05       	cpc	r23, r1
    1f5c:	d9 f6       	brne	.-74     	; 0x1f14 <Endpoint_Read_Control_Stream_LE+0x16>
    1f5e:	06 c0       	rjmp	.+12     	; 0x1f6c <Endpoint_Read_Control_Stream_LE+0x6e>
		}
	}

	while (!(Endpoint_IsINReady()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1f60:	80 91 00 14 	lds	r24, 0x1400

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1f64:	88 23       	and	r24, r24
    1f66:	41 f0       	breq	.+16     	; 0x1f78 <Endpoint_Read_Control_Stream_LE+0x7a>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1f68:	85 30       	cpi	r24, 0x05	; 5
    1f6a:	41 f0       	breq	.+16     	; 0x1f7c <Endpoint_Read_Control_Stream_LE+0x7e>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1f6c:	80 91 e8 00 	lds	r24, 0x00E8

			Endpoint_ClearOUT();
		}
	}

	while (!(Endpoint_IsINReady()))
    1f70:	80 ff       	sbrs	r24, 0
    1f72:	f6 cf       	rjmp	.-20     	; 0x1f60 <Endpoint_Read_Control_Stream_LE+0x62>
    1f74:	80 e0       	ldi	r24, 0x00	; 0
    1f76:	08 95       	ret
    1f78:	82 e0       	ldi	r24, 0x02	; 2
    1f7a:	08 95       	ret
    1f7c:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    1f7e:	08 95       	ret

00001f80 <Endpoint_Write_Control_PStream_LE>:

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
    1f80:	9c 01       	movw	r18, r24
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    1f82:	40 91 07 14 	lds	r20, 0x1407
    1f86:	50 91 08 14 	lds	r21, 0x1408
    1f8a:	46 17       	cp	r20, r22
    1f8c:	57 07       	cpc	r21, r23
    1f8e:	18 f4       	brcc	.+6      	; 0x1f96 <Endpoint_Write_Control_PStream_LE+0x16>
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    1f90:	f9 01       	movw	r30, r18
    1f92:	90 e0       	ldi	r25, 0x00	; 0
    1f94:	40 c0       	rjmp	.+128    	; 0x2016 <Endpoint_Write_Control_PStream_LE+0x96>
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    1f96:	61 15       	cp	r22, r1
    1f98:	71 05       	cpc	r23, r1
    1f9a:	11 f0       	breq	.+4      	; 0x1fa0 <Endpoint_Write_Control_PStream_LE+0x20>
    1f9c:	ab 01       	movw	r20, r22
    1f9e:	f8 cf       	rjmp	.-16     	; 0x1f90 <Endpoint_Write_Control_PStream_LE+0x10>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1fa0:	80 91 e8 00 	lds	r24, 0x00E8
    1fa4:	8e 77       	andi	r24, 0x7E	; 126
    1fa6:	80 93 e8 00 	sts	0x00E8, r24
    1faa:	40 e0       	ldi	r20, 0x00	; 0
    1fac:	50 e0       	ldi	r21, 0x00	; 0
    1fae:	f0 cf       	rjmp	.-32     	; 0x1f90 <Endpoint_Write_Control_PStream_LE+0x10>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1fb0:	80 91 00 14 	lds	r24, 0x1400

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1fb4:	88 23       	and	r24, r24
    1fb6:	09 f4       	brne	.+2      	; 0x1fba <Endpoint_Write_Control_PStream_LE+0x3a>
    1fb8:	40 c0       	rjmp	.+128    	; 0x203a <Endpoint_Write_Control_PStream_LE+0xba>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1fba:	85 30       	cpi	r24, 0x05	; 5
    1fbc:	09 f4       	brne	.+2      	; 0x1fc0 <Endpoint_Write_Control_PStream_LE+0x40>
    1fbe:	3f c0       	rjmp	.+126    	; 0x203e <Endpoint_Write_Control_PStream_LE+0xbe>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    1fc0:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    1fc4:	83 ff       	sbrs	r24, 3
    1fc6:	02 c0       	rjmp	.+4      	; 0x1fcc <Endpoint_Write_Control_PStream_LE+0x4c>
    1fc8:	81 e0       	ldi	r24, 0x01	; 1
    1fca:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1fcc:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    1fd0:	82 fd       	sbrc	r24, 2
    1fd2:	2d c0       	rjmp	.+90     	; 0x202e <Endpoint_Write_Control_PStream_LE+0xae>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1fd4:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    1fd8:	80 ff       	sbrs	r24, 0
    1fda:	1d c0       	rjmp	.+58     	; 0x2016 <Endpoint_Write_Control_PStream_LE+0x96>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    1fdc:	20 91 f2 00 	lds	r18, 0x00F2
    1fe0:	30 91 f3 00 	lds	r19, 0x00F3
    1fe4:	08 c0       	rjmp	.+16     	; 0x1ff6 <Endpoint_Write_Control_PStream_LE+0x76>
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    1fe6:	84 91       	lpm	r24, Z+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    1fe8:	80 93 f1 00 	sts	0x00F1, r24
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    1fec:	31 96       	adiw	r30, 0x01	; 1
				Length--;
    1fee:	41 50       	subi	r20, 0x01	; 1
    1ff0:	50 40       	sbci	r21, 0x00	; 0
				BytesInEndpoint++;
    1ff2:	2f 5f       	subi	r18, 0xFF	; 255
    1ff4:	3f 4f       	sbci	r19, 0xFF	; 255

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    1ff6:	41 15       	cp	r20, r1
    1ff8:	51 05       	cpc	r21, r1
    1ffa:	19 f0       	breq	.+6      	; 0x2002 <Endpoint_Write_Control_PStream_LE+0x82>
    1ffc:	28 30       	cpi	r18, 0x08	; 8
    1ffe:	31 05       	cpc	r19, r1
    2000:	90 f3       	brcs	.-28     	; 0x1fe6 <Endpoint_Write_Control_PStream_LE+0x66>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    2002:	90 e0       	ldi	r25, 0x00	; 0
    2004:	28 30       	cpi	r18, 0x08	; 8
    2006:	31 05       	cpc	r19, r1
    2008:	09 f4       	brne	.+2      	; 0x200c <Endpoint_Write_Control_PStream_LE+0x8c>
    200a:	91 e0       	ldi	r25, 0x01	; 1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    200c:	80 91 e8 00 	lds	r24, 0x00E8
    2010:	8e 77       	andi	r24, 0x7E	; 126
    2012:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    2016:	41 15       	cp	r20, r1
    2018:	51 05       	cpc	r21, r1
    201a:	51 f6       	brne	.-108    	; 0x1fb0 <Endpoint_Write_Control_PStream_LE+0x30>
    201c:	99 23       	and	r25, r25
    201e:	41 f6       	brne	.-112    	; 0x1fb0 <Endpoint_Write_Control_PStream_LE+0x30>
    2020:	06 c0       	rjmp	.+12     	; 0x202e <Endpoint_Write_Control_PStream_LE+0xae>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2022:	80 91 00 14 	lds	r24, 0x1400

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    2026:	88 23       	and	r24, r24
    2028:	41 f0       	breq	.+16     	; 0x203a <Endpoint_Write_Control_PStream_LE+0xba>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    202a:	85 30       	cpi	r24, 0x05	; 5
    202c:	41 f0       	breq	.+16     	; 0x203e <Endpoint_Write_Control_PStream_LE+0xbe>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    202e:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    2032:	82 ff       	sbrs	r24, 2
    2034:	f6 cf       	rjmp	.-20     	; 0x2022 <Endpoint_Write_Control_PStream_LE+0xa2>
    2036:	80 e0       	ldi	r24, 0x00	; 0
    2038:	08 95       	ret
    203a:	82 e0       	ldi	r24, 0x02	; 2
    203c:	08 95       	ret
    203e:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    2040:	08 95       	ret

00002042 <Endpoint_Read_Stream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    2042:	bf 92       	push	r11
    2044:	cf 92       	push	r12
    2046:	df 92       	push	r13
    2048:	ef 92       	push	r14
    204a:	ff 92       	push	r15
    204c:	0f 93       	push	r16
    204e:	1f 93       	push	r17
    2050:	cf 93       	push	r28
    2052:	df 93       	push	r29
    2054:	18 2f       	mov	r17, r24
    2056:	09 2f       	mov	r16, r25
    2058:	7b 01       	movw	r14, r22
    205a:	6a 01       	movw	r12, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    205c:	97 dd       	rcall	.-1234   	; 0x1b8c <Endpoint_WaitUntilReady>
    205e:	b8 2e       	mov	r11, r24
    2060:	88 23       	and	r24, r24
    2062:	b1 f5       	brne	.+108    	; 0x20d0 <Endpoint_Read_Stream_LE+0x8e>

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    2064:	81 2f       	mov	r24, r17
    2066:	90 2f       	mov	r25, r16
    2068:	9c 01       	movw	r18, r24
    206a:	e9 01       	movw	r28, r18
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
	  return ErrorCode;

	if (BytesProcessed != NULL)
    206c:	c1 14       	cp	r12, r1
    206e:	d1 04       	cpc	r13, r1
    2070:	39 f0       	breq	.+14     	; 0x2080 <Endpoint_Read_Stream_LE+0x3e>
	{
		Length -= *BytesProcessed;
    2072:	f6 01       	movw	r30, r12
    2074:	80 81       	ld	r24, Z
    2076:	91 81       	ldd	r25, Z+1	; 0x01
    2078:	e8 1a       	sub	r14, r24
    207a:	f9 0a       	sbc	r15, r25
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    207c:	c8 0f       	add	r28, r24
    207e:	d9 1f       	adc	r29, r25
    2080:	00 e0       	ldi	r16, 0x00	; 0
    2082:	10 e0       	ldi	r17, 0x00	; 0
    2084:	22 c0       	rjmp	.+68     	; 0x20ca <Endpoint_Read_Stream_LE+0x88>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    2086:	80 91 e8 00 	lds	r24, 0x00E8
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    208a:	85 fd       	sbrc	r24, 5
    208c:	16 c0       	rjmp	.+44     	; 0x20ba <Endpoint_Read_Stream_LE+0x78>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    208e:	80 91 e8 00 	lds	r24, 0x00E8
    2092:	8b 77       	andi	r24, 0x7B	; 123
    2094:	80 93 e8 00 	sts	0x00E8, r24
		{
			TEMPLATE_CLEAR_ENDPOINT();

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
    2098:	e7 d1       	rcall	.+974    	; 0x2468 <USB_USBTask>
			#endif

			if (BytesProcessed != NULL)
    209a:	c1 14       	cp	r12, r1
    209c:	d1 04       	cpc	r13, r1
    209e:	49 f0       	breq	.+18     	; 0x20b2 <Endpoint_Read_Stream_LE+0x70>
			{
				*BytesProcessed += BytesInTransfer;
    20a0:	f6 01       	movw	r30, r12
    20a2:	80 81       	ld	r24, Z
    20a4:	91 81       	ldd	r25, Z+1	; 0x01
    20a6:	80 0f       	add	r24, r16
    20a8:	91 1f       	adc	r25, r17
    20aa:	91 83       	std	Z+1, r25	; 0x01
    20ac:	80 83       	st	Z, r24
    20ae:	85 e0       	ldi	r24, 0x05	; 5
    20b0:	10 c0       	rjmp	.+32     	; 0x20d2 <Endpoint_Read_Stream_LE+0x90>
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    20b2:	6c dd       	rcall	.-1320   	; 0x1b8c <Endpoint_WaitUntilReady>
    20b4:	88 23       	and	r24, r24
    20b6:	49 f0       	breq	.+18     	; 0x20ca <Endpoint_Read_Stream_LE+0x88>
    20b8:	0c c0       	rjmp	.+24     	; 0x20d2 <Endpoint_Read_Stream_LE+0x90>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    20ba:	80 91 f1 00 	lds	r24, 0x00F1
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    20be:	89 93       	st	Y+, r24
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    20c0:	08 94       	sec
    20c2:	e1 08       	sbc	r14, r1
    20c4:	f1 08       	sbc	r15, r1
			BytesInTransfer++;
    20c6:	0f 5f       	subi	r16, 0xFF	; 255
    20c8:	1f 4f       	sbci	r17, 0xFF	; 255
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    20ca:	e1 14       	cp	r14, r1
    20cc:	f1 04       	cpc	r15, r1
    20ce:	d9 f6       	brne	.-74     	; 0x2086 <Endpoint_Read_Stream_LE+0x44>
    20d0:	8b 2d       	mov	r24, r11
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    20d2:	df 91       	pop	r29
    20d4:	cf 91       	pop	r28
    20d6:	1f 91       	pop	r17
    20d8:	0f 91       	pop	r16
    20da:	ff 90       	pop	r15
    20dc:	ef 90       	pop	r14
    20de:	df 90       	pop	r13
    20e0:	cf 90       	pop	r12
    20e2:	bf 90       	pop	r11
    20e4:	08 95       	ret

000020e6 <Endpoint_Write_Stream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    20e6:	bf 92       	push	r11
    20e8:	cf 92       	push	r12
    20ea:	df 92       	push	r13
    20ec:	ef 92       	push	r14
    20ee:	ff 92       	push	r15
    20f0:	0f 93       	push	r16
    20f2:	1f 93       	push	r17
    20f4:	cf 93       	push	r28
    20f6:	df 93       	push	r29
    20f8:	18 2f       	mov	r17, r24
    20fa:	09 2f       	mov	r16, r25
    20fc:	7b 01       	movw	r14, r22
    20fe:	6a 01       	movw	r12, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    2100:	45 dd       	rcall	.-1398   	; 0x1b8c <Endpoint_WaitUntilReady>
    2102:	b8 2e       	mov	r11, r24
    2104:	88 23       	and	r24, r24
    2106:	b1 f5       	brne	.+108    	; 0x2174 <__stack+0x75>

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    2108:	81 2f       	mov	r24, r17
    210a:	90 2f       	mov	r25, r16
    210c:	9c 01       	movw	r18, r24
    210e:	e9 01       	movw	r28, r18
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
	  return ErrorCode;

	if (BytesProcessed != NULL)
    2110:	c1 14       	cp	r12, r1
    2112:	d1 04       	cpc	r13, r1
    2114:	39 f0       	breq	.+14     	; 0x2124 <__stack+0x25>
	{
		Length -= *BytesProcessed;
    2116:	f6 01       	movw	r30, r12
    2118:	80 81       	ld	r24, Z
    211a:	91 81       	ldd	r25, Z+1	; 0x01
    211c:	e8 1a       	sub	r14, r24
    211e:	f9 0a       	sbc	r15, r25
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    2120:	c8 0f       	add	r28, r24
    2122:	d9 1f       	adc	r29, r25
    2124:	00 e0       	ldi	r16, 0x00	; 0
    2126:	10 e0       	ldi	r17, 0x00	; 0
    2128:	22 c0       	rjmp	.+68     	; 0x216e <__stack+0x6f>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    212a:	80 91 e8 00 	lds	r24, 0x00E8
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    212e:	85 fd       	sbrc	r24, 5
    2130:	16 c0       	rjmp	.+44     	; 0x215e <__stack+0x5f>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2132:	80 91 e8 00 	lds	r24, 0x00E8
    2136:	8e 77       	andi	r24, 0x7E	; 126
    2138:	80 93 e8 00 	sts	0x00E8, r24
		{
			TEMPLATE_CLEAR_ENDPOINT();

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
    213c:	95 d1       	rcall	.+810    	; 0x2468 <USB_USBTask>
			#endif

			if (BytesProcessed != NULL)
    213e:	c1 14       	cp	r12, r1
    2140:	d1 04       	cpc	r13, r1
    2142:	49 f0       	breq	.+18     	; 0x2156 <__stack+0x57>
			{
				*BytesProcessed += BytesInTransfer;
    2144:	f6 01       	movw	r30, r12
    2146:	80 81       	ld	r24, Z
    2148:	91 81       	ldd	r25, Z+1	; 0x01
    214a:	80 0f       	add	r24, r16
    214c:	91 1f       	adc	r25, r17
    214e:	91 83       	std	Z+1, r25	; 0x01
    2150:	80 83       	st	Z, r24
    2152:	85 e0       	ldi	r24, 0x05	; 5
    2154:	10 c0       	rjmp	.+32     	; 0x2176 <__stack+0x77>
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    2156:	1a dd       	rcall	.-1484   	; 0x1b8c <Endpoint_WaitUntilReady>
    2158:	88 23       	and	r24, r24
    215a:	49 f0       	breq	.+18     	; 0x216e <__stack+0x6f>
    215c:	0c c0       	rjmp	.+24     	; 0x2176 <__stack+0x77>
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    215e:	89 91       	ld	r24, Y+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    2160:	80 93 f1 00 	sts	0x00F1, r24
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    2164:	08 94       	sec
    2166:	e1 08       	sbc	r14, r1
    2168:	f1 08       	sbc	r15, r1
			BytesInTransfer++;
    216a:	0f 5f       	subi	r16, 0xFF	; 255
    216c:	1f 4f       	sbci	r17, 0xFF	; 255
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    216e:	e1 14       	cp	r14, r1
    2170:	f1 04       	cpc	r15, r1
    2172:	d9 f6       	brne	.-74     	; 0x212a <__stack+0x2b>
    2174:	8b 2d       	mov	r24, r11
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    2176:	df 91       	pop	r29
    2178:	cf 91       	pop	r28
    217a:	1f 91       	pop	r17
    217c:	0f 91       	pop	r16
    217e:	ff 90       	pop	r15
    2180:	ef 90       	pop	r14
    2182:	df 90       	pop	r13
    2184:	cf 90       	pop	r12
    2186:	bf 90       	pop	r11
    2188:	08 95       	ret

0000218a <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    218a:	0f 93       	push	r16
    218c:	1f 93       	push	r17
    218e:	df 93       	push	r29
    2190:	cf 93       	push	r28
    2192:	cd b7       	in	r28, 0x3d	; 61
    2194:	de b7       	in	r29, 0x3e	; 62
    2196:	ac 97       	sbiw	r28, 0x2c	; 44
    2198:	0f b6       	in	r0, 0x3f	; 63
    219a:	f8 94       	cli
    219c:	de bf       	out	0x3e, r29	; 62
    219e:	0f be       	out	0x3f, r0	; 63
    21a0:	cd bf       	out	0x3d, r28	; 61
    21a2:	e1 e0       	ldi	r30, 0x01	; 1
    21a4:	f4 e1       	ldi	r31, 0x14	; 20
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    21a6:	80 91 f1 00 	lds	r24, 0x00F1
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_8();
    21aa:	81 93       	st	Z+, r24
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    21ac:	24 e1       	ldi	r18, 0x14	; 20
    21ae:	e9 30       	cpi	r30, 0x09	; 9
    21b0:	f2 07       	cpc	r31, r18
    21b2:	c9 f7       	brne	.-14     	; 0x21a6 <USB_Device_ProcessControlRequest+0x1c>
	  *(RequestHeader++) = Endpoint_Read_8();
	#endif

	EVENT_USB_Device_ControlRequest();
    21b4:	0e 94 3a 02 	call	0x474	; 0x474 <EVENT_USB_Device_ControlRequest>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    21b8:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsSETUPReceived())
    21bc:	83 ff       	sbrs	r24, 3
    21be:	3a c1       	rjmp	.+628    	; 0x2434 <USB_Device_ProcessControlRequest+0x2aa>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    21c0:	80 91 01 14 	lds	r24, 0x1401

		switch (USB_ControlRequest.bRequest)
    21c4:	30 91 02 14 	lds	r19, 0x1402
    21c8:	35 30       	cpi	r19, 0x05	; 5
    21ca:	09 f4       	brne	.+2      	; 0x21ce <USB_Device_ProcessControlRequest+0x44>
    21cc:	87 c0       	rjmp	.+270    	; 0x22dc <USB_Device_ProcessControlRequest+0x152>
    21ce:	36 30       	cpi	r19, 0x06	; 6
    21d0:	40 f4       	brcc	.+16     	; 0x21e2 <USB_Device_ProcessControlRequest+0x58>
    21d2:	31 30       	cpi	r19, 0x01	; 1
    21d4:	c9 f1       	breq	.+114    	; 0x2248 <USB_Device_ProcessControlRequest+0xbe>
    21d6:	31 30       	cpi	r19, 0x01	; 1
    21d8:	70 f0       	brcs	.+28     	; 0x21f6 <USB_Device_ProcessControlRequest+0x6c>
    21da:	33 30       	cpi	r19, 0x03	; 3
    21dc:	09 f0       	breq	.+2      	; 0x21e0 <USB_Device_ProcessControlRequest+0x56>
    21de:	2a c1       	rjmp	.+596    	; 0x2434 <USB_Device_ProcessControlRequest+0x2aa>
    21e0:	33 c0       	rjmp	.+102    	; 0x2248 <USB_Device_ProcessControlRequest+0xbe>
    21e2:	38 30       	cpi	r19, 0x08	; 8
    21e4:	09 f4       	brne	.+2      	; 0x21e8 <USB_Device_ProcessControlRequest+0x5e>
    21e6:	f7 c0       	rjmp	.+494    	; 0x23d6 <USB_Device_ProcessControlRequest+0x24c>
    21e8:	39 30       	cpi	r19, 0x09	; 9
    21ea:	09 f4       	brne	.+2      	; 0x21ee <USB_Device_ProcessControlRequest+0x64>
    21ec:	06 c1       	rjmp	.+524    	; 0x23fa <USB_Device_ProcessControlRequest+0x270>
    21ee:	36 30       	cpi	r19, 0x06	; 6
    21f0:	09 f0       	breq	.+2      	; 0x21f4 <USB_Device_ProcessControlRequest+0x6a>
    21f2:	20 c1       	rjmp	.+576    	; 0x2434 <USB_Device_ProcessControlRequest+0x2aa>
    21f4:	97 c0       	rjmp	.+302    	; 0x2324 <USB_Device_ProcessControlRequest+0x19a>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    21f6:	80 38       	cpi	r24, 0x80	; 128
    21f8:	21 f0       	breq	.+8      	; 0x2202 <USB_Device_ProcessControlRequest+0x78>
    21fa:	82 38       	cpi	r24, 0x82	; 130
    21fc:	09 f0       	breq	.+2      	; 0x2200 <USB_Device_ProcessControlRequest+0x76>
    21fe:	1a c1       	rjmp	.+564    	; 0x2434 <USB_Device_ProcessControlRequest+0x2aa>
    2200:	08 c0       	rjmp	.+16     	; 0x2212 <USB_Device_ProcessControlRequest+0x88>
    2202:	90 91 fd 13 	lds	r25, 0x13FD
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
    2206:	80 91 fe 13 	lds	r24, 0x13FE
    220a:	88 23       	and	r24, r24
    220c:	99 f0       	breq	.+38     	; 0x2234 <USB_Device_ProcessControlRequest+0xaa>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    220e:	92 60       	ori	r25, 0x02	; 2
    2210:	11 c0       	rjmp	.+34     	; 0x2234 <USB_Device_ProcessControlRequest+0xaa>
			#endif
			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
			Endpoint_SelectEndpoint((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    2212:	80 91 05 14 	lds	r24, 0x1405
    2216:	8f 70       	andi	r24, 0x0F	; 15
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2218:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    221c:	80 91 eb 00 	lds	r24, 0x00EB

			CurrentStatus = Endpoint_IsStalled();
    2220:	90 e0       	ldi	r25, 0x00	; 0
    2222:	25 e0       	ldi	r18, 0x05	; 5
    2224:	96 95       	lsr	r25
    2226:	87 95       	ror	r24
    2228:	2a 95       	dec	r18
    222a:	e1 f7       	brne	.-8      	; 0x2224 <USB_Device_ProcessControlRequest+0x9a>
    222c:	98 2f       	mov	r25, r24
    222e:	91 70       	andi	r25, 0x01	; 1
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2230:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2234:	80 91 e8 00 	lds	r24, 0x00E8
    2238:	87 7f       	andi	r24, 0xF7	; 247
    223a:	80 93 e8 00 	sts	0x00E8, r24
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				UEDATX = (Data & 0xFF);
    223e:	90 93 f1 00 	sts	0x00F1, r25
				UEDATX = (Data >> 8);
    2242:	10 92 f1 00 	sts	0x00F1, r1
    2246:	d2 c0       	rjmp	.+420    	; 0x23ec <USB_Device_ProcessControlRequest+0x262>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    2248:	88 23       	and	r24, r24
    224a:	19 f0       	breq	.+6      	; 0x2252 <USB_Device_ProcessControlRequest+0xc8>
    224c:	82 30       	cpi	r24, 0x02	; 2
    224e:	09 f0       	breq	.+2      	; 0x2252 <USB_Device_ProcessControlRequest+0xc8>
    2250:	f1 c0       	rjmp	.+482    	; 0x2434 <USB_Device_ProcessControlRequest+0x2aa>
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
    2252:	90 e0       	ldi	r25, 0x00	; 0
    2254:	8f 71       	andi	r24, 0x1F	; 31
    2256:	90 70       	andi	r25, 0x00	; 0
    2258:	00 97       	sbiw	r24, 0x00	; 0
    225a:	21 f0       	breq	.+8      	; 0x2264 <USB_Device_ProcessControlRequest+0xda>
    225c:	02 97       	sbiw	r24, 0x02	; 2
    225e:	09 f0       	breq	.+2      	; 0x2262 <USB_Device_ProcessControlRequest+0xd8>
    2260:	e9 c0       	rjmp	.+466    	; 0x2434 <USB_Device_ProcessControlRequest+0x2aa>
    2262:	0c c0       	rjmp	.+24     	; 0x227c <USB_Device_ProcessControlRequest+0xf2>
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
    2264:	80 91 03 14 	lds	r24, 0x1403
    2268:	81 30       	cpi	r24, 0x01	; 1
    226a:	09 f0       	breq	.+2      	; 0x226e <USB_Device_ProcessControlRequest+0xe4>
    226c:	e3 c0       	rjmp	.+454    	; 0x2434 <USB_Device_ProcessControlRequest+0x2aa>
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    226e:	10 92 fe 13 	sts	0x13FE, r1
    2272:	33 30       	cpi	r19, 0x03	; 3
    2274:	69 f5       	brne	.+90     	; 0x22d0 <USB_Device_ProcessControlRequest+0x146>
    2276:	80 93 fe 13 	sts	0x13FE, r24
    227a:	2a c0       	rjmp	.+84     	; 0x22d0 <USB_Device_ProcessControlRequest+0x146>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    227c:	80 91 03 14 	lds	r24, 0x1403
    2280:	88 23       	and	r24, r24
    2282:	31 f5       	brne	.+76     	; 0x22d0 <USB_Device_ProcessControlRequest+0x146>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    2284:	20 91 05 14 	lds	r18, 0x1405
    2288:	2f 70       	andi	r18, 0x0F	; 15

				if (EndpointIndex == ENDPOINT_CONTROLEP)
    228a:	09 f4       	brne	.+2      	; 0x228e <USB_Device_ProcessControlRequest+0x104>
    228c:	d3 c0       	rjmp	.+422    	; 0x2434 <USB_Device_ProcessControlRequest+0x2aa>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    228e:	20 93 e9 00 	sts	0x00E9, r18
			 * \return Boolean \c true if the currently selected endpoint is enabled, \c false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
    2292:	80 91 eb 00 	lds	r24, 0x00EB
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (Endpoint_IsEnabled())
    2296:	80 ff       	sbrs	r24, 0
    2298:	1b c0       	rjmp	.+54     	; 0x22d0 <USB_Device_ProcessControlRequest+0x146>
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    229a:	33 30       	cpi	r19, 0x03	; 3
    229c:	21 f4       	brne	.+8      	; 0x22a6 <USB_Device_ProcessControlRequest+0x11c>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    229e:	80 91 eb 00 	lds	r24, 0x00EB
    22a2:	80 62       	ori	r24, 0x20	; 32
    22a4:	13 c0       	rjmp	.+38     	; 0x22cc <USB_Device_ProcessControlRequest+0x142>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    22a6:	80 91 eb 00 	lds	r24, 0x00EB
    22aa:	80 61       	ori	r24, 0x10	; 16
    22ac:	80 93 eb 00 	sts	0x00EB, r24
			 *  \param[in] EndpointNumber Endpoint number whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber)
			{
				UERST = (1 << EndpointNumber);
    22b0:	81 e0       	ldi	r24, 0x01	; 1
    22b2:	90 e0       	ldi	r25, 0x00	; 0
    22b4:	02 c0       	rjmp	.+4      	; 0x22ba <USB_Device_ProcessControlRequest+0x130>
    22b6:	88 0f       	add	r24, r24
    22b8:	99 1f       	adc	r25, r25
    22ba:	2a 95       	dec	r18
    22bc:	e2 f7       	brpl	.-8      	; 0x22b6 <USB_Device_ProcessControlRequest+0x12c>
    22be:	80 93 ea 00 	sts	0x00EA, r24
				UERST = 0;
    22c2:	10 92 ea 00 	sts	0x00EA, r1

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    22c6:	80 91 eb 00 	lds	r24, 0x00EB
    22ca:	88 60       	ori	r24, 0x08	; 8
    22cc:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    22d0:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    22d4:	80 91 e8 00 	lds	r24, 0x00E8
    22d8:	87 7f       	andi	r24, 0xF7	; 247
    22da:	8b c0       	rjmp	.+278    	; 0x23f2 <USB_Device_ProcessControlRequest+0x268>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    22dc:	88 23       	and	r24, r24
    22de:	09 f0       	breq	.+2      	; 0x22e2 <USB_Device_ProcessControlRequest+0x158>
    22e0:	a9 c0       	rjmp	.+338    	; 0x2434 <USB_Device_ProcessControlRequest+0x2aa>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t    DeviceAddress    = (USB_ControlRequest.wValue & 0x7F);
    22e2:	10 91 03 14 	lds	r17, 0x1403
    22e6:	1f 77       	andi	r17, 0x7F	; 127
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    22e8:	0f b7       	in	r16, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    22ea:	f8 94       	cli
    22ec:	80 91 e8 00 	lds	r24, 0x00E8
    22f0:	87 7f       	andi	r24, 0xF7	; 247
    22f2:	80 93 e8 00 	sts	0x00E8, r24
	uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
	GlobalInterruptDisable();

	Endpoint_ClearSETUP();

	Endpoint_ClearStatusStage();
    22f6:	29 dc       	rcall	.-1966   	; 0x1b4a <Endpoint_ClearStatusStage>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    22f8:	80 91 e8 00 	lds	r24, 0x00E8

	while (!(Endpoint_IsINReady()));
    22fc:	80 ff       	sbrs	r24, 0
    22fe:	fc cf       	rjmp	.-8      	; 0x22f8 <USB_Device_ProcessControlRequest+0x16e>
			#endif

			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				uint8_t Temp = (UDADDR & (1 << ADDEN)) | (Address & 0x7F);
    2300:	80 91 e3 00 	lds	r24, 0x00E3
    2304:	80 78       	andi	r24, 0x80	; 128
    2306:	81 2b       	or	r24, r17

				UDADDR = Temp;
    2308:	80 93 e3 00 	sts	0x00E3, r24
				UDADDR = Temp | (1 << ADDEN);
    230c:	80 68       	ori	r24, 0x80	; 128
    230e:	80 93 e3 00 	sts	0x00E3, r24

	USB_Device_SetDeviceAddress(DeviceAddress);
	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    2312:	11 23       	and	r17, r17
    2314:	11 f4       	brne	.+4      	; 0x231a <USB_Device_ProcessControlRequest+0x190>
    2316:	82 e0       	ldi	r24, 0x02	; 2
    2318:	01 c0       	rjmp	.+2      	; 0x231c <USB_Device_ProcessControlRequest+0x192>
    231a:	83 e0       	ldi	r24, 0x03	; 3
    231c:	80 93 00 14 	sts	0x1400, r24
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    2320:	0f bf       	out	0x3f, r16	; 63
				  __builtin_csrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				SREG = GlobalIntState;
				#endif

				GCC_MEMORY_BARRIER();
    2322:	88 c0       	rjmp	.+272    	; 0x2434 <USB_Device_ProcessControlRequest+0x2aa>
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    2324:	80 58       	subi	r24, 0x80	; 128
    2326:	82 30       	cpi	r24, 0x02	; 2
    2328:	08 f0       	brcs	.+2      	; 0x232c <USB_Device_ProcessControlRequest+0x1a2>
    232a:	84 c0       	rjmp	.+264    	; 0x2434 <USB_Device_ProcessControlRequest+0x2aa>
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
    232c:	80 91 03 14 	lds	r24, 0x1403
    2330:	90 91 04 14 	lds	r25, 0x1404
    2334:	23 e0       	ldi	r18, 0x03	; 3
    2336:	8c 3d       	cpi	r24, 0xDC	; 220
    2338:	92 07       	cpc	r25, r18
    233a:	09 f0       	breq	.+2      	; 0x233e <USB_Device_ProcessControlRequest+0x1b4>
    233c:	33 c0       	rjmp	.+102    	; 0x23a4 <USB_Device_ProcessControlRequest+0x21a>
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
    233e:	83 e0       	ldi	r24, 0x03	; 3
    2340:	8c 83       	std	Y+4, r24	; 0x04
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
    2342:	8a e2       	ldi	r24, 0x2A	; 42
    2344:	8b 83       	std	Y+3, r24	; 0x03
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    2346:	7f b7       	in	r23, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    2348:	f8 94       	cli
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
				#endif

				GCC_MEMORY_BARRIER();
    234a:	de 01       	movw	r26, r28
    234c:	15 96       	adiw	r26, 0x05	; 5
    234e:	6e e0       	ldi	r22, 0x0E	; 14
    2350:	40 e0       	ldi	r20, 0x00	; 0
    2352:	50 e0       	ldi	r21, 0x00	; 0

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte = boot_signature_byte_get(SigReadAddress);
    2354:	11 e2       	ldi	r17, 0x21	; 33
    2356:	e6 2f       	mov	r30, r22
    2358:	f0 e0       	ldi	r31, 0x00	; 0
    235a:	10 93 57 00 	sts	0x0057, r17
    235e:	84 91       	lpm	r24, Z+

					if (SerialCharNum & 0x01)
    2360:	40 ff       	sbrs	r20, 0
    2362:	03 c0       	rjmp	.+6      	; 0x236a <USB_Device_ProcessControlRequest+0x1e0>
					{
						SerialByte >>= 4;
    2364:	82 95       	swap	r24
    2366:	8f 70       	andi	r24, 0x0F	; 15
						SigReadAddress++;
    2368:	6f 5f       	subi	r22, 0xFF	; 255
					}

					SerialByte &= 0x0F;
    236a:	8f 70       	andi	r24, 0x0F	; 15
    236c:	28 2f       	mov	r18, r24
    236e:	30 e0       	ldi	r19, 0x00	; 0

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
    2370:	8a 30       	cpi	r24, 0x0A	; 10
    2372:	18 f0       	brcs	.+6      	; 0x237a <USB_Device_ProcessControlRequest+0x1f0>
    2374:	c9 01       	movw	r24, r18
    2376:	c7 96       	adiw	r24, 0x37	; 55
    2378:	02 c0       	rjmp	.+4      	; 0x237e <USB_Device_ProcessControlRequest+0x1f4>
    237a:	c9 01       	movw	r24, r18
    237c:	c0 96       	adiw	r24, 0x30	; 48
    237e:	8d 93       	st	X+, r24
    2380:	9d 93       	st	X+, r25
    2382:	4f 5f       	subi	r20, 0xFF	; 255
    2384:	5f 4f       	sbci	r21, 0xFF	; 255
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    2386:	44 31       	cpi	r20, 0x14	; 20
    2388:	51 05       	cpc	r21, r1
    238a:	29 f7       	brne	.-54     	; 0x2356 <USB_Device_ProcessControlRequest+0x1cc>
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    238c:	7f bf       	out	0x3f, r23	; 63
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    238e:	80 91 e8 00 	lds	r24, 0x00E8
    2392:	87 7f       	andi	r24, 0xF7	; 247
    2394:	80 93 e8 00 	sts	0x00E8, r24

	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
    2398:	ce 01       	movw	r24, r28
    239a:	03 96       	adiw	r24, 0x03	; 3
    239c:	6a e2       	ldi	r22, 0x2A	; 42
    239e:	70 e0       	ldi	r23, 0x00	; 0
    23a0:	50 dd       	rcall	.-1376   	; 0x1e42 <Endpoint_Write_Control_Stream_LE>
    23a2:	13 c0       	rjmp	.+38     	; 0x23ca <USB_Device_ProcessControlRequest+0x240>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    23a4:	60 91 05 14 	lds	r22, 0x1405
    23a8:	ae 01       	movw	r20, r28
    23aa:	4f 5f       	subi	r20, 0xFF	; 255
    23ac:	5f 4f       	sbci	r21, 0xFF	; 255
    23ae:	0e 94 bd 02 	call	0x57a	; 0x57a <CALLBACK_USB_GetDescriptor>
    23b2:	bc 01       	movw	r22, r24
    23b4:	00 97       	sbiw	r24, 0x00	; 0
    23b6:	09 f4       	brne	.+2      	; 0x23ba <USB_Device_ProcessControlRequest+0x230>
    23b8:	3d c0       	rjmp	.+122    	; 0x2434 <USB_Device_ProcessControlRequest+0x2aa>
    23ba:	80 91 e8 00 	lds	r24, 0x00E8
    23be:	87 7f       	andi	r24, 0xF7	; 247
    23c0:	80 93 e8 00 	sts	0x00E8, r24
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
    23c4:	89 81       	ldd	r24, Y+1	; 0x01
    23c6:	9a 81       	ldd	r25, Y+2	; 0x02
    23c8:	db dd       	rcall	.-1098   	; 0x1f80 <Endpoint_Write_Control_PStream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    23ca:	80 91 e8 00 	lds	r24, 0x00E8
    23ce:	8b 77       	andi	r24, 0x7B	; 123
    23d0:	80 93 e8 00 	sts	0x00E8, r24
    23d4:	2f c0       	rjmp	.+94     	; 0x2434 <USB_Device_ProcessControlRequest+0x2aa>
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    23d6:	80 38       	cpi	r24, 0x80	; 128
    23d8:	69 f5       	brne	.+90     	; 0x2434 <USB_Device_ProcessControlRequest+0x2aa>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    23da:	80 91 e8 00 	lds	r24, 0x00E8
    23de:	87 7f       	andi	r24, 0xF7	; 247
    23e0:	80 93 e8 00 	sts	0x00E8, r24

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
    23e4:	80 91 fc 13 	lds	r24, 0x13FC
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    23e8:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    23ec:	80 91 e8 00 	lds	r24, 0x00E8
    23f0:	8e 77       	andi	r24, 0x7E	; 126
    23f2:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    23f6:	a9 db       	rcall	.-2222   	; 0x1b4a <Endpoint_ClearStatusStage>
    23f8:	1d c0       	rjmp	.+58     	; 0x2434 <USB_Device_ProcessControlRequest+0x2aa>
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    23fa:	88 23       	and	r24, r24
    23fc:	d9 f4       	brne	.+54     	; 0x2434 <USB_Device_ProcessControlRequest+0x2aa>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    23fe:	90 91 03 14 	lds	r25, 0x1403
    2402:	92 30       	cpi	r25, 0x02	; 2
    2404:	b8 f4       	brcc	.+46     	; 0x2434 <USB_Device_ProcessControlRequest+0x2aa>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2406:	80 91 e8 00 	lds	r24, 0x00E8
    240a:	87 7f       	andi	r24, 0xF7	; 247
    240c:	80 93 e8 00 	sts	0x00E8, r24
	#endif
	#endif

	Endpoint_ClearSETUP();

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    2410:	90 93 fc 13 	sts	0x13FC, r25

	Endpoint_ClearStatusStage();
    2414:	9a db       	rcall	.-2252   	; 0x1b4a <Endpoint_ClearStatusStage>

	if (USB_Device_ConfigurationNumber)
    2416:	80 91 fc 13 	lds	r24, 0x13FC
    241a:	88 23       	and	r24, r24
    241c:	31 f4       	brne	.+12     	; 0x242a <USB_Device_ProcessControlRequest+0x2a0>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    241e:	80 91 e3 00 	lds	r24, 0x00E3
	  USB_DeviceState = DEVICE_STATE_Configured;
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    2422:	87 fd       	sbrc	r24, 7
    2424:	02 c0       	rjmp	.+4      	; 0x242a <USB_Device_ProcessControlRequest+0x2a0>
    2426:	81 e0       	ldi	r24, 0x01	; 1
    2428:	01 c0       	rjmp	.+2      	; 0x242c <USB_Device_ProcessControlRequest+0x2a2>
    242a:	84 e0       	ldi	r24, 0x04	; 4
    242c:	80 93 00 14 	sts	0x1400, r24

	EVENT_USB_Device_ConfigurationChanged();
    2430:	0e 94 3e 02 	call	0x47c	; 0x47c <EVENT_USB_Device_ConfigurationChanged>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2434:	80 91 e8 00 	lds	r24, 0x00E8

				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    2438:	83 ff       	sbrs	r24, 3
    243a:	0a c0       	rjmp	.+20     	; 0x2450 <USB_Device_ProcessControlRequest+0x2c6>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    243c:	80 91 eb 00 	lds	r24, 0x00EB
    2440:	80 62       	ori	r24, 0x20	; 32
    2442:	80 93 eb 00 	sts	0x00EB, r24
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2446:	80 91 e8 00 	lds	r24, 0x00E8
    244a:	87 7f       	andi	r24, 0xF7	; 247
    244c:	80 93 e8 00 	sts	0x00E8, r24
	{
		Endpoint_StallTransaction();
		Endpoint_ClearSETUP();
	}
}
    2450:	ac 96       	adiw	r28, 0x2c	; 44
    2452:	0f b6       	in	r0, 0x3f	; 63
    2454:	f8 94       	cli
    2456:	de bf       	out	0x3e, r29	; 62
    2458:	0f be       	out	0x3f, r0	; 63
    245a:	cd bf       	out	0x3d, r28	; 61
    245c:	cf 91       	pop	r28
    245e:	df 91       	pop	r29
    2460:	1f 91       	pop	r17
    2462:	0f 91       	pop	r16
    2464:	08 95       	ret

00002466 <USB_Event_Stub>:
#include "Events.h"

void USB_Event_Stub(void)
{

}
    2466:	08 95       	ret

00002468 <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
    2468:	1f 93       	push	r17
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState != DEVICE_STATE_Unattached)
    246a:	80 91 00 14 	lds	r24, 0x1400
    246e:	88 23       	and	r24, r24
    2470:	61 f0       	breq	.+24     	; 0x248a <USB_USBTask+0x22>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
    2472:	10 91 e9 00 	lds	r17, 0x00E9
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2476:	10 92 e9 00 	sts	0x00E9, r1
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    247a:	80 91 e8 00 	lds	r24, 0x00E8
	{
		uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

		Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

		if (Endpoint_IsSETUPReceived())
    247e:	83 ff       	sbrs	r24, 3
    2480:	01 c0       	rjmp	.+2      	; 0x2484 <USB_USBTask+0x1c>
		  USB_Device_ProcessControlRequest();
    2482:	83 de       	rcall	.-762    	; 0x218a <USB_Device_ProcessControlRequest>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
    2484:	1f 70       	andi	r17, 0x0F	; 15
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2486:	10 93 e9 00 	sts	0x00E9, r17
		#if defined(USB_CAN_BE_HOST)
		else if (USB_CurrentMode == USB_MODE_Host)
		  USB_HostTask();
		#endif
	#endif
}
    248a:	1f 91       	pop	r17
    248c:	08 95       	ret

0000248e <RNDIS_Device_IsPacketReceived>:
			return false;
	}
}

bool RNDIS_Device_IsPacketReceived(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    248e:	fc 01       	movw	r30, r24
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    2490:	80 91 00 14 	lds	r24, 0x1400
    2494:	84 30       	cpi	r24, 0x04	; 4
    2496:	99 f4       	brne	.+38     	; 0x24be <RNDIS_Device_IsPacketReceived+0x30>
    2498:	ea 56       	subi	r30, 0x6A	; 106
    249a:	ff 4f       	sbci	r31, 0xFF	; 255
    249c:	80 81       	ld	r24, Z
    249e:	e6 59       	subi	r30, 0x96	; 150
    24a0:	f0 40       	sbci	r31, 0x00	; 0
    24a2:	82 30       	cpi	r24, 0x02	; 2
    24a4:	61 f4       	brne	.+24     	; 0x24be <RNDIS_Device_IsPacketReceived+0x30>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return false;
	}

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpointNumber);
    24a6:	85 81       	ldd	r24, Z+5	; 0x05
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    24a8:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    24ac:	80 91 e8 00 	lds	r24, 0x00E8
    24b0:	90 e0       	ldi	r25, 0x00	; 0
    24b2:	96 95       	lsr	r25
    24b4:	87 95       	ror	r24
    24b6:	96 95       	lsr	r25
    24b8:	87 95       	ror	r24
    24ba:	81 70       	andi	r24, 0x01	; 1
    24bc:	08 95       	ret
	return Endpoint_IsOUTReceived();
    24be:	80 e0       	ldi	r24, 0x00	; 0
}
    24c0:	08 95       	ret

000024c2 <RNDIS_Device_SendPacket>:
}

uint8_t RNDIS_Device_SendPacket(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
                                void* Buffer,
                                const uint16_t PacketLength)
{
    24c2:	cf 92       	push	r12
    24c4:	df 92       	push	r13
    24c6:	ff 92       	push	r15
    24c8:	0f 93       	push	r16
    24ca:	1f 93       	push	r17
    24cc:	df 93       	push	r29
    24ce:	cf 93       	push	r28
    24d0:	cd b7       	in	r28, 0x3d	; 61
    24d2:	de b7       	in	r29, 0x3e	; 62
    24d4:	ac 97       	sbiw	r28, 0x2c	; 44
    24d6:	0f b6       	in	r0, 0x3f	; 63
    24d8:	f8 94       	cli
    24da:	de bf       	out	0x3e, r29	; 62
    24dc:	0f be       	out	0x3f, r0	; 63
    24de:	cd bf       	out	0x3d, r28	; 61
    24e0:	fc 01       	movw	r30, r24
    24e2:	6b 01       	movw	r12, r22
    24e4:	8a 01       	movw	r16, r20
	uint8_t ErrorCode;

	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    24e6:	80 91 00 14 	lds	r24, 0x1400
    24ea:	84 30       	cpi	r24, 0x04	; 4
    24ec:	09 f0       	breq	.+2      	; 0x24f0 <RNDIS_Device_SendPacket+0x2e>
    24ee:	49 c0       	rjmp	.+146    	; 0x2582 <RNDIS_Device_SendPacket+0xc0>
    24f0:	ea 56       	subi	r30, 0x6A	; 106
    24f2:	ff 4f       	sbci	r31, 0xFF	; 255
    24f4:	80 81       	ld	r24, Z
    24f6:	e6 59       	subi	r30, 0x96	; 150
    24f8:	f0 40       	sbci	r31, 0x00	; 0
    24fa:	82 30       	cpi	r24, 0x02	; 2
    24fc:	09 f0       	breq	.+2      	; 0x2500 <RNDIS_Device_SendPacket+0x3e>
    24fe:	41 c0       	rjmp	.+130    	; 0x2582 <RNDIS_Device_SendPacket+0xc0>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
	}

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataINEndpointNumber);
    2500:	81 81       	ldd	r24, Z+1	; 0x01
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2502:	80 93 e9 00 	sts	0x00E9, r24

	if ((ErrorCode = Endpoint_WaitUntilReady()) != ENDPOINT_READYWAIT_NoError)
    2506:	42 db       	rcall	.-2428   	; 0x1b8c <Endpoint_WaitUntilReady>
    2508:	f8 2e       	mov	r15, r24
    250a:	88 23       	and	r24, r24
    250c:	e1 f5       	brne	.+120    	; 0x2586 <RNDIS_Device_SendPacket+0xc4>
	  return ErrorCode;

	RNDIS_Packet_Message_t RNDISPacketHeader;

	memset(&RNDISPacketHeader, 0, sizeof(RNDIS_Packet_Message_t));
    250e:	fe 01       	movw	r30, r28
    2510:	31 96       	adiw	r30, 0x01	; 1
    2512:	8c e2       	ldi	r24, 0x2C	; 44
    2514:	df 01       	movw	r26, r30
    2516:	1d 92       	st	X+, r1
    2518:	8a 95       	dec	r24
    251a:	e9 f7       	brne	.-6      	; 0x2516 <RNDIS_Device_SendPacket+0x54>

	RNDISPacketHeader.MessageType   = CPU_TO_LE32(REMOTE_NDIS_PACKET_MSG);
    251c:	81 e0       	ldi	r24, 0x01	; 1
    251e:	90 e0       	ldi	r25, 0x00	; 0
    2520:	a0 e0       	ldi	r26, 0x00	; 0
    2522:	b0 e0       	ldi	r27, 0x00	; 0
    2524:	89 83       	std	Y+1, r24	; 0x01
    2526:	9a 83       	std	Y+2, r25	; 0x02
    2528:	ab 83       	std	Y+3, r26	; 0x03
    252a:	bc 83       	std	Y+4, r27	; 0x04
	RNDISPacketHeader.MessageLength = cpu_to_le32(sizeof(RNDIS_Packet_Message_t) + PacketLength);
    252c:	04 5d       	subi	r16, 0xD4	; 212
    252e:	1f 4f       	sbci	r17, 0xFF	; 255
    2530:	c8 01       	movw	r24, r16
    2532:	a0 e0       	ldi	r26, 0x00	; 0
    2534:	b0 e0       	ldi	r27, 0x00	; 0
    2536:	0c 52       	subi	r16, 0x2C	; 44
    2538:	10 40       	sbci	r17, 0x00	; 0
    253a:	8d 83       	std	Y+5, r24	; 0x05
    253c:	9e 83       	std	Y+6, r25	; 0x06
    253e:	af 83       	std	Y+7, r26	; 0x07
    2540:	b8 87       	std	Y+8, r27	; 0x08
	RNDISPacketHeader.DataOffset    = CPU_TO_LE32(sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t));
    2542:	84 e2       	ldi	r24, 0x24	; 36
    2544:	90 e0       	ldi	r25, 0x00	; 0
    2546:	a0 e0       	ldi	r26, 0x00	; 0
    2548:	b0 e0       	ldi	r27, 0x00	; 0
    254a:	89 87       	std	Y+9, r24	; 0x09
    254c:	9a 87       	std	Y+10, r25	; 0x0a
    254e:	ab 87       	std	Y+11, r26	; 0x0b
    2550:	bc 87       	std	Y+12, r27	; 0x0c
	RNDISPacketHeader.DataLength    = cpu_to_le32(PacketLength);
    2552:	c8 01       	movw	r24, r16
    2554:	a0 e0       	ldi	r26, 0x00	; 0
    2556:	b0 e0       	ldi	r27, 0x00	; 0
    2558:	8d 87       	std	Y+13, r24	; 0x0d
    255a:	9e 87       	std	Y+14, r25	; 0x0e
    255c:	af 87       	std	Y+15, r26	; 0x0f
    255e:	b8 8b       	std	Y+16, r27	; 0x10

	Endpoint_Write_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
    2560:	cf 01       	movw	r24, r30
    2562:	6c e2       	ldi	r22, 0x2C	; 44
    2564:	70 e0       	ldi	r23, 0x00	; 0
    2566:	40 e0       	ldi	r20, 0x00	; 0
    2568:	50 e0       	ldi	r21, 0x00	; 0
    256a:	bd dd       	rcall	.-1158   	; 0x20e6 <Endpoint_Write_Stream_LE>
	Endpoint_Write_Stream_LE(Buffer, PacketLength, NULL);
    256c:	c6 01       	movw	r24, r12
    256e:	b8 01       	movw	r22, r16
    2570:	40 e0       	ldi	r20, 0x00	; 0
    2572:	50 e0       	ldi	r21, 0x00	; 0
    2574:	b8 dd       	rcall	.-1168   	; 0x20e6 <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2576:	80 91 e8 00 	lds	r24, 0x00E8
    257a:	8e 77       	andi	r24, 0x7E	; 126
    257c:	80 93 e8 00 	sts	0x00E8, r24
    2580:	02 c0       	rjmp	.+4      	; 0x2586 <RNDIS_Device_SendPacket+0xc4>
	Endpoint_ClearIN();

	return ENDPOINT_RWSTREAM_NoError;
    2582:	32 e0       	ldi	r19, 0x02	; 2
    2584:	f3 2e       	mov	r15, r19
}
    2586:	8f 2d       	mov	r24, r15
    2588:	ac 96       	adiw	r28, 0x2c	; 44
    258a:	0f b6       	in	r0, 0x3f	; 63
    258c:	f8 94       	cli
    258e:	de bf       	out	0x3e, r29	; 62
    2590:	0f be       	out	0x3f, r0	; 63
    2592:	cd bf       	out	0x3d, r28	; 61
    2594:	cf 91       	pop	r28
    2596:	df 91       	pop	r29
    2598:	1f 91       	pop	r17
    259a:	0f 91       	pop	r16
    259c:	ff 90       	pop	r15
    259e:	df 90       	pop	r13
    25a0:	cf 90       	pop	r12
    25a2:	08 95       	ret

000025a4 <RNDIS_Device_USBTask>:

	return true;
}

void RNDIS_Device_USBTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    25a4:	0f 93       	push	r16
    25a6:	1f 93       	push	r17
    25a8:	df 93       	push	r29
    25aa:	cf 93       	push	r28
    25ac:	cd b7       	in	r28, 0x3d	; 61
    25ae:	de b7       	in	r29, 0x3e	; 62
    25b0:	28 97       	sbiw	r28, 0x08	; 8
    25b2:	0f b6       	in	r0, 0x3f	; 63
    25b4:	f8 94       	cli
    25b6:	de bf       	out	0x3e, r29	; 62
    25b8:	0f be       	out	0x3f, r0	; 63
    25ba:	cd bf       	out	0x3d, r28	; 61
    25bc:	8c 01       	movw	r16, r24
	if (USB_DeviceState != DEVICE_STATE_Configured)
    25be:	80 91 00 14 	lds	r24, 0x1400
    25c2:	84 30       	cpi	r24, 0x04	; 4
    25c4:	49 f5       	brne	.+82     	; 0x2618 <RNDIS_Device_USBTask+0x74>
	  return;

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.NotificationEndpointNumber);
    25c6:	f8 01       	movw	r30, r16
    25c8:	81 85       	ldd	r24, Z+9	; 0x09
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    25ca:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    25ce:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsINReady() && RNDISInterfaceInfo->State.ResponseReady)
    25d2:	80 ff       	sbrs	r24, 0
    25d4:	21 c0       	rjmp	.+66     	; 0x2618 <RNDIS_Device_USBTask+0x74>
    25d6:	0b 56       	subi	r16, 0x6B	; 107
    25d8:	1f 4f       	sbci	r17, 0xFF	; 255
    25da:	f8 01       	movw	r30, r16
    25dc:	80 81       	ld	r24, Z
    25de:	05 59       	subi	r16, 0x95	; 149
    25e0:	10 40       	sbci	r17, 0x00	; 0
    25e2:	88 23       	and	r24, r24
    25e4:	c9 f0       	breq	.+50     	; 0x2618 <RNDIS_Device_USBTask+0x74>
				.bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
				.bRequest      = RNDIS_NOTIF_ResponseAvailable,
				.wValue        = CPU_TO_LE16(0),
				.wIndex        = CPU_TO_LE16(0),
				.wLength       = CPU_TO_LE16(0),
			};
    25e6:	de 01       	movw	r26, r28
    25e8:	11 96       	adiw	r26, 0x01	; 1
    25ea:	ef ee       	ldi	r30, 0xEF	; 239
    25ec:	f1 e0       	ldi	r31, 0x01	; 1
    25ee:	88 e0       	ldi	r24, 0x08	; 8
    25f0:	01 90       	ld	r0, Z+
    25f2:	0d 92       	st	X+, r0
    25f4:	81 50       	subi	r24, 0x01	; 1
    25f6:	e1 f7       	brne	.-8      	; 0x25f0 <RNDIS_Device_USBTask+0x4c>

		Endpoint_Write_Stream_LE(&Notification, sizeof(USB_Request_Header_t), NULL);
    25f8:	ce 01       	movw	r24, r28
    25fa:	01 96       	adiw	r24, 0x01	; 1
    25fc:	68 e0       	ldi	r22, 0x08	; 8
    25fe:	70 e0       	ldi	r23, 0x00	; 0
    2600:	40 e0       	ldi	r20, 0x00	; 0
    2602:	50 e0       	ldi	r21, 0x00	; 0
    2604:	70 dd       	rcall	.-1312   	; 0x20e6 <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2606:	80 91 e8 00 	lds	r24, 0x00E8
    260a:	8e 77       	andi	r24, 0x7E	; 126
    260c:	80 93 e8 00 	sts	0x00E8, r24

		Endpoint_ClearIN();

		RNDISInterfaceInfo->State.ResponseReady = false;
    2610:	0b 56       	subi	r16, 0x6B	; 107
    2612:	1f 4f       	sbci	r17, 0xFF	; 255
    2614:	f8 01       	movw	r30, r16
    2616:	10 82       	st	Z, r1
	}
}
    2618:	28 96       	adiw	r28, 0x08	; 8
    261a:	0f b6       	in	r0, 0x3f	; 63
    261c:	f8 94       	cli
    261e:	de bf       	out	0x3e, r29	; 62
    2620:	0f be       	out	0x3f, r0	; 63
    2622:	cd bf       	out	0x3d, r28	; 61
    2624:	cf 91       	pop	r28
    2626:	df 91       	pop	r29
    2628:	1f 91       	pop	r17
    262a:	0f 91       	pop	r16
    262c:	08 95       	ret

0000262e <RNDIS_Device_ReadPacket>:
}

uint8_t RNDIS_Device_ReadPacket(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
                                void* Buffer,
                                uint16_t* const PacketLength)
{
    262e:	ef 92       	push	r14
    2630:	ff 92       	push	r15
    2632:	0f 93       	push	r16
    2634:	1f 93       	push	r17
    2636:	df 93       	push	r29
    2638:	cf 93       	push	r28
    263a:	cd b7       	in	r28, 0x3d	; 61
    263c:	de b7       	in	r29, 0x3e	; 62
    263e:	ac 97       	sbiw	r28, 0x2c	; 44
    2640:	0f b6       	in	r0, 0x3f	; 63
    2642:	f8 94       	cli
    2644:	de bf       	out	0x3e, r29	; 62
    2646:	0f be       	out	0x3f, r0	; 63
    2648:	cd bf       	out	0x3d, r28	; 61
    264a:	fc 01       	movw	r30, r24
    264c:	7b 01       	movw	r14, r22
    264e:	8a 01       	movw	r16, r20
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    2650:	80 91 00 14 	lds	r24, 0x1400
    2654:	84 30       	cpi	r24, 0x04	; 4
    2656:	d1 f5       	brne	.+116    	; 0x26cc <RNDIS_Device_ReadPacket+0x9e>
    2658:	ea 56       	subi	r30, 0x6A	; 106
    265a:	ff 4f       	sbci	r31, 0xFF	; 255
    265c:	80 81       	ld	r24, Z
    265e:	e6 59       	subi	r30, 0x96	; 150
    2660:	f0 40       	sbci	r31, 0x00	; 0
    2662:	82 30       	cpi	r24, 0x02	; 2
    2664:	99 f5       	brne	.+102    	; 0x26cc <RNDIS_Device_ReadPacket+0x9e>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
	}

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpointNumber);
    2666:	85 81       	ldd	r24, Z+5	; 0x05
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2668:	80 93 e9 00 	sts	0x00E9, r24

	*PacketLength = 0;
    266c:	fa 01       	movw	r30, r20
    266e:	11 82       	std	Z+1, r1	; 0x01
    2670:	10 82       	st	Z, r1
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2672:	80 91 e8 00 	lds	r24, 0x00E8

	if (!(Endpoint_IsOUTReceived()))
    2676:	82 ff       	sbrs	r24, 2
    2678:	27 c0       	rjmp	.+78     	; 0x26c8 <RNDIS_Device_ReadPacket+0x9a>
		return ENDPOINT_RWSTREAM_NoError;

	RNDIS_Packet_Message_t RNDISPacketHeader;
	Endpoint_Read_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
    267a:	ce 01       	movw	r24, r28
    267c:	01 96       	adiw	r24, 0x01	; 1
    267e:	6c e2       	ldi	r22, 0x2C	; 44
    2680:	70 e0       	ldi	r23, 0x00	; 0
    2682:	40 e0       	ldi	r20, 0x00	; 0
    2684:	50 e0       	ldi	r21, 0x00	; 0
    2686:	dd dc       	rcall	.-1606   	; 0x2042 <Endpoint_Read_Stream_LE>

	if (le32_to_cpu(RNDISPacketHeader.DataLength) > ETHERNET_FRAME_SIZE_MAX)
    2688:	2d 85       	ldd	r18, Y+13	; 0x0d
    268a:	3e 85       	ldd	r19, Y+14	; 0x0e
    268c:	4f 85       	ldd	r20, Y+15	; 0x0f
    268e:	58 89       	ldd	r21, Y+16	; 0x10
    2690:	2d 3d       	cpi	r18, 0xDD	; 221
    2692:	f5 e0       	ldi	r31, 0x05	; 5
    2694:	3f 07       	cpc	r19, r31
    2696:	f0 e0       	ldi	r31, 0x00	; 0
    2698:	4f 07       	cpc	r20, r31
    269a:	f0 e0       	ldi	r31, 0x00	; 0
    269c:	5f 07       	cpc	r21, r31
    269e:	38 f0       	brcs	.+14     	; 0x26ae <RNDIS_Device_ReadPacket+0x80>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    26a0:	80 91 eb 00 	lds	r24, 0x00EB
    26a4:	80 62       	ori	r24, 0x20	; 32
    26a6:	80 93 eb 00 	sts	0x00EB, r24
    26aa:	80 e8       	ldi	r24, 0x80	; 128
    26ac:	10 c0       	rjmp	.+32     	; 0x26ce <RNDIS_Device_ReadPacket+0xa0>
		Endpoint_StallTransaction();

		return RNDIS_ERROR_LOGICAL_CMD_FAILED;
	}

	*PacketLength = (uint16_t)le32_to_cpu(RNDISPacketHeader.DataLength);
    26ae:	f8 01       	movw	r30, r16
    26b0:	31 83       	std	Z+1, r19	; 0x01
    26b2:	20 83       	st	Z, r18

	Endpoint_Read_Stream_LE(Buffer, *PacketLength, NULL);
    26b4:	c7 01       	movw	r24, r14
    26b6:	b9 01       	movw	r22, r18
    26b8:	40 e0       	ldi	r20, 0x00	; 0
    26ba:	50 e0       	ldi	r21, 0x00	; 0
    26bc:	c2 dc       	rcall	.-1660   	; 0x2042 <Endpoint_Read_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    26be:	80 91 e8 00 	lds	r24, 0x00E8
    26c2:	8b 77       	andi	r24, 0x7B	; 123
    26c4:	80 93 e8 00 	sts	0x00E8, r24
    26c8:	80 e0       	ldi	r24, 0x00	; 0
    26ca:	01 c0       	rjmp	.+2      	; 0x26ce <RNDIS_Device_ReadPacket+0xa0>
	Endpoint_ClearOUT();

	return ENDPOINT_RWSTREAM_NoError;
    26cc:	82 e0       	ldi	r24, 0x02	; 2
}
    26ce:	ac 96       	adiw	r28, 0x2c	; 44
    26d0:	0f b6       	in	r0, 0x3f	; 63
    26d2:	f8 94       	cli
    26d4:	de bf       	out	0x3e, r29	; 62
    26d6:	0f be       	out	0x3f, r0	; 63
    26d8:	cd bf       	out	0x3d, r28	; 61
    26da:	cf 91       	pop	r28
    26dc:	df 91       	pop	r29
    26de:	1f 91       	pop	r17
    26e0:	0f 91       	pop	r16
    26e2:	ff 90       	pop	r15
    26e4:	ef 90       	pop	r14
    26e6:	08 95       	ret

000026e8 <RNDIS_Device_ConfigureEndpoints>:
			break;
	}
}

bool RNDIS_Device_ConfigureEndpoints(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    26e8:	1f 93       	push	r17
    26ea:	cf 93       	push	r28
    26ec:	df 93       	push	r29
    26ee:	ec 01       	movw	r28, r24
	memset(&RNDISInterfaceInfo->State, 0x00, sizeof(RNDISInterfaceInfo->State));
    26f0:	45 96       	adiw	r24, 0x15	; 21
    26f2:	fc 01       	movw	r30, r24
    26f4:	86 e8       	ldi	r24, 0x86	; 134
    26f6:	df 01       	movw	r26, r30
    26f8:	1d 92       	st	X+, r1
    26fa:	8a 95       	dec	r24
    26fc:	e9 f7       	brne	.-6      	; 0x26f8 <RNDIS_Device_ConfigureEndpoints+0x10>
    26fe:	11 e0       	ldi	r17, 0x01	; 1
		uint16_t Size;
		uint8_t  Type;
		uint8_t  Direction;
		bool     DoubleBanked;

		if (EndpointNum == RNDISInterfaceInfo->Config.DataINEndpointNumber)
    2700:	89 81       	ldd	r24, Y+1	; 0x01
    2702:	18 17       	cp	r17, r24
    2704:	29 f4       	brne	.+10     	; 0x2710 <RNDIS_Device_ConfigureEndpoints+0x28>
		{
			Size         = RNDISInterfaceInfo->Config.DataINEndpointSize;
    2706:	6a 81       	ldd	r22, Y+2	; 0x02
    2708:	7b 81       	ldd	r23, Y+3	; 0x03
			Direction    = ENDPOINT_DIR_IN;
			Type         = EP_TYPE_BULK;
			DoubleBanked = RNDISInterfaceInfo->Config.DataINEndpointDoubleBank;
    270a:	8c 81       	ldd	r24, Y+4	; 0x04
    270c:	52 e0       	ldi	r21, 0x02	; 2
    270e:	10 c0       	rjmp	.+32     	; 0x2730 <RNDIS_Device_ConfigureEndpoints+0x48>
		}
		else if (EndpointNum == RNDISInterfaceInfo->Config.DataOUTEndpointNumber)
    2710:	8d 81       	ldd	r24, Y+5	; 0x05
    2712:	18 17       	cp	r17, r24
    2714:	31 f4       	brne	.+12     	; 0x2722 <RNDIS_Device_ConfigureEndpoints+0x3a>
		{
			Size         = RNDISInterfaceInfo->Config.DataOUTEndpointSize;
    2716:	6e 81       	ldd	r22, Y+6	; 0x06
    2718:	7f 81       	ldd	r23, Y+7	; 0x07
			Direction    = ENDPOINT_DIR_OUT;
			Type         = EP_TYPE_BULK;
			DoubleBanked = RNDISInterfaceInfo->Config.DataOUTEndpointDoubleBank;
    271a:	88 85       	ldd	r24, Y+8	; 0x08
    271c:	52 e0       	ldi	r21, 0x02	; 2
    271e:	30 e0       	ldi	r19, 0x00	; 0
    2720:	08 c0       	rjmp	.+16     	; 0x2732 <RNDIS_Device_ConfigureEndpoints+0x4a>
		}
		else if (EndpointNum == RNDISInterfaceInfo->Config.NotificationEndpointNumber)
    2722:	89 85       	ldd	r24, Y+9	; 0x09
    2724:	18 17       	cp	r17, r24
    2726:	39 f5       	brne	.+78     	; 0x2776 <RNDIS_Device_ConfigureEndpoints+0x8e>
		{
			Size         = RNDISInterfaceInfo->Config.NotificationEndpointSize;
    2728:	6a 85       	ldd	r22, Y+10	; 0x0a
    272a:	7b 85       	ldd	r23, Y+11	; 0x0b
			Direction    = ENDPOINT_DIR_IN;
			Type         = EP_TYPE_INTERRUPT;
			DoubleBanked = RNDISInterfaceInfo->Config.NotificationEndpointDoubleBank;
    272c:	8c 85       	ldd	r24, Y+12	; 0x0c
    272e:	53 e0       	ldi	r21, 0x03	; 3
    2730:	30 e8       	ldi	r19, 0x80	; 128
		else
		{
			continue;
		}

		if (!(Endpoint_ConfigureEndpoint(EndpointNum, Type, Direction, Size,
    2732:	88 23       	and	r24, r24
    2734:	11 f4       	brne	.+4      	; 0x273a <RNDIS_Device_ConfigureEndpoints+0x52>
    2736:	40 e0       	ldi	r20, 0x00	; 0
    2738:	01 c0       	rjmp	.+2      	; 0x273c <RNDIS_Device_ConfigureEndpoints+0x54>
    273a:	44 e0       	ldi	r20, 0x04	; 4
    273c:	20 e0       	ldi	r18, 0x00	; 0
    273e:	88 e0       	ldi	r24, 0x08	; 8
    2740:	90 e0       	ldi	r25, 0x00	; 0
    2742:	03 c0       	rjmp	.+6      	; 0x274a <RNDIS_Device_ConfigureEndpoints+0x62>
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
				{
					MaskVal++;
    2744:	2f 5f       	subi	r18, 0xFF	; 255
					CheckBytes <<= 1;
    2746:	88 0f       	add	r24, r24
    2748:	99 1f       	adc	r25, r25
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
    274a:	86 17       	cp	r24, r22
    274c:	97 07       	cpc	r25, r23
    274e:	d0 f3       	brcs	.-12     	; 0x2744 <RNDIS_Device_ConfigureEndpoints+0x5c>
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | (Direction ? (1 << EPDIR) : 0)),
    2750:	85 2f       	mov	r24, r21
    2752:	90 e0       	ldi	r25, 0x00	; 0
    2754:	56 e0       	ldi	r21, 0x06	; 6
    2756:	88 0f       	add	r24, r24
    2758:	99 1f       	adc	r25, r25
    275a:	5a 95       	dec	r21
    275c:	e1 f7       	brne	.-8      	; 0x2756 <RNDIS_Device_ConfigureEndpoints+0x6e>
    275e:	60 e0       	ldi	r22, 0x00	; 0
    2760:	31 11       	cpse	r19, r1
    2762:	61 e0       	ldi	r22, 0x01	; 1
    2764:	68 2b       	or	r22, r24
    2766:	42 60       	ori	r20, 0x02	; 2
    2768:	22 95       	swap	r18
    276a:	20 7f       	andi	r18, 0xF0	; 240
    276c:	42 2b       	or	r20, r18
    276e:	81 2f       	mov	r24, r17
    2770:	b7 d9       	rcall	.-3218   	; 0x1ae0 <Endpoint_ConfigureEndpoint_Prv>
    2772:	88 23       	and	r24, r24
    2774:	29 f0       	breq	.+10     	; 0x2780 <RNDIS_Device_ConfigureEndpoints+0x98>

bool RNDIS_Device_ConfigureEndpoints(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
	memset(&RNDISInterfaceInfo->State, 0x00, sizeof(RNDISInterfaceInfo->State));

	for (uint8_t EndpointNum = 1; EndpointNum < ENDPOINT_TOTAL_ENDPOINTS; EndpointNum++)
    2776:	1f 5f       	subi	r17, 0xFF	; 255
    2778:	17 30       	cpi	r17, 0x07	; 7
    277a:	09 f0       	breq	.+2      	; 0x277e <RNDIS_Device_ConfigureEndpoints+0x96>
    277c:	c1 cf       	rjmp	.-126    	; 0x2700 <RNDIS_Device_ConfigureEndpoints+0x18>
    277e:	81 e0       	ldi	r24, 0x01	; 1
			return false;
		}
	}

	return true;
}
    2780:	df 91       	pop	r29
    2782:	cf 91       	pop	r28
    2784:	1f 91       	pop	r17
    2786:	08 95       	ret

00002788 <RNDIS_Device_ProcessControlRequest>:
		CPU_TO_LE32(OID_802_3_XMIT_ONE_COLLISION),
		CPU_TO_LE32(OID_802_3_XMIT_MORE_COLLISIONS),
	};

void RNDIS_Device_ProcessControlRequest(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    2788:	ef 92       	push	r14
    278a:	ff 92       	push	r15
    278c:	0f 93       	push	r16
    278e:	1f 93       	push	r17
    2790:	cf 93       	push	r28
    2792:	df 93       	push	r29
    2794:	ec 01       	movw	r28, r24
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2796:	80 91 e8 00 	lds	r24, 0x00E8
	if (!(Endpoint_IsSETUPReceived()))
    279a:	83 ff       	sbrs	r24, 3
    279c:	b6 c2       	rjmp	.+1388   	; 0x2d0a <RNDIS_Device_ProcessControlRequest+0x582>
	  return;

	if (USB_ControlRequest.wIndex != RNDISInterfaceInfo->Config.ControlInterfaceNumber)
    279e:	88 81       	ld	r24, Y
    27a0:	90 e0       	ldi	r25, 0x00	; 0
    27a2:	20 91 05 14 	lds	r18, 0x1405
    27a6:	30 91 06 14 	lds	r19, 0x1406
    27aa:	28 17       	cp	r18, r24
    27ac:	39 07       	cpc	r19, r25
    27ae:	09 f0       	breq	.+2      	; 0x27b2 <RNDIS_Device_ProcessControlRequest+0x2a>
    27b0:	ac c2       	rjmp	.+1368   	; 0x2d0a <RNDIS_Device_ProcessControlRequest+0x582>
	  return;

	switch (USB_ControlRequest.bRequest)
    27b2:	80 91 02 14 	lds	r24, 0x1402
    27b6:	88 23       	and	r24, r24
    27b8:	21 f0       	breq	.+8      	; 0x27c2 <RNDIS_Device_ProcessControlRequest+0x3a>
    27ba:	81 30       	cpi	r24, 0x01	; 1
    27bc:	09 f0       	breq	.+2      	; 0x27c0 <RNDIS_Device_ProcessControlRequest+0x38>
    27be:	a5 c2       	rjmp	.+1354   	; 0x2d0a <RNDIS_Device_ProcessControlRequest+0x582>
    27c0:	57 c2       	rjmp	.+1198   	; 0x2c70 <RNDIS_Device_ProcessControlRequest+0x4e8>
	{
		case RNDIS_REQ_SendEncapsulatedCommand:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    27c2:	80 91 01 14 	lds	r24, 0x1401
    27c6:	81 32       	cpi	r24, 0x21	; 33
    27c8:	09 f0       	breq	.+2      	; 0x27cc <RNDIS_Device_ProcessControlRequest+0x44>
    27ca:	9f c2       	rjmp	.+1342   	; 0x2d0a <RNDIS_Device_ProcessControlRequest+0x582>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    27cc:	80 91 e8 00 	lds	r24, 0x00E8
    27d0:	87 7f       	andi	r24, 0xF7	; 247
    27d2:	80 93 e8 00 	sts	0x00E8, r24
			{
				Endpoint_ClearSETUP();
				Endpoint_Read_Control_Stream_LE(RNDISInterfaceInfo->State.RNDISMessageBuffer, USB_ControlRequest.wLength);
    27d6:	8e 01       	movw	r16, r28
    27d8:	0b 5e       	subi	r16, 0xEB	; 235
    27da:	1f 4f       	sbci	r17, 0xFF	; 255
    27dc:	60 91 07 14 	lds	r22, 0x1407
    27e0:	70 91 08 14 	lds	r23, 0x1408
    27e4:	c8 01       	movw	r24, r16
    27e6:	8b db       	rcall	.-2282   	; 0x1efe <Endpoint_Read_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    27e8:	80 91 e8 00 	lds	r24, 0x00E8
    27ec:	8e 77       	andi	r24, 0x7E	; 126
    27ee:	80 93 e8 00 	sts	0x00E8, r24
	/* Note: Only a single buffer is used for both the received message and its response to save SRAM. Because of
	         this, response bytes should be filled in order so that they do not clobber unread data in the buffer. */

	RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

	switch (le32_to_cpu(MessageHeader->MessageType))
    27f2:	8d 89       	ldd	r24, Y+21	; 0x15
    27f4:	9e 89       	ldd	r25, Y+22	; 0x16
    27f6:	af 89       	ldd	r26, Y+23	; 0x17
    27f8:	b8 8d       	ldd	r27, Y+24	; 0x18
    27fa:	84 30       	cpi	r24, 0x04	; 4
    27fc:	91 05       	cpc	r25, r1
    27fe:	a1 05       	cpc	r26, r1
    2800:	b1 05       	cpc	r27, r1
    2802:	09 f4       	brne	.+2      	; 0x2806 <RNDIS_Device_ProcessControlRequest+0x7e>
    2804:	77 c0       	rjmp	.+238    	; 0x28f4 <RNDIS_Device_ProcessControlRequest+0x16c>
    2806:	85 30       	cpi	r24, 0x05	; 5
    2808:	91 05       	cpc	r25, r1
    280a:	a1 05       	cpc	r26, r1
    280c:	b1 05       	cpc	r27, r1
    280e:	58 f4       	brcc	.+22     	; 0x2826 <RNDIS_Device_ProcessControlRequest+0x9e>
    2810:	82 30       	cpi	r24, 0x02	; 2
    2812:	91 05       	cpc	r25, r1
    2814:	a1 05       	cpc	r26, r1
    2816:	b1 05       	cpc	r27, r1
    2818:	c1 f0       	breq	.+48     	; 0x284a <RNDIS_Device_ProcessControlRequest+0xc2>
    281a:	03 97       	sbiw	r24, 0x03	; 3
    281c:	a1 05       	cpc	r26, r1
    281e:	b1 05       	cpc	r27, r1
    2820:	09 f0       	breq	.+2      	; 0x2824 <RNDIS_Device_ProcessControlRequest+0x9c>
    2822:	73 c2       	rjmp	.+1254   	; 0x2d0a <RNDIS_Device_ProcessControlRequest+0x582>
    2824:	5d c0       	rjmp	.+186    	; 0x28e0 <RNDIS_Device_ProcessControlRequest+0x158>
    2826:	86 30       	cpi	r24, 0x06	; 6
    2828:	91 05       	cpc	r25, r1
    282a:	a1 05       	cpc	r26, r1
    282c:	b1 05       	cpc	r27, r1
    282e:	09 f4       	brne	.+2      	; 0x2832 <RNDIS_Device_ProcessControlRequest+0xaa>
    2830:	e7 c1       	rjmp	.+974    	; 0x2c00 <RNDIS_Device_ProcessControlRequest+0x478>
    2832:	86 30       	cpi	r24, 0x06	; 6
    2834:	91 05       	cpc	r25, r1
    2836:	a1 05       	cpc	r26, r1
    2838:	b1 05       	cpc	r27, r1
    283a:	08 f4       	brcc	.+2      	; 0x283e <RNDIS_Device_ProcessControlRequest+0xb6>
    283c:	96 c1       	rjmp	.+812    	; 0x2b6a <RNDIS_Device_ProcessControlRequest+0x3e2>
    283e:	08 97       	sbiw	r24, 0x08	; 8
    2840:	a1 05       	cpc	r26, r1
    2842:	b1 05       	cpc	r27, r1
    2844:	09 f0       	breq	.+2      	; 0x2848 <RNDIS_Device_ProcessControlRequest+0xc0>
    2846:	61 c2       	rjmp	.+1218   	; 0x2d0a <RNDIS_Device_ProcessControlRequest+0x582>
    2848:	f7 c1       	rjmp	.+1006   	; 0x2c38 <RNDIS_Device_ProcessControlRequest+0x4b0>
	{
		case REMOTE_NDIS_INITIALIZE_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    284a:	cb 56       	subi	r28, 0x6B	; 107
    284c:	df 4f       	sbci	r29, 0xFF	; 255
    284e:	21 e0       	ldi	r18, 0x01	; 1
    2850:	28 83       	st	Y, r18
    2852:	c5 59       	subi	r28, 0x95	; 149
    2854:	d0 40       	sbci	r29, 0x00	; 0
			RNDIS_Initialize_Message_t*  INITIALIZE_Message  =
			               (RNDIS_Initialize_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_Initialize_Complete_t* INITIALIZE_Response =
			               (RNDIS_Initialize_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			INITIALIZE_Response->MessageType            = CPU_TO_LE32(REMOTE_NDIS_INITIALIZE_CMPLT);
    2856:	82 e0       	ldi	r24, 0x02	; 2
    2858:	90 e0       	ldi	r25, 0x00	; 0
    285a:	a0 e0       	ldi	r26, 0x00	; 0
    285c:	b0 e8       	ldi	r27, 0x80	; 128
    285e:	8d 8b       	std	Y+21, r24	; 0x15
    2860:	9e 8b       	std	Y+22, r25	; 0x16
    2862:	af 8b       	std	Y+23, r26	; 0x17
    2864:	b8 8f       	std	Y+24, r27	; 0x18
			INITIALIZE_Response->MessageLength          = CPU_TO_LE32(sizeof(RNDIS_Initialize_Complete_t));
    2866:	84 e3       	ldi	r24, 0x34	; 52
    2868:	90 e0       	ldi	r25, 0x00	; 0
    286a:	a0 e0       	ldi	r26, 0x00	; 0
    286c:	b0 e0       	ldi	r27, 0x00	; 0
    286e:	f8 01       	movw	r30, r16
    2870:	84 83       	std	Z+4, r24	; 0x04
    2872:	95 83       	std	Z+5, r25	; 0x05
    2874:	a6 83       	std	Z+6, r26	; 0x06
    2876:	b7 83       	std	Z+7, r27	; 0x07
			INITIALIZE_Response->RequestId              = INITIALIZE_Message->RequestId;
			INITIALIZE_Response->Status                 = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    2878:	14 86       	std	Z+12, r1	; 0x0c
    287a:	15 86       	std	Z+13, r1	; 0x0d
    287c:	16 86       	std	Z+14, r1	; 0x0e
    287e:	17 86       	std	Z+15, r1	; 0x0f

			INITIALIZE_Response->MajorVersion           = CPU_TO_LE32(REMOTE_NDIS_VERSION_MAJOR);
    2880:	81 e0       	ldi	r24, 0x01	; 1
    2882:	90 e0       	ldi	r25, 0x00	; 0
    2884:	a0 e0       	ldi	r26, 0x00	; 0
    2886:	b0 e0       	ldi	r27, 0x00	; 0
    2888:	80 8b       	std	Z+16, r24	; 0x10
    288a:	91 8b       	std	Z+17, r25	; 0x11
    288c:	a2 8b       	std	Z+18, r26	; 0x12
    288e:	b3 8b       	std	Z+19, r27	; 0x13
			INITIALIZE_Response->MinorVersion           = CPU_TO_LE32(REMOTE_NDIS_VERSION_MINOR);
    2890:	14 8a       	std	Z+20, r1	; 0x14
    2892:	15 8a       	std	Z+21, r1	; 0x15
    2894:	16 8a       	std	Z+22, r1	; 0x16
    2896:	17 8a       	std	Z+23, r1	; 0x17
			INITIALIZE_Response->DeviceFlags            = CPU_TO_LE32(REMOTE_NDIS_DF_CONNECTIONLESS);
    2898:	80 8f       	std	Z+24, r24	; 0x18
    289a:	91 8f       	std	Z+25, r25	; 0x19
    289c:	a2 8f       	std	Z+26, r26	; 0x1a
    289e:	b3 8f       	std	Z+27, r27	; 0x1b
			INITIALIZE_Response->Medium                 = CPU_TO_LE32(REMOTE_NDIS_MEDIUM_802_3);
    28a0:	14 8e       	std	Z+28, r1	; 0x1c
    28a2:	15 8e       	std	Z+29, r1	; 0x1d
    28a4:	16 8e       	std	Z+30, r1	; 0x1e
    28a6:	17 8e       	std	Z+31, r1	; 0x1f
			INITIALIZE_Response->MaxPacketsPerTransfer  = CPU_TO_LE32(1);
    28a8:	80 a3       	std	Z+32, r24	; 0x20
    28aa:	91 a3       	std	Z+33, r25	; 0x21
    28ac:	a2 a3       	std	Z+34, r26	; 0x22
    28ae:	b3 a3       	std	Z+35, r27	; 0x23
			INITIALIZE_Response->MaxTransferSize        = CPU_TO_LE32(sizeof(RNDIS_Packet_Message_t) + ETHERNET_FRAME_SIZE_MAX);
    28b0:	88 e0       	ldi	r24, 0x08	; 8
    28b2:	96 e0       	ldi	r25, 0x06	; 6
    28b4:	a0 e0       	ldi	r26, 0x00	; 0
    28b6:	b0 e0       	ldi	r27, 0x00	; 0
    28b8:	84 a3       	std	Z+36, r24	; 0x24
    28ba:	95 a3       	std	Z+37, r25	; 0x25
    28bc:	a6 a3       	std	Z+38, r26	; 0x26
    28be:	b7 a3       	std	Z+39, r27	; 0x27
			INITIALIZE_Response->PacketAlignmentFactor  = CPU_TO_LE32(0);
    28c0:	10 a6       	std	Z+40, r1	; 0x28
    28c2:	11 a6       	std	Z+41, r1	; 0x29
    28c4:	12 a6       	std	Z+42, r1	; 0x2a
    28c6:	13 a6       	std	Z+43, r1	; 0x2b
			INITIALIZE_Response->AFListOffset           = CPU_TO_LE32(0);
    28c8:	14 a6       	std	Z+44, r1	; 0x2c
    28ca:	15 a6       	std	Z+45, r1	; 0x2d
    28cc:	16 a6       	std	Z+46, r1	; 0x2e
    28ce:	17 a6       	std	Z+47, r1	; 0x2f
			INITIALIZE_Response->AFListSize             = CPU_TO_LE32(0);
    28d0:	10 aa       	std	Z+48, r1	; 0x30
    28d2:	11 aa       	std	Z+49, r1	; 0x31
    28d4:	12 aa       	std	Z+50, r1	; 0x32
    28d6:	13 aa       	std	Z+51, r1	; 0x33

			RNDISInterfaceInfo->State.CurrRNDISState    = RNDIS_Initialized;
    28d8:	ca 56       	subi	r28, 0x6A	; 106
    28da:	df 4f       	sbci	r29, 0xFF	; 255
    28dc:	28 83       	st	Y, r18
    28de:	15 c2       	rjmp	.+1066   	; 0x2d0a <RNDIS_Device_ProcessControlRequest+0x582>
			break;
		case REMOTE_NDIS_HALT_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = false;
    28e0:	cb 56       	subi	r28, 0x6B	; 107
    28e2:	df 4f       	sbci	r29, 0xFF	; 255
    28e4:	19 92       	st	Y+, r1

			MessageHeader->MessageLength                = CPU_TO_LE32(0);
    28e6:	f8 01       	movw	r30, r16
    28e8:	14 82       	std	Z+4, r1	; 0x04
    28ea:	15 82       	std	Z+5, r1	; 0x05
    28ec:	16 82       	std	Z+6, r1	; 0x06
    28ee:	17 82       	std	Z+7, r1	; 0x07

			RNDISInterfaceInfo->State.CurrRNDISState    = RNDIS_Uninitialized;
    28f0:	18 82       	st	Y, r1
    28f2:	0b c2       	rjmp	.+1046   	; 0x2d0a <RNDIS_Device_ProcessControlRequest+0x582>
			break;
		case REMOTE_NDIS_QUERY_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    28f4:	cb 56       	subi	r28, 0x6B	; 107
    28f6:	df 4f       	sbci	r29, 0xFF	; 255
    28f8:	81 e0       	ldi	r24, 0x01	; 1
    28fa:	88 83       	st	Y, r24
    28fc:	c5 59       	subi	r28, 0x95	; 149
    28fe:	d0 40       	sbci	r29, 0x00	; 0

			RNDIS_Query_Message_t*  QUERY_Message       = (RNDIS_Query_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_Query_Complete_t* QUERY_Response      = (RNDIS_Query_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			uint32_t                Query_Oid           = CPU_TO_LE32(QUERY_Message->Oid);
    2900:	f8 01       	movw	r30, r16
    2902:	24 85       	ldd	r18, Z+12	; 0x0c
    2904:	35 85       	ldd	r19, Z+13	; 0x0d
    2906:	46 85       	ldd	r20, Z+14	; 0x0e
    2908:	57 85       	ldd	r21, Z+15	; 0x0f

			void*    QueryData    = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                                      le32_to_cpu(QUERY_Message->InformationBufferOffset)];
			void*    ResponseData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Query_Complete_t)];
    290a:	fd e2       	ldi	r31, 0x2D	; 45
    290c:	ef 2e       	mov	r14, r31
    290e:	f1 2c       	mov	r15, r1
    2910:	ec 0e       	add	r14, r28
    2912:	fd 1e       	adc	r15, r29
			uint16_t ResponseSize;

			QUERY_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_QUERY_CMPLT);
    2914:	84 e0       	ldi	r24, 0x04	; 4
    2916:	90 e0       	ldi	r25, 0x00	; 0
    2918:	a0 e0       	ldi	r26, 0x00	; 0
    291a:	b0 e8       	ldi	r27, 0x80	; 128
    291c:	8d 8b       	std	Y+21, r24	; 0x15
    291e:	9e 8b       	std	Y+22, r25	; 0x16
    2920:	af 8b       	std	Y+23, r26	; 0x17
    2922:	b8 8f       	std	Y+24, r27	; 0x18
                                          uint16_t* const ResponseSize)
{
	(void)QueryData;
	(void)QuerySize;

	switch (OId)
    2924:	2e 30       	cpi	r18, 0x0E	; 14
    2926:	f1 e0       	ldi	r31, 0x01	; 1
    2928:	3f 07       	cpc	r19, r31
    292a:	f1 e0       	ldi	r31, 0x01	; 1
    292c:	4f 07       	cpc	r20, r31
    292e:	f0 e0       	ldi	r31, 0x00	; 0
    2930:	5f 07       	cpc	r21, r31
    2932:	09 f4       	brne	.+2      	; 0x2936 <RNDIS_Device_ProcessControlRequest+0x1ae>
    2934:	e7 c0       	rjmp	.+462    	; 0x2b04 <RNDIS_Device_ProcessControlRequest+0x37c>
    2936:	2f 30       	cpi	r18, 0x0F	; 15
    2938:	61 e0       	ldi	r22, 0x01	; 1
    293a:	36 07       	cpc	r19, r22
    293c:	61 e0       	ldi	r22, 0x01	; 1
    293e:	46 07       	cpc	r20, r22
    2940:	60 e0       	ldi	r22, 0x00	; 0
    2942:	56 07       	cpc	r21, r22
    2944:	08 f0       	brcs	.+2      	; 0x2948 <RNDIS_Device_ProcessControlRequest+0x1c0>
    2946:	58 c0       	rjmp	.+176    	; 0x29f8 <RNDIS_Device_ProcessControlRequest+0x270>
    2948:	26 30       	cpi	r18, 0x06	; 6
    294a:	81 e0       	ldi	r24, 0x01	; 1
    294c:	38 07       	cpc	r19, r24
    294e:	81 e0       	ldi	r24, 0x01	; 1
    2950:	48 07       	cpc	r20, r24
    2952:	80 e0       	ldi	r24, 0x00	; 0
    2954:	58 07       	cpc	r21, r24
    2956:	09 f4       	brne	.+2      	; 0x295a <RNDIS_Device_ProcessControlRequest+0x1d2>
    2958:	ae c0       	rjmp	.+348    	; 0x2ab6 <RNDIS_Device_ProcessControlRequest+0x32e>
    295a:	27 30       	cpi	r18, 0x07	; 7
    295c:	e1 e0       	ldi	r30, 0x01	; 1
    295e:	3e 07       	cpc	r19, r30
    2960:	e1 e0       	ldi	r30, 0x01	; 1
    2962:	4e 07       	cpc	r20, r30
    2964:	e0 e0       	ldi	r30, 0x00	; 0
    2966:	5e 07       	cpc	r21, r30
    2968:	f8 f4       	brcc	.+62     	; 0x29a8 <RNDIS_Device_ProcessControlRequest+0x220>
    296a:	22 30       	cpi	r18, 0x02	; 2
    296c:	f1 e0       	ldi	r31, 0x01	; 1
    296e:	3f 07       	cpc	r19, r31
    2970:	f1 e0       	ldi	r31, 0x01	; 1
    2972:	4f 07       	cpc	r20, r31
    2974:	f0 e0       	ldi	r31, 0x00	; 0
    2976:	5f 07       	cpc	r21, r31
    2978:	09 f4       	brne	.+2      	; 0x297c <RNDIS_Device_ProcessControlRequest+0x1f4>
    297a:	cd c0       	rjmp	.+410    	; 0x2b16 <RNDIS_Device_ProcessControlRequest+0x38e>
    297c:	23 30       	cpi	r18, 0x03	; 3
    297e:	61 e0       	ldi	r22, 0x01	; 1
    2980:	36 07       	cpc	r19, r22
    2982:	61 e0       	ldi	r22, 0x01	; 1
    2984:	46 07       	cpc	r20, r22
    2986:	60 e0       	ldi	r22, 0x00	; 0
    2988:	56 07       	cpc	r21, r22
    298a:	38 f4       	brcc	.+14     	; 0x299a <RNDIS_Device_ProcessControlRequest+0x212>
    298c:	21 50       	subi	r18, 0x01	; 1
    298e:	31 40       	sbci	r19, 0x01	; 1
    2990:	41 40       	sbci	r20, 0x01	; 1
    2992:	50 40       	sbci	r21, 0x00	; 0
    2994:	09 f0       	breq	.+2      	; 0x2998 <RNDIS_Device_ProcessControlRequest+0x210>
    2996:	cf c0       	rjmp	.+414    	; 0x2b36 <RNDIS_Device_ProcessControlRequest+0x3ae>
    2998:	80 c0       	rjmp	.+256    	; 0x2a9a <RNDIS_Device_ProcessControlRequest+0x312>
    299a:	25 50       	subi	r18, 0x05	; 5
    299c:	31 40       	sbci	r19, 0x01	; 1
    299e:	41 40       	sbci	r20, 0x01	; 1
    29a0:	50 40       	sbci	r21, 0x00	; 0
    29a2:	08 f0       	brcs	.+2      	; 0x29a6 <RNDIS_Device_ProcessControlRequest+0x21e>
    29a4:	c8 c0       	rjmp	.+400    	; 0x2b36 <RNDIS_Device_ProcessControlRequest+0x3ae>
    29a6:	b7 c0       	rjmp	.+366    	; 0x2b16 <RNDIS_Device_ProcessControlRequest+0x38e>
    29a8:	2c 30       	cpi	r18, 0x0C	; 12
    29aa:	f1 e0       	ldi	r31, 0x01	; 1
    29ac:	3f 07       	cpc	r19, r31
    29ae:	f1 e0       	ldi	r31, 0x01	; 1
    29b0:	4f 07       	cpc	r20, r31
    29b2:	f0 e0       	ldi	r31, 0x00	; 0
    29b4:	5f 07       	cpc	r21, r31
    29b6:	80 f4       	brcc	.+32     	; 0x29d8 <RNDIS_Device_ProcessControlRequest+0x250>
    29b8:	2a 30       	cpi	r18, 0x0A	; 10
    29ba:	61 e0       	ldi	r22, 0x01	; 1
    29bc:	36 07       	cpc	r19, r22
    29be:	61 e0       	ldi	r22, 0x01	; 1
    29c0:	46 07       	cpc	r20, r22
    29c2:	60 e0       	ldi	r22, 0x00	; 0
    29c4:	56 07       	cpc	r21, r22
    29c6:	08 f0       	brcs	.+2      	; 0x29ca <RNDIS_Device_ProcessControlRequest+0x242>
    29c8:	76 c0       	rjmp	.+236    	; 0x2ab6 <RNDIS_Device_ProcessControlRequest+0x32e>
    29ca:	27 50       	subi	r18, 0x07	; 7
    29cc:	31 40       	sbci	r19, 0x01	; 1
    29ce:	41 40       	sbci	r20, 0x01	; 1
    29d0:	50 40       	sbci	r21, 0x00	; 0
    29d2:	09 f0       	breq	.+2      	; 0x29d6 <RNDIS_Device_ProcessControlRequest+0x24e>
    29d4:	b0 c0       	rjmp	.+352    	; 0x2b36 <RNDIS_Device_ProcessControlRequest+0x3ae>
    29d6:	81 c0       	rjmp	.+258    	; 0x2ada <RNDIS_Device_ProcessControlRequest+0x352>
    29d8:	2c 30       	cpi	r18, 0x0C	; 12
    29da:	e1 e0       	ldi	r30, 0x01	; 1
    29dc:	3e 07       	cpc	r19, r30
    29de:	e1 e0       	ldi	r30, 0x01	; 1
    29e0:	4e 07       	cpc	r20, r30
    29e2:	e0 e0       	ldi	r30, 0x00	; 0
    29e4:	5e 07       	cpc	r21, r30
    29e6:	09 f4       	brne	.+2      	; 0x29ea <RNDIS_Device_ProcessControlRequest+0x262>
    29e8:	61 c0       	rjmp	.+194    	; 0x2aac <RNDIS_Device_ProcessControlRequest+0x324>
    29ea:	2d 50       	subi	r18, 0x0D	; 13
    29ec:	31 40       	sbci	r19, 0x01	; 1
    29ee:	41 40       	sbci	r20, 0x01	; 1
    29f0:	50 40       	sbci	r21, 0x00	; 0
    29f2:	09 f0       	breq	.+2      	; 0x29f6 <RNDIS_Device_ProcessControlRequest+0x26e>
    29f4:	a0 c0       	rjmp	.+320    	; 0x2b36 <RNDIS_Device_ProcessControlRequest+0x3ae>
    29f6:	64 c0       	rjmp	.+200    	; 0x2ac0 <RNDIS_Device_ProcessControlRequest+0x338>
    29f8:	26 30       	cpi	r18, 0x06	; 6
    29fa:	61 e0       	ldi	r22, 0x01	; 1
    29fc:	36 07       	cpc	r19, r22
    29fe:	62 e0       	ldi	r22, 0x02	; 2
    2a00:	46 07       	cpc	r20, r22
    2a02:	60 e0       	ldi	r22, 0x00	; 0
    2a04:	56 07       	cpc	r21, r22
    2a06:	10 f5       	brcc	.+68     	; 0x2a4c <RNDIS_Device_ProcessControlRequest+0x2c4>
    2a08:	21 30       	cpi	r18, 0x01	; 1
    2a0a:	81 e0       	ldi	r24, 0x01	; 1
    2a0c:	38 07       	cpc	r19, r24
    2a0e:	82 e0       	ldi	r24, 0x02	; 2
    2a10:	48 07       	cpc	r20, r24
    2a12:	80 e0       	ldi	r24, 0x00	; 0
    2a14:	58 07       	cpc	r21, r24
    2a16:	08 f0       	brcs	.+2      	; 0x2a1a <RNDIS_Device_ProcessControlRequest+0x292>
    2a18:	7e c0       	rjmp	.+252    	; 0x2b16 <RNDIS_Device_ProcessControlRequest+0x38e>
    2a1a:	24 31       	cpi	r18, 0x14	; 20
    2a1c:	e1 e0       	ldi	r30, 0x01	; 1
    2a1e:	3e 07       	cpc	r19, r30
    2a20:	e1 e0       	ldi	r30, 0x01	; 1
    2a22:	4e 07       	cpc	r20, r30
    2a24:	e0 e0       	ldi	r30, 0x00	; 0
    2a26:	5e 07       	cpc	r21, r30
    2a28:	09 f4       	brne	.+2      	; 0x2a2c <RNDIS_Device_ProcessControlRequest+0x2a4>
    2a2a:	75 c0       	rjmp	.+234    	; 0x2b16 <RNDIS_Device_ProcessControlRequest+0x38e>
    2a2c:	22 30       	cpi	r18, 0x02	; 2
    2a2e:	f2 e0       	ldi	r31, 0x02	; 2
    2a30:	3f 07       	cpc	r19, r31
    2a32:	f1 e0       	ldi	r31, 0x01	; 1
    2a34:	4f 07       	cpc	r20, r31
    2a36:	f0 e0       	ldi	r31, 0x00	; 0
    2a38:	5f 07       	cpc	r21, r31
    2a3a:	09 f4       	brne	.+2      	; 0x2a3e <RNDIS_Device_ProcessControlRequest+0x2b6>
    2a3c:	6c c0       	rjmp	.+216    	; 0x2b16 <RNDIS_Device_ProcessControlRequest+0x38e>
    2a3e:	21 51       	subi	r18, 0x11	; 17
    2a40:	31 40       	sbci	r19, 0x01	; 1
    2a42:	41 40       	sbci	r20, 0x01	; 1
    2a44:	50 40       	sbci	r21, 0x00	; 0
    2a46:	09 f0       	breq	.+2      	; 0x2a4a <RNDIS_Device_ProcessControlRequest+0x2c2>
    2a48:	76 c0       	rjmp	.+236    	; 0x2b36 <RNDIS_Device_ProcessControlRequest+0x3ae>
    2a4a:	6a c0       	rjmp	.+212    	; 0x2b20 <RNDIS_Device_ProcessControlRequest+0x398>
    2a4c:	24 30       	cpi	r18, 0x04	; 4
    2a4e:	81 e0       	ldi	r24, 0x01	; 1
    2a50:	38 07       	cpc	r19, r24
    2a52:	81 e0       	ldi	r24, 0x01	; 1
    2a54:	48 07       	cpc	r20, r24
    2a56:	81 e0       	ldi	r24, 0x01	; 1
    2a58:	58 07       	cpc	r21, r24
    2a5a:	09 f4       	brne	.+2      	; 0x2a5e <RNDIS_Device_ProcessControlRequest+0x2d6>
    2a5c:	4e c0       	rjmp	.+156    	; 0x2afa <RNDIS_Device_ProcessControlRequest+0x372>
    2a5e:	25 30       	cpi	r18, 0x05	; 5
    2a60:	e1 e0       	ldi	r30, 0x01	; 1
    2a62:	3e 07       	cpc	r19, r30
    2a64:	e1 e0       	ldi	r30, 0x01	; 1
    2a66:	4e 07       	cpc	r20, r30
    2a68:	e1 e0       	ldi	r30, 0x01	; 1
    2a6a:	5e 07       	cpc	r21, r30
    2a6c:	58 f4       	brcc	.+22     	; 0x2a84 <RNDIS_Device_ProcessControlRequest+0x2fc>
    2a6e:	21 50       	subi	r18, 0x01	; 1
    2a70:	31 40       	sbci	r19, 0x01	; 1
    2a72:	41 40       	sbci	r20, 0x01	; 1
    2a74:	51 40       	sbci	r21, 0x01	; 1
    2a76:	22 30       	cpi	r18, 0x02	; 2
    2a78:	31 05       	cpc	r19, r1
    2a7a:	41 05       	cpc	r20, r1
    2a7c:	51 05       	cpc	r21, r1
    2a7e:	08 f0       	brcs	.+2      	; 0x2a82 <RNDIS_Device_ProcessControlRequest+0x2fa>
    2a80:	5a c0       	rjmp	.+180    	; 0x2b36 <RNDIS_Device_ProcessControlRequest+0x3ae>
    2a82:	30 c0       	rjmp	.+96     	; 0x2ae4 <RNDIS_Device_ProcessControlRequest+0x35c>
    2a84:	21 50       	subi	r18, 0x01	; 1
    2a86:	31 40       	sbci	r19, 0x01	; 1
    2a88:	42 40       	sbci	r20, 0x02	; 2
    2a8a:	51 40       	sbci	r21, 0x01	; 1
    2a8c:	23 30       	cpi	r18, 0x03	; 3
    2a8e:	31 05       	cpc	r19, r1
    2a90:	41 05       	cpc	r20, r1
    2a92:	51 05       	cpc	r21, r1
    2a94:	08 f0       	brcs	.+2      	; 0x2a98 <RNDIS_Device_ProcessControlRequest+0x310>
    2a96:	4f c0       	rjmp	.+158    	; 0x2b36 <RNDIS_Device_ProcessControlRequest+0x3ae>
    2a98:	3e c0       	rjmp	.+124    	; 0x2b16 <RNDIS_Device_ProcessControlRequest+0x38e>
	{
		case OID_GEN_SUPPORTED_LIST:
			*ResponseSize = sizeof(AdapterSupportedOIDList);

			memcpy_P(ResponseData, AdapterSupportedOIDList, sizeof(AdapterSupportedOIDList));
    2a9a:	c7 01       	movw	r24, r14
    2a9c:	66 eb       	ldi	r22, 0xB6	; 182
    2a9e:	73 e0       	ldi	r23, 0x03	; 3
    2aa0:	4c e6       	ldi	r20, 0x6C	; 108
    2aa2:	50 e0       	ldi	r21, 0x00	; 0
    2aa4:	75 d1       	rcall	.+746    	; 0x2d90 <memcpy_P>
    2aa6:	cc e6       	ldi	r28, 0x6C	; 108
    2aa8:	d0 e0       	ldi	r29, 0x00	; 0
    2aaa:	12 c1       	rjmp	.+548    	; 0x2cd0 <RNDIS_Device_ProcessControlRequest+0x548>
			return true;
		case OID_GEN_VENDOR_ID:
			*ResponseSize = sizeof(uint32_t);

			/* Vendor ID 0x0xFFFFFF is reserved for vendors who have not purchased a NDIS VID */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(0x00FFFFFF);
    2aac:	8f ef       	ldi	r24, 0xFF	; 255
    2aae:	9f ef       	ldi	r25, 0xFF	; 255
    2ab0:	af ef       	ldi	r26, 0xFF	; 255
    2ab2:	b0 e0       	ldi	r27, 0x00	; 0
    2ab4:	39 c0       	rjmp	.+114    	; 0x2b28 <RNDIS_Device_ProcessControlRequest+0x3a0>
		case OID_GEN_MAXIMUM_FRAME_SIZE:
		case OID_GEN_TRANSMIT_BLOCK_SIZE:
		case OID_GEN_RECEIVE_BLOCK_SIZE:
			*ResponseSize = sizeof(uint32_t);

			*((uint32_t*)ResponseData) = CPU_TO_LE32(ETHERNET_FRAME_SIZE_MAX);
    2ab6:	8c ed       	ldi	r24, 0xDC	; 220
    2ab8:	95 e0       	ldi	r25, 0x05	; 5
    2aba:	a0 e0       	ldi	r26, 0x00	; 0
    2abc:	b0 e0       	ldi	r27, 0x00	; 0
    2abe:	34 c0       	rjmp	.+104    	; 0x2b28 <RNDIS_Device_ProcessControlRequest+0x3a0>

			return true;
		case OID_GEN_VENDOR_DESCRIPTION:
			*ResponseSize = (strlen(RNDISInterfaceInfo->Config.AdapterVendorDescription) + 1);
    2ac0:	6d 85       	ldd	r22, Y+13	; 0x0d
    2ac2:	7e 85       	ldd	r23, Y+14	; 0x0e
    2ac4:	fb 01       	movw	r30, r22
    2ac6:	ef 01       	movw	r28, r30
    2ac8:	09 90       	ld	r0, Y+
    2aca:	00 20       	and	r0, r0
    2acc:	e9 f7       	brne	.-6      	; 0x2ac8 <RNDIS_Device_ProcessControlRequest+0x340>
    2ace:	ce 1b       	sub	r28, r30
    2ad0:	df 0b       	sbc	r29, r31

			memcpy(ResponseData, RNDISInterfaceInfo->Config.AdapterVendorDescription, *ResponseSize);
    2ad2:	c7 01       	movw	r24, r14
    2ad4:	ae 01       	movw	r20, r28
    2ad6:	91 d1       	rcall	.+802    	; 0x2dfa <memcpy>
    2ad8:	fb c0       	rjmp	.+502    	; 0x2cd0 <RNDIS_Device_ProcessControlRequest+0x548>
			return true;
		case OID_GEN_LINK_SPEED:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate 10Mb/s link speed */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(100000);
    2ada:	80 ea       	ldi	r24, 0xA0	; 160
    2adc:	96 e8       	ldi	r25, 0x86	; 134
    2ade:	a1 e0       	ldi	r26, 0x01	; 1
    2ae0:	b0 e0       	ldi	r27, 0x00	; 0
    2ae2:	22 c0       	rjmp	.+68     	; 0x2b28 <RNDIS_Device_ProcessControlRequest+0x3a0>
			return true;
		case OID_802_3_PERMANENT_ADDRESS:
		case OID_802_3_CURRENT_ADDRESS:
			*ResponseSize = sizeof(MAC_Address_t);

			memcpy(ResponseData, &RNDISInterfaceInfo->Config.AdapterMACAddress, sizeof(MAC_Address_t));
    2ae4:	d7 01       	movw	r26, r14
    2ae6:	fe 01       	movw	r30, r28
    2ae8:	3f 96       	adiw	r30, 0x0f	; 15
    2aea:	86 e0       	ldi	r24, 0x06	; 6
    2aec:	01 90       	ld	r0, Z+
    2aee:	0d 92       	st	X+, r0
    2af0:	81 50       	subi	r24, 0x01	; 1
    2af2:	e1 f7       	brne	.-8      	; 0x2aec <RNDIS_Device_ProcessControlRequest+0x364>
    2af4:	c6 e0       	ldi	r28, 0x06	; 6
    2af6:	d0 e0       	ldi	r29, 0x00	; 0
    2af8:	eb c0       	rjmp	.+470    	; 0x2cd0 <RNDIS_Device_ProcessControlRequest+0x548>
			return true;
		case OID_802_3_MAXIMUM_LIST_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate only one multicast address supported */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(1);
    2afa:	81 e0       	ldi	r24, 0x01	; 1
    2afc:	90 e0       	ldi	r25, 0x00	; 0
    2afe:	a0 e0       	ldi	r26, 0x00	; 0
    2b00:	b0 e0       	ldi	r27, 0x00	; 0
    2b02:	12 c0       	rjmp	.+36     	; 0x2b28 <RNDIS_Device_ProcessControlRequest+0x3a0>

			return true;
		case OID_GEN_CURRENT_PACKET_FILTER:
			*ResponseSize = sizeof(uint32_t);

			*((uint32_t*)ResponseData) = cpu_to_le32(RNDISInterfaceInfo->State.CurrPacketFilter);
    2b04:	c9 56       	subi	r28, 0x69	; 105
    2b06:	df 4f       	sbci	r29, 0xFF	; 255
    2b08:	88 81       	ld	r24, Y
    2b0a:	99 81       	ldd	r25, Y+1	; 0x01
    2b0c:	aa 81       	ldd	r26, Y+2	; 0x02
    2b0e:	bb 81       	ldd	r27, Y+3	; 0x03
    2b10:	c7 59       	subi	r28, 0x97	; 151
    2b12:	d0 40       	sbci	r29, 0x00	; 0
    2b14:	09 c0       	rjmp	.+18     	; 0x2b28 <RNDIS_Device_ProcessControlRequest+0x3a0>
		case OID_802_3_XMIT_ONE_COLLISION:
		case OID_802_3_XMIT_MORE_COLLISIONS:
			*ResponseSize = sizeof(uint32_t);

			/* Unused statistic OIDs - always return 0 for each */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(0);
    2b16:	1d a6       	std	Y+45, r1	; 0x2d
    2b18:	1e a6       	std	Y+46, r1	; 0x2e
    2b1a:	1f a6       	std	Y+47, r1	; 0x2f
    2b1c:	18 aa       	std	Y+48, r1	; 0x30
    2b1e:	08 c0       	rjmp	.+16     	; 0x2b30 <RNDIS_Device_ProcessControlRequest+0x3a8>
			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate maximum overall buffer (Ethernet frame and RNDIS header) the adapter can handle */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(RNDIS_MESSAGE_BUFFER_SIZE + ETHERNET_FRAME_SIZE_MAX);
    2b20:	8c e5       	ldi	r24, 0x5C	; 92
    2b22:	96 e0       	ldi	r25, 0x06	; 6
    2b24:	a0 e0       	ldi	r26, 0x00	; 0
    2b26:	b0 e0       	ldi	r27, 0x00	; 0
    2b28:	8d a7       	std	Y+45, r24	; 0x2d
    2b2a:	9e a7       	std	Y+46, r25	; 0x2e
    2b2c:	af a7       	std	Y+47, r26	; 0x2f
    2b2e:	b8 ab       	std	Y+48, r27	; 0x30
    2b30:	c4 e0       	ldi	r28, 0x04	; 4
    2b32:	d0 e0       	ldi	r29, 0x00	; 0
    2b34:	cd c0       	rjmp	.+410    	; 0x2cd0 <RNDIS_Device_ProcessControlRequest+0x548>
				QUERY_Response->InformationBufferLength = CPU_TO_LE32(ResponseSize);
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
			}
			else
			{
				QUERY_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_NOT_SUPPORTED);
    2b36:	8b eb       	ldi	r24, 0xBB	; 187
    2b38:	90 e0       	ldi	r25, 0x00	; 0
    2b3a:	a0 e0       	ldi	r26, 0x00	; 0
    2b3c:	b0 ec       	ldi	r27, 0xC0	; 192
    2b3e:	f8 01       	movw	r30, r16
    2b40:	84 87       	std	Z+12, r24	; 0x0c
    2b42:	95 87       	std	Z+13, r25	; 0x0d
    2b44:	a6 87       	std	Z+14, r26	; 0x0e
    2b46:	b7 87       	std	Z+15, r27	; 0x0f
				QUERY_Response->MessageLength           = CPU_TO_LE32(sizeof(RNDIS_Query_Complete_t));
    2b48:	88 e1       	ldi	r24, 0x18	; 24
    2b4a:	90 e0       	ldi	r25, 0x00	; 0
    2b4c:	a0 e0       	ldi	r26, 0x00	; 0
    2b4e:	b0 e0       	ldi	r27, 0x00	; 0
    2b50:	84 83       	std	Z+4, r24	; 0x04
    2b52:	95 83       	std	Z+5, r25	; 0x05
    2b54:	a6 83       	std	Z+6, r26	; 0x06
    2b56:	b7 83       	std	Z+7, r27	; 0x07

				QUERY_Response->InformationBufferLength = CPU_TO_LE32(0);
    2b58:	10 8a       	std	Z+16, r1	; 0x10
    2b5a:	11 8a       	std	Z+17, r1	; 0x11
    2b5c:	12 8a       	std	Z+18, r1	; 0x12
    2b5e:	13 8a       	std	Z+19, r1	; 0x13
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(0);
    2b60:	14 8a       	std	Z+20, r1	; 0x14
    2b62:	15 8a       	std	Z+21, r1	; 0x15
    2b64:	16 8a       	std	Z+22, r1	; 0x16
    2b66:	17 8a       	std	Z+23, r1	; 0x17
    2b68:	d0 c0       	rjmp	.+416    	; 0x2d0a <RNDIS_Device_ProcessControlRequest+0x582>
			}

			break;
		case REMOTE_NDIS_SET_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    2b6a:	cb 56       	subi	r28, 0x6B	; 107
    2b6c:	df 4f       	sbci	r29, 0xFF	; 255
    2b6e:	81 e0       	ldi	r24, 0x01	; 1
    2b70:	88 83       	st	Y, r24
    2b72:	c5 59       	subi	r28, 0x95	; 149
    2b74:	d0 40       	sbci	r29, 0x00	; 0

			RNDIS_Set_Message_t*  SET_Message           = (RNDIS_Set_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_Set_Complete_t* SET_Response          = (RNDIS_Set_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			uint32_t              SET_Oid               = le32_to_cpu(SET_Message->Oid);
    2b76:	f8 01       	movw	r30, r16
    2b78:	24 85       	ldd	r18, Z+12	; 0x0c
    2b7a:	35 85       	ldd	r19, Z+13	; 0x0d
    2b7c:	46 85       	ldd	r20, Z+14	; 0x0e
    2b7e:	57 85       	ldd	r21, Z+15	; 0x0f

			SET_Response->MessageType                   = CPU_TO_LE32(REMOTE_NDIS_SET_CMPLT);
    2b80:	85 e0       	ldi	r24, 0x05	; 5
    2b82:	90 e0       	ldi	r25, 0x00	; 0
    2b84:	a0 e0       	ldi	r26, 0x00	; 0
    2b86:	b0 e8       	ldi	r27, 0x80	; 128
    2b88:	8d 8b       	std	Y+21, r24	; 0x15
    2b8a:	9e 8b       	std	Y+22, r25	; 0x16
    2b8c:	af 8b       	std	Y+23, r26	; 0x17
    2b8e:	b8 8f       	std	Y+24, r27	; 0x18
			SET_Response->MessageLength                 = CPU_TO_LE32(sizeof(RNDIS_Set_Complete_t));
    2b90:	80 e1       	ldi	r24, 0x10	; 16
    2b92:	90 e0       	ldi	r25, 0x00	; 0
    2b94:	a0 e0       	ldi	r26, 0x00	; 0
    2b96:	b0 e0       	ldi	r27, 0x00	; 0
    2b98:	84 83       	std	Z+4, r24	; 0x04
    2b9a:	95 83       	std	Z+5, r25	; 0x05
    2b9c:	a6 83       	std	Z+6, r26	; 0x06
    2b9e:	b7 83       	std	Z+7, r27	; 0x07
			SET_Response->RequestId                     = SET_Message->RequestId;

			void* SetData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];
    2ba0:	84 89       	ldd	r24, Z+20	; 0x14
    2ba2:	95 89       	ldd	r25, Z+21	; 0x15
    2ba4:	a6 89       	ldd	r26, Z+22	; 0x16
    2ba6:	b7 89       	ldd	r27, Z+23	; 0x17
                                        const void* SetData,
                                        const uint16_t SetSize)
{
	(void)SetSize;

	switch (OId)
    2ba8:	2e 30       	cpi	r18, 0x0E	; 14
    2baa:	f1 e0       	ldi	r31, 0x01	; 1
    2bac:	3f 07       	cpc	r19, r31
    2bae:	f1 e0       	ldi	r31, 0x01	; 1
    2bb0:	4f 07       	cpc	r20, r31
    2bb2:	f0 e0       	ldi	r31, 0x00	; 0
    2bb4:	5f 07       	cpc	r21, r31
    2bb6:	51 f0       	breq	.+20     	; 0x2bcc <RNDIS_Device_ProcessControlRequest+0x444>
    2bb8:	23 50       	subi	r18, 0x03	; 3
    2bba:	31 40       	sbci	r19, 0x01	; 1
    2bbc:	41 40       	sbci	r20, 0x01	; 1
    2bbe:	51 40       	sbci	r21, 0x01	; 1
    2bc0:	a9 f0       	breq	.+42     	; 0x2bec <RNDIS_Device_ProcessControlRequest+0x464>
    2bc2:	8b eb       	ldi	r24, 0xBB	; 187
    2bc4:	90 e0       	ldi	r25, 0x00	; 0
    2bc6:	a0 e0       	ldi	r26, 0x00	; 0
    2bc8:	b0 ec       	ldi	r27, 0xC0	; 192
    2bca:	14 c0       	rjmp	.+40     	; 0x2bf4 <RNDIS_Device_ProcessControlRequest+0x46c>
	{
		case OID_GEN_CURRENT_PACKET_FILTER:
			RNDISInterfaceInfo->State.CurrPacketFilter = le32_to_cpu(*((uint32_t*)SetData));
    2bcc:	fe 01       	movw	r30, r28
    2bce:	e8 0f       	add	r30, r24
    2bd0:	f9 1f       	adc	r31, r25
    2bd2:	85 8d       	ldd	r24, Z+29	; 0x1d
    2bd4:	96 8d       	ldd	r25, Z+30	; 0x1e
    2bd6:	a7 8d       	ldd	r26, Z+31	; 0x1f
    2bd8:	b0 a1       	ldd	r27, Z+32	; 0x20
    2bda:	c9 56       	subi	r28, 0x69	; 105
    2bdc:	df 4f       	sbci	r29, 0xFF	; 255
    2bde:	88 83       	st	Y, r24
    2be0:	99 83       	std	Y+1, r25	; 0x01
    2be2:	aa 83       	std	Y+2, r26	; 0x02
    2be4:	bb 83       	std	Y+3, r27	; 0x03
			RNDISInterfaceInfo->State.CurrRNDISState   = le32_to_cpu((RNDISInterfaceInfo->State.CurrPacketFilter) ?
    2be6:	fe 01       	movw	r30, r28
    2be8:	82 e0       	ldi	r24, 0x02	; 2
    2bea:	82 93       	st	-Z, r24
    2bec:	80 e0       	ldi	r24, 0x00	; 0
    2bee:	90 e0       	ldi	r25, 0x00	; 0
    2bf0:	a0 e0       	ldi	r26, 0x00	; 0
    2bf2:	b0 e0       	ldi	r27, 0x00	; 0
			SET_Response->RequestId                     = SET_Message->RequestId;

			void* SetData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];

			SET_Response->Status = RNDIS_Device_ProcessNDISSet(RNDISInterfaceInfo, SET_Oid, SetData,
    2bf4:	f8 01       	movw	r30, r16
    2bf6:	84 87       	std	Z+12, r24	; 0x0c
    2bf8:	95 87       	std	Z+13, r25	; 0x0d
    2bfa:	a6 87       	std	Z+14, r26	; 0x0e
    2bfc:	b7 87       	std	Z+15, r27	; 0x0f
    2bfe:	85 c0       	rjmp	.+266    	; 0x2d0a <RNDIS_Device_ProcessControlRequest+0x582>
			                                                   le32_to_cpu(SET_Message->InformationBufferLength)) ?
			                                                   REMOTE_NDIS_STATUS_SUCCESS : REMOTE_NDIS_STATUS_NOT_SUPPORTED;
			break;
		case REMOTE_NDIS_RESET_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    2c00:	cb 56       	subi	r28, 0x6B	; 107
    2c02:	df 4f       	sbci	r29, 0xFF	; 255
    2c04:	81 e0       	ldi	r24, 0x01	; 1
    2c06:	88 83       	st	Y, r24
    2c08:	c5 59       	subi	r28, 0x95	; 149
    2c0a:	d0 40       	sbci	r29, 0x00	; 0

			RNDIS_Reset_Complete_t* RESET_Response      = (RNDIS_Reset_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			RESET_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_RESET_CMPLT);
    2c0c:	86 e0       	ldi	r24, 0x06	; 6
    2c0e:	90 e0       	ldi	r25, 0x00	; 0
    2c10:	a0 e0       	ldi	r26, 0x00	; 0
    2c12:	b0 e8       	ldi	r27, 0x80	; 128
    2c14:	8d 8b       	std	Y+21, r24	; 0x15
    2c16:	9e 8b       	std	Y+22, r25	; 0x16
    2c18:	af 8b       	std	Y+23, r26	; 0x17
    2c1a:	b8 8f       	std	Y+24, r27	; 0x18
			RESET_Response->MessageLength               = CPU_TO_LE32(sizeof(RNDIS_Reset_Complete_t));
    2c1c:	80 e1       	ldi	r24, 0x10	; 16
    2c1e:	90 e0       	ldi	r25, 0x00	; 0
    2c20:	a0 e0       	ldi	r26, 0x00	; 0
    2c22:	b0 e0       	ldi	r27, 0x00	; 0
    2c24:	f8 01       	movw	r30, r16
    2c26:	84 83       	std	Z+4, r24	; 0x04
    2c28:	95 83       	std	Z+5, r25	; 0x05
    2c2a:	a6 83       	std	Z+6, r26	; 0x06
    2c2c:	b7 83       	std	Z+7, r27	; 0x07
			RESET_Response->Status                      = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    2c2e:	10 86       	std	Z+8, r1	; 0x08
    2c30:	11 86       	std	Z+9, r1	; 0x09
    2c32:	12 86       	std	Z+10, r1	; 0x0a
    2c34:	13 86       	std	Z+11, r1	; 0x0b
    2c36:	17 c0       	rjmp	.+46     	; 0x2c66 <RNDIS_Device_ProcessControlRequest+0x4de>
			RESET_Response->AddressingReset             = CPU_TO_LE32(0);

			break;
		case REMOTE_NDIS_KEEPALIVE_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    2c38:	cb 56       	subi	r28, 0x6B	; 107
    2c3a:	df 4f       	sbci	r29, 0xFF	; 255
    2c3c:	81 e0       	ldi	r24, 0x01	; 1
    2c3e:	88 83       	st	Y, r24
    2c40:	c5 59       	subi	r28, 0x95	; 149
    2c42:	d0 40       	sbci	r29, 0x00	; 0
			RNDIS_KeepAlive_Message_t*  KEEPALIVE_Message  =
			                (RNDIS_KeepAlive_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_KeepAlive_Complete_t* KEEPALIVE_Response =
			                (RNDIS_KeepAlive_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			KEEPALIVE_Response->MessageType             = CPU_TO_LE32(REMOTE_NDIS_KEEPALIVE_CMPLT);
    2c44:	88 e0       	ldi	r24, 0x08	; 8
    2c46:	90 e0       	ldi	r25, 0x00	; 0
    2c48:	a0 e0       	ldi	r26, 0x00	; 0
    2c4a:	b0 e8       	ldi	r27, 0x80	; 128
    2c4c:	8d 8b       	std	Y+21, r24	; 0x15
    2c4e:	9e 8b       	std	Y+22, r25	; 0x16
    2c50:	af 8b       	std	Y+23, r26	; 0x17
    2c52:	b8 8f       	std	Y+24, r27	; 0x18
			KEEPALIVE_Response->MessageLength           = CPU_TO_LE32(sizeof(RNDIS_KeepAlive_Complete_t));
    2c54:	80 e1       	ldi	r24, 0x10	; 16
    2c56:	90 e0       	ldi	r25, 0x00	; 0
    2c58:	a0 e0       	ldi	r26, 0x00	; 0
    2c5a:	b0 e0       	ldi	r27, 0x00	; 0
    2c5c:	f8 01       	movw	r30, r16
    2c5e:	84 83       	std	Z+4, r24	; 0x04
    2c60:	95 83       	std	Z+5, r25	; 0x05
    2c62:	a6 83       	std	Z+6, r26	; 0x06
    2c64:	b7 83       	std	Z+7, r27	; 0x07
			KEEPALIVE_Response->RequestId               = KEEPALIVE_Message->RequestId;
			KEEPALIVE_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    2c66:	14 86       	std	Z+12, r1	; 0x0c
    2c68:	15 86       	std	Z+13, r1	; 0x0d
    2c6a:	16 86       	std	Z+14, r1	; 0x0e
    2c6c:	17 86       	std	Z+15, r1	; 0x0f
    2c6e:	4d c0       	rjmp	.+154    	; 0x2d0a <RNDIS_Device_ProcessControlRequest+0x582>
				RNDIS_Device_ProcessRNDISControlMessage(RNDISInterfaceInfo);
			}

			break;
		case RNDIS_REQ_GetEncapsulatedResponse:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    2c70:	80 91 01 14 	lds	r24, 0x1401
    2c74:	81 3a       	cpi	r24, 0xA1	; 161
    2c76:	09 f0       	breq	.+2      	; 0x2c7a <RNDIS_Device_ProcessControlRequest+0x4f2>
    2c78:	48 c0       	rjmp	.+144    	; 0x2d0a <RNDIS_Device_ProcessControlRequest+0x582>
			{
				RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
    2c7a:	8e 01       	movw	r16, r28
    2c7c:	0b 5e       	subi	r16, 0xEB	; 235
    2c7e:	1f 4f       	sbci	r17, 0xFF	; 255

				if (!(MessageHeader->MessageLength))
    2c80:	f8 01       	movw	r30, r16
    2c82:	84 81       	ldd	r24, Z+4	; 0x04
    2c84:	95 81       	ldd	r25, Z+5	; 0x05
    2c86:	a6 81       	ldd	r26, Z+6	; 0x06
    2c88:	b7 81       	ldd	r27, Z+7	; 0x07
    2c8a:	00 97       	sbiw	r24, 0x00	; 0
    2c8c:	a1 05       	cpc	r26, r1
    2c8e:	b1 05       	cpc	r27, r1
    2c90:	49 f4       	brne	.+18     	; 0x2ca4 <RNDIS_Device_ProcessControlRequest+0x51c>
				{
					RNDISInterfaceInfo->State.RNDISMessageBuffer[0] = 0;
    2c92:	1d 8a       	std	Y+21, r1	; 0x15
					MessageHeader->MessageLength                    = CPU_TO_LE32(1);
    2c94:	81 e0       	ldi	r24, 0x01	; 1
    2c96:	90 e0       	ldi	r25, 0x00	; 0
    2c98:	a0 e0       	ldi	r26, 0x00	; 0
    2c9a:	b0 e0       	ldi	r27, 0x00	; 0
    2c9c:	84 83       	std	Z+4, r24	; 0x04
    2c9e:	95 83       	std	Z+5, r25	; 0x05
    2ca0:	a6 83       	std	Z+6, r26	; 0x06
    2ca2:	b7 83       	std	Z+7, r27	; 0x07
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2ca4:	80 91 e8 00 	lds	r24, 0x00E8
    2ca8:	87 7f       	andi	r24, 0xF7	; 247
    2caa:	80 93 e8 00 	sts	0x00E8, r24
				}

				Endpoint_ClearSETUP();
				Endpoint_Write_Control_Stream_LE(RNDISInterfaceInfo->State.RNDISMessageBuffer, le32_to_cpu(MessageHeader->MessageLength));
    2cae:	f8 01       	movw	r30, r16
    2cb0:	64 81       	ldd	r22, Z+4	; 0x04
    2cb2:	75 81       	ldd	r23, Z+5	; 0x05
    2cb4:	ce 01       	movw	r24, r28
    2cb6:	45 96       	adiw	r24, 0x15	; 21
    2cb8:	c4 d8       	rcall	.-3704   	; 0x1e42 <Endpoint_Write_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2cba:	80 91 e8 00 	lds	r24, 0x00E8
    2cbe:	8b 77       	andi	r24, 0x7B	; 123
    2cc0:	80 93 e8 00 	sts	0x00E8, r24
				Endpoint_ClearOUT();

				MessageHeader->MessageLength = CPU_TO_LE32(0);
    2cc4:	f8 01       	movw	r30, r16
    2cc6:	14 82       	std	Z+4, r1	; 0x04
    2cc8:	15 82       	std	Z+5, r1	; 0x05
    2cca:	16 82       	std	Z+6, r1	; 0x06
    2ccc:	17 82       	std	Z+7, r1	; 0x07
    2cce:	1d c0       	rjmp	.+58     	; 0x2d0a <RNDIS_Device_ProcessControlRequest+0x582>
			QUERY_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_QUERY_CMPLT);

			if (RNDIS_Device_ProcessNDISQuery(RNDISInterfaceInfo, Query_Oid, QueryData, le32_to_cpu(QUERY_Message->InformationBufferLength),
			                                  ResponseData, &ResponseSize))
			{
				QUERY_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    2cd0:	f8 01       	movw	r30, r16
    2cd2:	14 86       	std	Z+12, r1	; 0x0c
    2cd4:	15 86       	std	Z+13, r1	; 0x0d
    2cd6:	16 86       	std	Z+14, r1	; 0x0e
    2cd8:	17 86       	std	Z+15, r1	; 0x0f
				QUERY_Response->MessageLength           = cpu_to_le32(sizeof(RNDIS_Query_Complete_t) + ResponseSize);
    2cda:	68 96       	adiw	r28, 0x18	; 24
    2cdc:	ce 01       	movw	r24, r28
    2cde:	a0 e0       	ldi	r26, 0x00	; 0
    2ce0:	b0 e0       	ldi	r27, 0x00	; 0
    2ce2:	68 97       	sbiw	r28, 0x18	; 24
    2ce4:	84 83       	std	Z+4, r24	; 0x04
    2ce6:	95 83       	std	Z+5, r25	; 0x05
    2ce8:	a6 83       	std	Z+6, r26	; 0x06
    2cea:	b7 83       	std	Z+7, r27	; 0x07

				QUERY_Response->InformationBufferLength = CPU_TO_LE32(ResponseSize);
    2cec:	ce 01       	movw	r24, r28
    2cee:	a0 e0       	ldi	r26, 0x00	; 0
    2cf0:	b0 e0       	ldi	r27, 0x00	; 0
    2cf2:	80 8b       	std	Z+16, r24	; 0x10
    2cf4:	91 8b       	std	Z+17, r25	; 0x11
    2cf6:	a2 8b       	std	Z+18, r26	; 0x12
    2cf8:	b3 8b       	std	Z+19, r27	; 0x13
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
    2cfa:	80 e1       	ldi	r24, 0x10	; 16
    2cfc:	90 e0       	ldi	r25, 0x00	; 0
    2cfe:	a0 e0       	ldi	r26, 0x00	; 0
    2d00:	b0 e0       	ldi	r27, 0x00	; 0
    2d02:	84 8b       	std	Z+20, r24	; 0x14
    2d04:	95 8b       	std	Z+21, r25	; 0x15
    2d06:	a6 8b       	std	Z+22, r26	; 0x16
    2d08:	b7 8b       	std	Z+23, r27	; 0x17
				MessageHeader->MessageLength = CPU_TO_LE32(0);
			}

			break;
	}
}
    2d0a:	df 91       	pop	r29
    2d0c:	cf 91       	pop	r28
    2d0e:	1f 91       	pop	r17
    2d10:	0f 91       	pop	r16
    2d12:	ff 90       	pop	r15
    2d14:	ef 90       	pop	r14
    2d16:	08 95       	ret

00002d18 <Serial_putchar>:

FILE USARTSerialStream;

int Serial_putchar(char DataByte,
                   FILE *Stream)
{
    2d18:	98 2f       	mov	r25, r24
			 *  \param[in] DataByte  Byte to transmit through the USART.
			 */
			static inline void Serial_SendByte(const char DataByte) ATTR_ALWAYS_INLINE;
			static inline void Serial_SendByte(const char DataByte)
			{
				while (!(UCSR1A & (1 << UDRE1)));
    2d1a:	80 91 c8 00 	lds	r24, 0x00C8
    2d1e:	85 ff       	sbrs	r24, 5
    2d20:	fc cf       	rjmp	.-8      	; 0x2d1a <Serial_putchar+0x2>
				UDR1 = DataByte;
    2d22:	90 93 ce 00 	sts	0x00CE, r25
	(void)Stream;

	Serial_SendByte(DataByte);
	return 0;
}
    2d26:	80 e0       	ldi	r24, 0x00	; 0
    2d28:	90 e0       	ldi	r25, 0x00	; 0
    2d2a:	08 95       	ret

00002d2c <Serial_getchar>:
			 *  \return Boolean \c true if a character has been received, \c false otherwise.
			 */
			static inline bool Serial_IsCharReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Serial_IsCharReceived(void)
			{
				return ((UCSR1A & (1 << RXC1)) ? true : false);
    2d2c:	80 91 c8 00 	lds	r24, 0x00C8

int Serial_getchar(FILE *Stream)
{
	(void)Stream;

	if (!(Serial_IsCharReceived()))
    2d30:	87 fd       	sbrc	r24, 7
    2d32:	03 c0       	rjmp	.+6      	; 0x2d3a <Serial_getchar+0xe>
    2d34:	2e ef       	ldi	r18, 0xFE	; 254
    2d36:	3f ef       	ldi	r19, 0xFF	; 255
    2d38:	0b c0       	rjmp	.+22     	; 0x2d50 <Serial_getchar+0x24>
    2d3a:	80 91 c8 00 	lds	r24, 0x00C8
			 *  \return Next byte received from the USART, or a negative value if no byte has been received.
			 */
			static inline int16_t Serial_ReceiveByte(void) ATTR_ALWAYS_INLINE;
			static inline int16_t Serial_ReceiveByte(void)
			{
				if (!(Serial_IsCharReceived()))
    2d3e:	87 fd       	sbrc	r24, 7
    2d40:	03 c0       	rjmp	.+6      	; 0x2d48 <Serial_getchar+0x1c>
    2d42:	2f ef       	ldi	r18, 0xFF	; 255
    2d44:	3f ef       	ldi	r19, 0xFF	; 255
    2d46:	04 c0       	rjmp	.+8      	; 0x2d50 <Serial_getchar+0x24>
				  return -1;

				return UDR1;
    2d48:	80 91 ce 00 	lds	r24, 0x00CE
    2d4c:	28 2f       	mov	r18, r24
    2d4e:	30 e0       	ldi	r19, 0x00	; 0
	  return _FDEV_EOF;

	return Serial_ReceiveByte();
}
    2d50:	c9 01       	movw	r24, r18
    2d52:	08 95       	ret

00002d54 <Serial_CreateStream>:
	while (Length--)
	  Serial_SendByte(*(Buffer++));
}

void Serial_CreateStream(FILE* Stream)
{
    2d54:	fc 01       	movw	r30, r24
	if (!(Stream))
    2d56:	00 97       	sbiw	r24, 0x00	; 0
    2d58:	59 f4       	brne	.+22     	; 0x2d70 <Serial_CreateStream+0x1c>
	{
		Stream = &USARTSerialStream;
		stdin  = Stream;
    2d5a:	89 e0       	ldi	r24, 0x09	; 9
    2d5c:	94 e1       	ldi	r25, 0x14	; 20
    2d5e:	90 93 18 14 	sts	0x1418, r25
    2d62:	80 93 17 14 	sts	0x1417, r24
		stdout = Stream;
    2d66:	90 93 1a 14 	sts	0x141A, r25
    2d6a:	80 93 19 14 	sts	0x1419, r24
    2d6e:	fc 01       	movw	r30, r24
	}

	*Stream = (FILE)FDEV_SETUP_STREAM(Serial_putchar, Serial_getchar, _FDEV_SETUP_RW);
    2d70:	8e e0       	ldi	r24, 0x0E	; 14
    2d72:	df 01       	movw	r26, r30
    2d74:	1d 92       	st	X+, r1
    2d76:	8a 95       	dec	r24
    2d78:	e9 f7       	brne	.-6      	; 0x2d74 <Serial_CreateStream+0x20>
    2d7a:	83 e0       	ldi	r24, 0x03	; 3
    2d7c:	83 83       	std	Z+3, r24	; 0x03
    2d7e:	8c e8       	ldi	r24, 0x8C	; 140
    2d80:	96 e1       	ldi	r25, 0x16	; 22
    2d82:	91 87       	std	Z+9, r25	; 0x09
    2d84:	80 87       	std	Z+8, r24	; 0x08
    2d86:	86 e9       	ldi	r24, 0x96	; 150
    2d88:	96 e1       	ldi	r25, 0x16	; 22
    2d8a:	93 87       	std	Z+11, r25	; 0x0b
    2d8c:	82 87       	std	Z+10, r24	; 0x0a
}
    2d8e:	08 95       	ret

00002d90 <memcpy_P>:
    2d90:	fb 01       	movw	r30, r22
    2d92:	dc 01       	movw	r26, r24
    2d94:	02 c0       	rjmp	.+4      	; 0x2d9a <memcpy_P+0xa>
    2d96:	05 90       	lpm	r0, Z+
    2d98:	0d 92       	st	X+, r0
    2d9a:	41 50       	subi	r20, 0x01	; 1
    2d9c:	50 40       	sbci	r21, 0x00	; 0
    2d9e:	d8 f7       	brcc	.-10     	; 0x2d96 <memcpy_P+0x6>
    2da0:	08 95       	ret

00002da2 <strcpy_P>:
    2da2:	fb 01       	movw	r30, r22
    2da4:	dc 01       	movw	r26, r24
    2da6:	05 90       	lpm	r0, Z+
    2da8:	0d 92       	st	X+, r0
    2daa:	00 20       	and	r0, r0
    2dac:	e1 f7       	brne	.-8      	; 0x2da6 <strcpy_P+0x4>
    2dae:	08 95       	ret

00002db0 <strlen_P>:
    2db0:	fc 01       	movw	r30, r24
    2db2:	05 90       	lpm	r0, Z+
    2db4:	00 20       	and	r0, r0
    2db6:	e9 f7       	brne	.-6      	; 0x2db2 <strlen_P+0x2>
    2db8:	80 95       	com	r24
    2dba:	90 95       	com	r25
    2dbc:	8e 0f       	add	r24, r30
    2dbe:	9f 1f       	adc	r25, r31
    2dc0:	08 95       	ret

00002dc2 <strncpy_P>:
    2dc2:	fb 01       	movw	r30, r22
    2dc4:	dc 01       	movw	r26, r24
    2dc6:	41 50       	subi	r20, 0x01	; 1
    2dc8:	50 40       	sbci	r21, 0x00	; 0
    2dca:	48 f0       	brcs	.+18     	; 0x2dde <strncpy_P+0x1c>
    2dcc:	05 90       	lpm	r0, Z+
    2dce:	0d 92       	st	X+, r0
    2dd0:	00 20       	and	r0, r0
    2dd2:	c9 f7       	brne	.-14     	; 0x2dc6 <strncpy_P+0x4>
    2dd4:	01 c0       	rjmp	.+2      	; 0x2dd8 <strncpy_P+0x16>
    2dd6:	1d 92       	st	X+, r1
    2dd8:	41 50       	subi	r20, 0x01	; 1
    2dda:	50 40       	sbci	r21, 0x00	; 0
    2ddc:	e0 f7       	brcc	.-8      	; 0x2dd6 <strncpy_P+0x14>
    2dde:	08 95       	ret

00002de0 <memcmp>:
    2de0:	fb 01       	movw	r30, r22
    2de2:	dc 01       	movw	r26, r24
    2de4:	04 c0       	rjmp	.+8      	; 0x2dee <memcmp+0xe>
    2de6:	8d 91       	ld	r24, X+
    2de8:	01 90       	ld	r0, Z+
    2dea:	80 19       	sub	r24, r0
    2dec:	21 f4       	brne	.+8      	; 0x2df6 <memcmp+0x16>
    2dee:	41 50       	subi	r20, 0x01	; 1
    2df0:	50 40       	sbci	r21, 0x00	; 0
    2df2:	c8 f7       	brcc	.-14     	; 0x2de6 <memcmp+0x6>
    2df4:	88 1b       	sub	r24, r24
    2df6:	99 0b       	sbc	r25, r25
    2df8:	08 95       	ret

00002dfa <memcpy>:
    2dfa:	fb 01       	movw	r30, r22
    2dfc:	dc 01       	movw	r26, r24
    2dfe:	02 c0       	rjmp	.+4      	; 0x2e04 <memcpy+0xa>
    2e00:	01 90       	ld	r0, Z+
    2e02:	0d 92       	st	X+, r0
    2e04:	41 50       	subi	r20, 0x01	; 1
    2e06:	50 40       	sbci	r21, 0x00	; 0
    2e08:	d8 f7       	brcc	.-10     	; 0x2e00 <memcpy+0x6>
    2e0a:	08 95       	ret

00002e0c <memmove>:
    2e0c:	68 17       	cp	r22, r24
    2e0e:	79 07       	cpc	r23, r25
    2e10:	68 f4       	brcc	.+26     	; 0x2e2c <memmove+0x20>
    2e12:	fb 01       	movw	r30, r22
    2e14:	dc 01       	movw	r26, r24
    2e16:	e4 0f       	add	r30, r20
    2e18:	f5 1f       	adc	r31, r21
    2e1a:	a4 0f       	add	r26, r20
    2e1c:	b5 1f       	adc	r27, r21
    2e1e:	02 c0       	rjmp	.+4      	; 0x2e24 <memmove+0x18>
    2e20:	02 90       	ld	r0, -Z
    2e22:	0e 92       	st	-X, r0
    2e24:	41 50       	subi	r20, 0x01	; 1
    2e26:	50 40       	sbci	r21, 0x00	; 0
    2e28:	d8 f7       	brcc	.-10     	; 0x2e20 <memmove+0x14>
    2e2a:	08 95       	ret
    2e2c:	e6 cf       	rjmp	.-52     	; 0x2dfa <memcpy>

00002e2e <strncmp>:
    2e2e:	fb 01       	movw	r30, r22
    2e30:	dc 01       	movw	r26, r24
    2e32:	41 50       	subi	r20, 0x01	; 1
    2e34:	50 40       	sbci	r21, 0x00	; 0
    2e36:	30 f0       	brcs	.+12     	; 0x2e44 <strncmp+0x16>
    2e38:	8d 91       	ld	r24, X+
    2e3a:	01 90       	ld	r0, Z+
    2e3c:	80 19       	sub	r24, r0
    2e3e:	19 f4       	brne	.+6      	; 0x2e46 <strncmp+0x18>
    2e40:	00 20       	and	r0, r0
    2e42:	b9 f7       	brne	.-18     	; 0x2e32 <strncmp+0x4>
    2e44:	88 1b       	sub	r24, r24
    2e46:	99 0b       	sbc	r25, r25
    2e48:	08 95       	ret

00002e4a <_exit>:
    2e4a:	f8 94       	cli

00002e4c <__stop_program>:
    2e4c:	ff cf       	rjmp	.-2      	; 0x2e4c <__stop_program>
